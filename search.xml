<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASMR</title>
      <link href="/2023/06/03/ASMR/"/>
      <url>/2023/06/03/ASMR/</url>
      
        <content type="html"><![CDATA[<iframe width="560" height="315" src="https://www.youtube.com/embed/zGRQhDTADQM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> ASMR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASMR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/10/25/git/"/>
      <url>/2022/10/25/git/</url>
      
        <content type="html"><![CDATA[<h1 id="GIt-的常用命令"><a href="#GIt-的常用命令" class="headerlink" title="GIt 的常用命令"></a>GIt 的常用命令</h1><ul><li>查看配置信息：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name<br>git config --global user.email<br></code></pre></td></tr></table></figure><ul><li><p>获取本地仓库:  git init </p></li><li><p>查看修改状态  git status  </p></li><li><p>添加工作区到暂存区 （add）   git add   单个文件名|通配符  . </p></li><li><p>提交暂存区到本地仓库    git commit  -m ‘注释内容’ </p></li><li><p>查看提交日志   git  log  [option] </p><ul><li>options:<ul><li>– all 显示所有分支</li><li>–pretty&#x3D;online 将提交信息显示为一行。</li><li>–abbrev–commit  使得输出的commitid更简短</li><li>–graph 以图的形式显示</li></ul></li></ul></li><li><p>版本回退   git reset  –hard commitID       </p></li><li><p>commitID 可以通过 git  log  或者 git-log   查看</p></li><li><p>git reflog  可以 查看已删除的提交记录</p></li><li><p>查看本地分支：  gti  branch  </p></li><li><p>创建本地分支 ：  git  branch  分支名 </p></li><li><p>切换分支：  git checkout   分支名 </p><ul><li>还可以切换到不存在的（创建并切换：  git checkout -b  分支名)</li></ul></li><li><p>分支合并：  git merge  分支名称</p></li><li><p>删除分支： 不能删除当前分支。 只能删除其他分支。</p></li><li><p>git  branch -d b1  删除分支时需要各种检查。</p></li><li><p>git  branch -D  b1  不做任何检查，强制删除。 </p></li><li><p>删除整个文件夹。</p></li><li><p>#删除文件(如“动画demo.md‘)或者文件夹<br><code>git rm --cached 文件名/git rm -r --cached 文件夹名</code></p></li></ul><p>在开发中，一般有如下分支使用原则与流程：</p><p> master （生产） 分支 线上分支，主分支，中小规模项目作为线上运行的应用对应的分支；</p><p> develop（开发）分支 是从master创建的分支，一般作为开发部门的主要开发分支，如果没有其他并行开发不同期上线 要求，都可以在此版本进行开发，阶段开发完成后，需要是合并到master分支,准备上线。</p><p> feature&#x2F;xxxx分支 从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的研发任务完 成后合并到develop分支。</p><p> hotfix&#x2F;xxxx分支， 从master派生的分支，一般作为线上bug修复使用，修复完成后需要合并到master、test、 develop分支。</p><p> 还有一些其他分支，在此不再详述，例如test分支（用于代码测试）、pre分支（预上线分支）等 等。</p><ul><li><p>查看远程仓库 ：   git remote  </p></li><li><p>克隆远程仓库代码： git clone &lt;远程仓库地址&gt;</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="/2022/10/19/mybatis/"/>
      <url>/2022/10/19/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="第一章-java-ORM-总体概览"><a href="#第一章-java-ORM-总体概览" class="headerlink" title="第一章 java ORM  总体概览"></a>第一章 java ORM  总体概览</h2><h3 id="1-1传统JDBC-编程"><a href="#1-1传统JDBC-编程" class="headerlink" title="1.1传统JDBC  编程"></a>1.1传统JDBC  编程</h3><ul><li><h4 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h4></li></ul><ol><li><h4 id="使用JDBC连接数据库-注册驱动和数据库信息"><a href="#使用JDBC连接数据库-注册驱动和数据库信息" class="headerlink" title="使用JDBC连接数据库,注册驱动和数据库信息"></a>使用JDBC连接数据库,注册驱动和数据库信息</h4></li><li><h4 id="操作Connection-打开Statement-对象"><a href="#操作Connection-打开Statement-对象" class="headerlink" title="操作Connection,打开Statement 对象"></a>操作Connection,打开Statement 对象</h4></li><li><h4 id="通过statement执行sql-返回结果到ResultSet对象"><a href="#通过statement执行sql-返回结果到ResultSet对象" class="headerlink" title="通过statement执行sql.返回结果到ResultSet对象"></a>通过statement执行sql.返回结果到ResultSet对象</h4></li><li><h4 id="使用ResultSet读取数据-然后通过代码转化为具体的pojo对象"><a href="#使用ResultSet读取数据-然后通过代码转化为具体的pojo对象" class="headerlink" title="使用ResultSet读取数据,然后通过代码转化为具体的pojo对象"></a>使用ResultSet读取数据,然后通过代码转化为具体的pojo对象</h4></li><li><h4 id="关闭数据库相关资源"><a href="#关闭数据库相关资源" class="headerlink" title="关闭数据库相关资源."></a>关闭数据库相关资源.</h4></li></ol><ul><li><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端:"></a>弊端:</h4></li></ul><ol><li><h4 id="工作量大"><a href="#工作量大" class="headerlink" title="工作量大"></a>工作量大</h4></li><li><h4 id="对JDBC编程可能产生异常进行捕获并正确关闭资源-对于简单的SQL都很复杂-更不谈更复杂的SQL"><a href="#对JDBC编程可能产生异常进行捕获并正确关闭资源-对于简单的SQL都很复杂-更不谈更复杂的SQL" class="headerlink" title="对JDBC编程可能产生异常进行捕获并正确关闭资源,对于简单的SQL都很复杂,更不谈更复杂的SQL."></a>对JDBC编程可能产生异常进行捕获并正确关闭资源,对于简单的SQL都很复杂,更不谈更复杂的SQL.</h4></li></ol><h3 id="1-2-ORM模型-对象关系映射"><a href="#1-2-ORM模型-对象关系映射" class="headerlink" title="1.2  ORM模型(对象关系映射)"></a>1.2  ORM模型(对象关系映射)</h3><ol><li><h4 id="ORM模型就是数据库的表-和简单的java-对象-POJO-的关系映射模型"><a href="#ORM模型就是数据库的表-和简单的java-对象-POJO-的关系映射模型" class="headerlink" title="ORM模型就是数据库的表 和简单的java 对象(POJO)的关系映射模型"></a>ORM模型就是数据库的表 和简单的java 对象(POJO)的关系映射模型</h4></li><li><h4 id="解决数据库和POJO对象的相呼映射-x3D-x3D-通过这层映射关系可以简单地把数据库表中的数据转化为POJO-以便程序员可以更加容易理解和应用java程序-x3D-x3D"><a href="#解决数据库和POJO对象的相呼映射-x3D-x3D-通过这层映射关系可以简单地把数据库表中的数据转化为POJO-以便程序员可以更加容易理解和应用java程序-x3D-x3D" class="headerlink" title="解决数据库和POJO对象的相呼映射,&#x3D;&#x3D;通过这层映射关系可以简单地把数据库表中的数据转化为POJO,以便程序员可以更加容易理解和应用java程序&#x3D;&#x3D;."></a>解决数据库和POJO对象的相呼映射,&#x3D;&#x3D;通过这层映射关系可以简单地把数据库表中的数据转化为POJO,以便程序员可以更加容易理解和应用java程序&#x3D;&#x3D;.</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930074059635.png" alt="image-20220930074059635"></p><h3 id="1-3-Hibernate"><a href="#1-3-Hibernate" class="headerlink" title="1.3  Hibernate"></a>1.3  Hibernate</h3><ol><li><h4 id="Hibernate是建立在若干pojo通过XMl映射文件-或者注解-提供的规则映射到数据表上的-即我们可以通过pojo来操作数据库的数据-它提供的是一种全表映射"><a href="#Hibernate是建立在若干pojo通过XMl映射文件-或者注解-提供的规则映射到数据表上的-即我们可以通过pojo来操作数据库的数据-它提供的是一种全表映射" class="headerlink" title="Hibernate是建立在若干pojo通过XMl映射文件(或者注解)提供的规则映射到数据表上的,即我们可以通过pojo来操作数据库的数据.它提供的是一种全表映射."></a>Hibernate是建立在若干pojo通过XMl映射文件(或者注解)提供的规则映射到数据表上的,即我们可以通过pojo来操作数据库的数据.它提供的是一种全表映射.</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930074251621.png" alt="image-20220930074251621"></p><ol><li><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息:"></a>配置信息:</h4><ol><li><h4 id="建立hibernate的工厂对象-sessionfactory-用它坐全局对象来产生session接口然后就可以操控数据库了"><a href="#建立hibernate的工厂对象-sessionfactory-用它坐全局对象来产生session接口然后就可以操控数据库了" class="headerlink" title="建立hibernate的工厂对象(sessionfactory),用它坐全局对象来产生session接口然后就可以操控数据库了."></a>建立hibernate的工厂对象(sessionfactory),用它坐全局对象来产生session接口然后就可以操控数据库了.</h4></li></ol></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930074507698.png" alt="image-20220930074507698"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930074513820.png" alt="image-20220930074513820"></p><ul><li><h4 id="在配置类中配置的好处"><a href="#在配置类中配置的好处" class="headerlink" title="在配置类中配置的好处:"></a>在配置类中配置的好处:</h4></li></ul><ol><li><h4 id="消除了代码的映射规则-它全部被分离到xml或者注解里面去配置"><a href="#消除了代码的映射规则-它全部被分离到xml或者注解里面去配置" class="headerlink" title="消除了代码的映射规则,它全部被分离到xml或者注解里面去配置"></a>消除了代码的映射规则,它全部被分离到xml或者注解里面去配置</h4></li><li><h4 id="无需再管理数据库连接-他也配置在xml里面"><a href="#无需再管理数据库连接-他也配置在xml里面" class="headerlink" title="无需再管理数据库连接,他也配置在xml里面"></a>无需再管理数据库连接,他也配置在xml里面</h4></li><li><h4 id="一个会话中不要操作多个对象-只要操作session对象即可"><a href="#一个会话中不要操作多个对象-只要操作session对象即可" class="headerlink" title="一个会话中不要操作多个对象,只要操作session对象即可"></a>一个会话中不要操作多个对象,只要操作session对象即可</h4></li><li><h4 id="关闭资源只需要关闭一个session即可"><a href="#关闭资源只需要关闭一个session即可" class="headerlink" title="关闭资源只需要关闭一个session即可."></a>关闭资源只需要关闭一个session即可.</h4></li></ol><ul><li><h4 id="hibernate的缺点"><a href="#hibernate的缺点" class="headerlink" title="hibernate的缺点:"></a>hibernate的缺点:</h4></li></ul><ol><li><h4 id="全表映射带来的不方便-比如更新时需要发送所有字段"><a href="#全表映射带来的不方便-比如更新时需要发送所有字段" class="headerlink" title="全表映射带来的不方便,比如更新时需要发送所有字段"></a>全表映射带来的不方便,比如更新时需要发送所有字段</h4></li><li><h4 id="无法根据不同的条件组装不同的sql"><a href="#无法根据不同的条件组装不同的sql" class="headerlink" title="无法根据不同的条件组装不同的sql"></a>无法根据不同的条件组装不同的sql</h4></li><li><h4 id="对多表关联和复杂sql查询支持比较差-需要自己写sql-返回后需要将数据组组装成pojo"><a href="#对多表关联和复杂sql查询支持比较差-需要自己写sql-返回后需要将数据组组装成pojo" class="headerlink" title="对多表关联和复杂sql查询支持比较差,需要自己写sql,返回后需要将数据组组装成pojo"></a>对多表关联和复杂sql查询支持比较差,需要自己写sql,返回后需要将数据组组装成pojo</h4></li><li><h4 id="不能有效支持存储过程"><a href="#不能有效支持存储过程" class="headerlink" title="不能有效支持存储过程"></a>不能有效支持存储过程</h4></li><li><h4 id="虽然有HQL-但性能较差-大型互联网系统中往往需要优化sql-而hibernate做不到"><a href="#虽然有HQL-但性能较差-大型互联网系统中往往需要优化sql-而hibernate做不到" class="headerlink" title="虽然有HQL,但性能较差,大型互联网系统中往往需要优化sql,而hibernate做不到."></a>虽然有HQL,但性能较差,大型互联网系统中往往需要优化sql,而hibernate做不到.</h4></li></ol><ul><li><h4 id="x3D-x3D-在当今大型互联网中-灵活-sql优化-减少数据的传递-x3D-x3D-是最基本的优化方法-显然Hibernate无法满足我们的要求-这是-x3D-x3D-Mybatis-就诞生了-它提供了更灵活-更方便的方法-弥补了hibernate的缺陷-x3D-x3D-x3D-x3D"><a href="#x3D-x3D-在当今大型互联网中-灵活-sql优化-减少数据的传递-x3D-x3D-是最基本的优化方法-显然Hibernate无法满足我们的要求-这是-x3D-x3D-Mybatis-就诞生了-它提供了更灵活-更方便的方法-弥补了hibernate的缺陷-x3D-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;在当今大型互联网中,灵活,sql优化,减少数据的传递&#x3D;&#x3D;是最基本的优化方法,显然Hibernate无法满足我们的要求,这是&#x3D;&#x3D;Mybatis 就诞生了.它提供了更灵活,更方便的方法,弥补了hibernate的缺陷&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;在当今大型互联网中,灵活,sql优化,减少数据的传递&#x3D;&#x3D;是最基本的优化方法,显然Hibernate无法满足我们的要求,这是&#x3D;&#x3D;Mybatis 就诞生了.它提供了更灵活,更方便的方法,弥补了hibernate的缺陷&#x3D;&#x3D;&#x3D;&#x3D;</h4></li></ul><h3 id="1-4-Mybatis"><a href="#1-4-Mybatis" class="headerlink" title="1.4 Mybatis"></a>1.4 Mybatis</h3><ol><li><h4 id="半自动映射的框架Mybatis-需要手工匹配提供POJO-sql和映射关系-而全表映射的hibernate只提供和pojo和映射关系即可"><a href="#半自动映射的框架Mybatis-需要手工匹配提供POJO-sql和映射关系-而全表映射的hibernate只提供和pojo和映射关系即可" class="headerlink" title="半自动映射的框架Mybatis :  需要手工匹配提供POJO,sql和映射关系,而全表映射的hibernate只提供和pojo和映射关系即可."></a>半自动映射的框架Mybatis :  需要手工匹配提供POJO,sql和映射关系,而全表映射的hibernate只提供和pojo和映射关系即可.</h4></li></ol><ul><li><h4 id="ibatis-是一个基于java的持久层框架-x3D-x3D-提供了包括SQL-Maps和-DAO-Data-Access-Object-x3D-x3D-很好地解决了hibernate遇到的问题-与hibernate不同的是-他不单单需要我们提供映射文件-还需要我们提供sql语句-包括"><a href="#ibatis-是一个基于java的持久层框架-x3D-x3D-提供了包括SQL-Maps和-DAO-Data-Access-Object-x3D-x3D-很好地解决了hibernate遇到的问题-与hibernate不同的是-他不单单需要我们提供映射文件-还需要我们提供sql语句-包括" class="headerlink" title="ibatis 是一个基于java的持久层框架,&#x3D;&#x3D;提供了包括SQL Maps和 DAO(Data Access Object),&#x3D;&#x3D;很好地解决了hibernate遇到的问题,与hibernate不同的是,他不单单需要我们提供映射文件,还需要我们提供sql语句,包括:"></a>ibatis 是一个基于java的持久层框架,&#x3D;&#x3D;提供了包括SQL Maps和 DAO(Data Access Object),&#x3D;&#x3D;很好地解决了hibernate遇到的问题,与hibernate不同的是,他不单单需要我们提供映射文件,还需要我们提供sql语句,包括:</h4></li></ul><ol><li><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4></li><li><h4 id="映射规则"><a href="#映射规则" class="headerlink" title="映射规则"></a>映射规则</h4></li><li><h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO."></a>POJO.</h4></li></ol><ul><li><h4 id="Mybatis-虽然配置多-但是可以动态配置SQL-Mybatis几乎能做到JDBC所有能做到的事情-Mybatis具有自动映射功能-换句话说-在注意一下规则地基础上-Mybatis可以自动完成映射"><a href="#Mybatis-虽然配置多-但是可以动态配置SQL-Mybatis几乎能做到JDBC所有能做到的事情-Mybatis具有自动映射功能-换句话说-在注意一下规则地基础上-Mybatis可以自动完成映射" class="headerlink" title="Mybatis 虽然配置多,但是可以动态配置SQL,Mybatis几乎能做到JDBC所有能做到的事情,Mybatis具有自动映射功能,换句话说,在注意一下规则地基础上,Mybatis可以自动完成映射."></a>Mybatis 虽然配置多,但是可以动态配置SQL,Mybatis几乎能做到JDBC所有能做到的事情,Mybatis具有自动映射功能,换句话说,在注意一下规则地基础上,Mybatis可以自动完成映射.</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930075856818.png" alt="image-20220930075856818"></p><ol><li><h4 id="实现JDBCExample"><a href="#实现JDBCExample" class="headerlink" title="实现JDBCExample"></a>实现JDBCExample</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080028766.png" alt="image-20220930080028766"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080046314.png" alt="image-20220930080046314"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080131402.png" alt="image-20220930080131402"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080141911.png" alt="image-20220930080141911"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080205685.png" alt="image-20220930080205685"></p><ol><li><h4 id="以上便完成了Mybatis代码的编写工作-sql和映射规则都在xml进行了分离-可以自由书写sql-定义映射规则-此外Mybatis提供接口编程的映射器只需要一个接口和映射文件便可以运行-消除了ibatis时代需要sql调度Sqlsession的情况"><a href="#以上便完成了Mybatis代码的编写工作-sql和映射规则都在xml进行了分离-可以自由书写sql-定义映射规则-此外Mybatis提供接口编程的映射器只需要一个接口和映射文件便可以运行-消除了ibatis时代需要sql调度Sqlsession的情况" class="headerlink" title="以上便完成了Mybatis代码的编写工作,sql和映射规则都在xml进行了分离,可以自由书写sql,定义映射规则,此外Mybatis提供接口编程的映射器只需要一个接口和映射文件便可以运行,消除了ibatis时代需要sql调度Sqlsession的情况."></a>以上便完成了Mybatis代码的编写工作,sql和映射规则都在xml进行了分离,可以自由书写sql,定义映射规则,此外Mybatis提供接口编程的映射器只需要一个接口和映射文件便可以运行,消除了ibatis时代需要sql调度Sqlsession的情况.</h4></li></ol><ul><li><h4 id="x3D-x3D-注意-当数据库的字段名称和POJO中属性名字一致时Mybatis会自动映射-x3D-x3D"><a href="#x3D-x3D-注意-当数据库的字段名称和POJO中属性名字一致时Mybatis会自动映射-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;注意:  当数据库的字段名称和POJO中属性名字一致时Mybatis会自动映射&#x3D;&#x3D;"></a>&#x3D;&#x3D;注意:  当数据库的字段名称和POJO中属性名字一致时Mybatis会自动映射&#x3D;&#x3D;</h4></li></ul><h4 id="1-5-什么时候用Mybatis"><a href="#1-5-什么时候用Mybatis" class="headerlink" title="1.5  什么时候用Mybatis"></a>1.5  什么时候用Mybatis</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930080625184.png" alt="image-20220930080625184"></p><h2 id="第二章-Mybatis入门"><a href="#第二章-Mybatis入门" class="headerlink" title="第二章 Mybatis入门"></a>第二章 Mybatis入门</h2><h3 id="2-1-开发环境的配置"><a href="#2-1-开发环境的配置" class="headerlink" title="2.1  开发环境的配置."></a>2.1  开发环境的配置.</h3><ul><li><h4 id="可以和springboot-集成-也可以简单创个maven应用然后导入依赖"><a href="#可以和springboot-集成-也可以简单创个maven应用然后导入依赖" class="headerlink" title="可以和springboot 集成,也可以简单创个maven应用然后导入依赖."></a>可以和springboot 集成,也可以简单创个maven应用然后导入依赖.</h4></li></ul><h3 id="2-2-Mybatis的基本构成"><a href="#2-2-Mybatis的基本构成" class="headerlink" title="2.2  Mybatis的基本构成"></a>2.2  Mybatis的基本构成</h3><ul><li><h4 id="Mybatis的核心组件"><a href="#Mybatis的核心组件" class="headerlink" title="Mybatis的核心组件"></a>Mybatis的核心组件</h4></li></ul><ol><li><h4 id="SqlSessionFactoryBuilder-构造器-他会根据配置信息或者代码来生成SqlSessionFactory-工厂接口"><a href="#SqlSessionFactoryBuilder-构造器-他会根据配置信息或者代码来生成SqlSessionFactory-工厂接口" class="headerlink" title="SqlSessionFactoryBuilder(构造器):他会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)"></a>SqlSessionFactoryBuilder(构造器):他会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)</h4></li><li><h4 id="SqlSessionFactory-依靠工厂来生成SqlSession-会话"><a href="#SqlSessionFactory-依靠工厂来生成SqlSession-会话" class="headerlink" title="SqlSessionFactory:依靠工厂来生成SqlSession(会话)"></a>SqlSessionFactory:依靠工厂来生成SqlSession(会话)</h4></li><li><h4 id="SqlSession-是一个既可以发送SQl去执行并返回结果-也可以获取Mapper的接口"><a href="#SqlSession-是一个既可以发送SQl去执行并返回结果-也可以获取Mapper的接口" class="headerlink" title="SqlSession:是一个既可以发送SQl去执行并返回结果,也可以获取Mapper的接口"></a>SqlSession:是一个既可以发送SQl去执行并返回结果,也可以获取Mapper的接口</h4></li><li><h4 id="SQL-Mpper-他是Mybatis新设计的组件-由一个JAVA接口和XMl文件-或者注解-构成的-需要给出对应的SQL和映射规则-它负责去发送SQL执行-并返回结果"><a href="#SQL-Mpper-他是Mybatis新设计的组件-由一个JAVA接口和XMl文件-或者注解-构成的-需要给出对应的SQL和映射规则-它负责去发送SQL执行-并返回结果" class="headerlink" title="SQL Mpper: 他是Mybatis新设计的组件,由一个JAVA接口和XMl文件(或者注解)构成的,需要给出对应的SQL和映射规则,它负责去发送SQL执行,并返回结果."></a>SQL Mpper: 他是Mybatis新设计的组件,由一个JAVA接口和XMl文件(或者注解)构成的,需要给出对应的SQL和映射规则,它负责去发送SQL执行,并返回结果.</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930082712020.png" alt="image-20220930082712020"></p><h4 id="2-2-1-构建SqlSessionFactory"><a href="#2-2-1-构建SqlSessionFactory" class="headerlink" title="2.2.1  构建SqlSessionFactory"></a>2.2.1  构建SqlSessionFactory</h4><ul><li><h4 id="SqlSessionFactory实例可以通过SqlSessionFactory获得-值得注意的是-x3D-x3D-SqlSessionFactory是一个接口而不是实现类-x3D-x3D-它的任务是创建SqlSession-而SqlSession类似于一个Connection对象-Mybatis提供了两种模式去创建SqlSessionFactory"><a href="#SqlSessionFactory实例可以通过SqlSessionFactory获得-值得注意的是-x3D-x3D-SqlSessionFactory是一个接口而不是实现类-x3D-x3D-它的任务是创建SqlSession-而SqlSession类似于一个Connection对象-Mybatis提供了两种模式去创建SqlSessionFactory" class="headerlink" title="SqlSessionFactory实例可以通过SqlSessionFactory获得,值得注意的是&#x3D;&#x3D;SqlSessionFactory是一个接口而不是实现类&#x3D;&#x3D;,它的任务是创建SqlSession.而SqlSession类似于一个Connection对象,Mybatis提供了两种模式去创建SqlSessionFactory:"></a>SqlSessionFactory实例可以通过SqlSessionFactory获得,值得注意的是&#x3D;&#x3D;SqlSessionFactory是一个接口而不是实现类&#x3D;&#x3D;,它的任务是创建SqlSession.而SqlSession类似于一个Connection对象,Mybatis提供了两种模式去创建SqlSessionFactory:</h4><ul><li><h4 id="x3D-x3D-一种是XML配置的方式-这是推荐的方式-x3D-x3D"><a href="#x3D-x3D-一种是XML配置的方式-这是推荐的方式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;一种是XML配置的方式,这是推荐的方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;一种是XML配置的方式,这是推荐的方式&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-另一种是代码的方式-x3D-x3D"><a href="#x3D-x3D-另一种是代码的方式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;另一种是代码的方式&#x3D;&#x3D;."></a>&#x3D;&#x3D;另一种是代码的方式&#x3D;&#x3D;.</h4></li></ul></li><li><h4 id="注意-能够使用配置文件的时候-尽量使用配置文件-避免硬编码问题-和方便日后配置人员修改-避免重复代码"><a href="#注意-能够使用配置文件的时候-尽量使用配置文件-避免硬编码问题-和方便日后配置人员修改-避免重复代码" class="headerlink" title="注意:能够使用配置文件的时候,尽量使用配置文件,避免硬编码问题,和方便日后配置人员修改,避免重复代码."></a>注意:能够使用配置文件的时候,尽量使用配置文件,避免硬编码问题,和方便日后配置人员修改,避免重复代码.</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930083452171.png" alt="image-20220930083452171"></p><h5 id="2-2-2-1-使用XML-方式构建"><a href="#2-2-2-1-使用XML-方式构建" class="headerlink" title="2.2.2.1   使用XML 方式构建"></a>2.2.2.1   使用XML 方式构建</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--加载外部properties文件，位置必须在第一个--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--给单独的实体类取别名--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.ovesh.domain.User&quot; alias=&quot;user&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--批量给实体类取别名：指定包下面所有的类的别名默认为其类名，不区分大小写--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--定义数据库信息，默认采用development数据库构建环境--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--采用JDBC管理事务--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--定义映射器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930084600951.png" alt="image-20220930084600951"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930084605980.png" alt="image-20220930084605980"></p><ul><li><h4 id="生成SqlSessionFactory"><a href="#生成SqlSessionFactory" class="headerlink" title="生成SqlSessionFactory"></a>生成SqlSessionFactory</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930084708853.png" alt="image-20220930084708853"></p><h5 id="2-2-1-2-使用代码方式构建"><a href="#2-2-1-2-使用代码方式构建" class="headerlink" title="2.2.1.2    使用代码方式构建"></a>2.2.1.2    使用代码方式构建</h5><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930085727795.png" alt="image-20220930085727795"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930085810139.png" alt="image-20220930085810139"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930085817491.png" alt="image-20220930085817491"></p><ul><li><h4 id="经历的流程"><a href="#经历的流程" class="headerlink" title="经历的流程"></a>经历的流程</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930085737988.png" alt="image-20220930085737988"></p><h4 id="2-2-2-创建-SqlSession"><a href="#2-2-2-创建-SqlSession" class="headerlink" title="2.2.2   创建 SqlSession"></a>2.2.2   创建 SqlSession</h4><ul><li><h4 id="SqlSession-是一个接口类-扮演者门面的作用-而真正干活的是Executor接口"><a href="#SqlSession-是一个接口类-扮演者门面的作用-而真正干活的是Executor接口" class="headerlink" title="SqlSession 是一个接口类,扮演者门面的作用,而真正干活的是Executor接口."></a>SqlSession 是一个接口类,扮演者门面的作用,而真正干活的是Executor接口.</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930090440320.png" alt="image-20220930090440320"></p><ol><li><h4 id="SqlSession-接口的实现类有两个-分别是DefaultSqlSession和SqlSessionManger"><a href="#SqlSession-接口的实现类有两个-分别是DefaultSqlSession和SqlSessionManger" class="headerlink" title="SqlSession 接口的实现类有两个,分别是DefaultSqlSession和SqlSessionManger."></a>SqlSession 接口的实现类有两个,分别是DefaultSqlSession和SqlSessionManger.</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930091242277.png" alt="image-20220930091242277"></p><p>这样即完成SqlSession 的 创建, 在finally中保证其关闭,让连接资源归还给数据库,以便后续使用.</p><ul><li><h4 id="SqlSession的用途"><a href="#SqlSession的用途" class="headerlink" title="SqlSession的用途:"></a>SqlSession的用途:</h4></li></ul><ol><li><h4 id="获取映射器-让映射器通过命名空间和方法找到对应的SQL-发送给数据库执行返回结果"><a href="#获取映射器-让映射器通过命名空间和方法找到对应的SQL-发送给数据库执行返回结果" class="headerlink" title="获取映射器,让映射器通过命名空间和方法找到对应的SQL,发送给数据库执行返回结果"></a>获取映射器,让映射器通过命名空间和方法找到对应的SQL,发送给数据库执行返回结果</h4></li><li><h4 id="直接通过命名信息去执行SQL结果-这是ibatis留下的-在SqlSession层可以通过update-insert-select-delete等方法-带上sql的id来操作在xml中配置好的sql-它也支持是事务-通过commit-rollback方法提交或者回滚事务"><a href="#直接通过命名信息去执行SQL结果-这是ibatis留下的-在SqlSession层可以通过update-insert-select-delete等方法-带上sql的id来操作在xml中配置好的sql-它也支持是事务-通过commit-rollback方法提交或者回滚事务" class="headerlink" title="直接通过命名信息去执行SQL结果,这是ibatis留下的,在SqlSession层可以通过update,insert,select,delete等方法,带上sql的id来操作在xml中配置好的sql,它也支持是事务,通过commit,rollback方法提交或者回滚事务."></a>直接通过命名信息去执行SQL结果,这是ibatis留下的,在SqlSession层可以通过update,insert,select,delete等方法,带上sql的id来操作在xml中配置好的sql,它也支持是事务,通过commit,rollback方法提交或者回滚事务.</h4></li></ol><h4 id="2-2-3-映射器"><a href="#2-2-3-映射器" class="headerlink" title="2.2.3    映射器"></a>2.2.3    映射器</h4><p>映射器是由JAVA接口和XML文件(或者注解)共同组成的,他的作用如下:</p><ol><li><h4 id="定义参数类型"><a href="#定义参数类型" class="headerlink" title="定义参数类型"></a>定义参数类型</h4></li><li><h4 id="描述缓存"><a href="#描述缓存" class="headerlink" title="描述缓存"></a>描述缓存</h4></li><li><h4 id="描述SQL语句"><a href="#描述SQL语句" class="headerlink" title="描述SQL语句"></a>描述SQL语句</h4></li><li><h4 id="定义查询结果和POJO的映射关系"><a href="#定义查询结果和POJO的映射关系" class="headerlink" title="定义查询结果和POJO的映射关系."></a>定义查询结果和POJO的映射关系.</h4></li><li><h4 id="一个映射器的实现方式有两种-一是通过XMl文件方式实现-另外一种是通过代码来实现-在Configuration里面注册Mapper接口-还需要我们写入Java注解"><a href="#一个映射器的实现方式有两种-一是通过XMl文件方式实现-另外一种是通过代码来实现-在Configuration里面注册Mapper接口-还需要我们写入Java注解" class="headerlink" title="一个映射器的实现方式有两种:一是通过XMl文件方式实现,另外一种是通过代码来实现.在Configuration里面注册Mapper接口(还需要我们写入Java注解)"></a>一个映射器的实现方式有两种:一是通过XMl文件方式实现,另外一种是通过代码来实现.在Configuration里面注册Mapper接口(还需要我们写入Java注解)</h4></li><li><h4 id="这是Mybatis的核心内容-很复杂-推荐使用xml方式来实现我们的需求-理由如下"><a href="#这是Mybatis的核心内容-很复杂-推荐使用xml方式来实现我们的需求-理由如下" class="headerlink" title="这是Mybatis的核心内容,很复杂,推荐使用xml方式来实现我们的需求,理由如下:"></a>这是Mybatis的核心内容,很复杂,推荐使用xml方式来实现我们的需求,理由如下:</h4><ol><li><h4 id="java注解受限-功能少-而Mybatis的Mapper内容相当多相当复杂-功能强大-使用XML文件方式可以带来灵活的空间-显示出Mybatis的强大和灵活"><a href="#java注解受限-功能少-而Mybatis的Mapper内容相当多相当复杂-功能强大-使用XML文件方式可以带来灵活的空间-显示出Mybatis的强大和灵活" class="headerlink" title="java注解受限,功能少,而Mybatis的Mapper内容相当多相当复杂,功能强大,使用XML文件方式可以带来灵活的空间,显示出Mybatis的强大和灵活"></a>java注解受限,功能少,而Mybatis的Mapper内容相当多相当复杂,功能强大,使用XML文件方式可以带来灵活的空间,显示出Mybatis的强大和灵活</h4></li><li><h4 id="如果SQL很复杂-条件很多-尤其是存在动态sql时-写在java文件里可读性很差-不利于维护"><a href="#如果SQL很复杂-条件很多-尤其是存在动态sql时-写在java文件里可读性很差-不利于维护" class="headerlink" title="如果SQL很复杂,条件很多,尤其是存在动态sql时,写在java文件里可读性很差,不利于维护."></a>如果SQL很复杂,条件很多,尤其是存在动态sql时,写在java文件里可读性很差,不利于维护.</h4></li></ol></li></ol><h5 id="2-2-3-1-XML-文件配置方式实现Mapper"><a href="#2-2-3-1-XML-文件配置方式实现Mapper" class="headerlink" title="2.2.3.1  XML 文件配置方式实现Mapper"></a>2.2.3.1  XML 文件配置方式实现Mapper</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.ovesh.dao.BookDao&quot;</span>&gt;</span><br><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span>   <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;book&quot;</span>&gt;</span><br>        select *from tb_user where id =#&#123;id&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930094513832.png" alt="image-20220930094513832"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930094530513.png" alt="image-20220930094530513"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930094550882.png" alt="image-20220930094550882"></p><ul><li><h4 id="用SqlSession-获取-Mapper"><a href="#用SqlSession-获取-Mapper" class="headerlink" title="用SqlSession 获取 Mapper"></a>用SqlSession 获取 Mapper</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BookDao</span> <span class="hljs-variable">bookdao</span> <span class="hljs-operator">=</span> Sqlsession.getMapper(BookDao.Class);<br><span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> BookDao.getBook(<span class="hljs-number">1L</span>);<br>sout(book.toString());<br></code></pre></td></tr></table></figure><p>这样就完成了一次Mybatis查询数据库.</p><h5 id="2-2-3-2-java-注解方式实现Mapper"><a href="#2-2-3-2-java-注解方式实现Mapper" class="headerlink" title="2.2.3.2     java 注解方式实现Mapper."></a>2.2.3.2     java 注解方式实现Mapper.</h5><ul><li><h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ovesh.dao;<br><br><span class="hljs-keyword">import</span> com.ovesh.domain.Book;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Ovesh</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/4/13 9:29</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookDao</span> &#123;<br>    <span class="hljs-meta">@Select(&quot; select *from tb_user where id =#&#123;id&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getById</span><span class="hljs-params">(Integer id)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930095155673.png" alt="image-20220930095155673"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930095230851.png" alt="image-20220930095230851"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930095353524.png" alt="image-20220930095353524"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930102908082.png" alt="image-20220930102908082"></p><h3 id="2-3-生命周期"><a href="#2-3-生命周期" class="headerlink" title="2.3   生命周期"></a>2.3   生命周期</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930103319496.png" alt="image-20220930103319496"></p><h4 id="2-3-1-SqlSessionFactoryBuilder"><a href="#2-3-1-SqlSessionFactoryBuilder" class="headerlink" title="2.3.1   SqlSessionFactoryBuilder"></a>2.3.1   SqlSessionFactoryBuilder</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930103348263.png" alt="image-20220930103348263"></p><h4 id="2-3-2-SqlSessionFactory"><a href="#2-3-2-SqlSessionFactory" class="headerlink" title="2.3.2  SqlSessionFactory"></a>2.3.2  SqlSessionFactory</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930103416412.png" alt="image-20220930103416412"></p><h4 id="2-3-3-SqlSession"><a href="#2-3-3-SqlSession" class="headerlink" title="2.3.3  SqlSession"></a>2.3.3  SqlSession</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930103428465.png" alt="image-20220930103428465"></p><h4 id="2-3-4-Mapper"><a href="#2-3-4-Mapper" class="headerlink" title="2.3.4  Mapper"></a>2.3.4  Mapper</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930104303834.png" alt="image-20220930104303834"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930104330241.png" alt="image-20220930104330241"></p><h2 id="第三章-配置"><a href="#第三章-配置" class="headerlink" title="第三章 配置"></a>第三章 配置</h2><ul><li><h4 id="Mybatis-配置XML文件的层次结构，并且这些层次是不能颠倒顺序的。"><a href="#Mybatis-配置XML文件的层次结构，并且这些层次是不能颠倒顺序的。" class="headerlink" title="Mybatis  配置XML文件的层次结构，并且这些层次是不能颠倒顺序的。"></a>Mybatis  配置XML文件的层次结构，并且这些层次是不能颠倒顺序的。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930113441335.png" alt="image-20220930113441335"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930114118164.png" alt="image-20220930114118164"></p><h3 id="3-1-properties-元素"><a href="#3-1-properties-元素" class="headerlink" title="3.1   properties   元素"></a>3.1   properties   元素</h3><p>properties 是一个配置属性的元素，让我们能在配置文件的上下文使用它。</p><ol><li><h4 id="property子元素"><a href="#property子元素" class="headerlink" title="property子元素"></a>property子元素</h4></li><li><h4 id="properties配置文件"><a href="#properties配置文件" class="headerlink" title="properties配置文件"></a>properties配置文件</h4></li><li><h4 id="程序参数传递。"><a href="#程序参数传递。" class="headerlink" title="程序参数传递。"></a>程序参数传递。</h4></li></ol><h4 id="3-1-1-property-子元素"><a href="#3-1-1-property-子元素" class="headerlink" title="3.1.1  property 子元素"></a>3.1.1  property 子元素</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930172015514.png" alt="image-20220930172015514"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xmk">&lt;properties&gt;<br>    &lt;property name=&quot;url&quot; value=&quot;www.baodu.com&quot;/&gt;<br>&lt;/properties&gt;<br></code></pre></td></tr></table></figure><ul><li><h4 id="外层是properties-内层是-property"><a href="#外层是properties-内层是-property" class="headerlink" title="外层是properties  内层是 property"></a>外层是properties  内层是 property</h4></li><li><h4 id="配置参数在配置文件中的使用。"><a href="#配置参数在配置文件中的使用。" class="headerlink" title="配置参数在配置文件中的使用。"></a>配置参数在配置文件中的使用。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930172650660.png" alt="image-20220930172650660"></p><h4 id="3-1-2-properties-配置文件"><a href="#3-1-2-properties-配置文件" class="headerlink" title="3.1.2  properties 配置文件"></a>3.1.2  properties 配置文件</h4><ul><li><h4 id="更多时候，使用properties通过配置文件来配置属性值，以方便我们在多个配置文件重复使用它们，也方便日后的维护和修改。"><a href="#更多时候，使用properties通过配置文件来配置属性值，以方便我们在多个配置文件重复使用它们，也方便日后的维护和修改。" class="headerlink" title="更多时候，使用properties通过配置文件来配置属性值，以方便我们在多个配置文件重复使用它们，也方便日后的维护和修改。"></a>更多时候，使用properties通过配置文件来配置属性值，以方便我们在多个配置文件重复使用它们，也方便日后的维护和修改。</h4></li><li><h4 id="编写properties-配置文件"><a href="#编写properties-配置文件" class="headerlink" title="编写properties 配置文件"></a>编写properties 配置文件</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930172954690.png" alt="image-20220930172954690"></p><ul><li><h4 id="把properties-配置文件放在resource-包下，并且在mybatis-配置文件中引用"><a href="#把properties-配置文件放在resource-包下，并且在mybatis-配置文件中引用" class="headerlink" title="把properties 配置文件放在resource 包下，并且在mybatis 配置文件中引用"></a>把properties 配置文件放在resource 包下，并且在mybatis 配置文件中引用</h4></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span> =<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-3-程序参数传递"><a href="#3-1-3-程序参数传递" class="headerlink" title="3.1.3    程序参数传递"></a>3.1.3    程序参数传递</h4><ul><li><h4 id="假设jdbc-properties-文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory-之前把它转换成明文。而系统也提供了解密方法decode-str-，看看以下代码是如何来完成sqlSessionFactory的创建。"><a href="#假设jdbc-properties-文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory-之前把它转换成明文。而系统也提供了解密方法decode-str-，看看以下代码是如何来完成sqlSessionFactory的创建。" class="headerlink" title="假设jdbc.properties 文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory 之前把它转换成明文。而系统也提供了解密方法decode(str)，看看以下代码是如何来完成sqlSessionFactory的创建。"></a>假设jdbc.properties 文件中的username和password两个属性使用了加密的字符串，这个时候我们需要在生成SqlSessionFactory 之前把它转换成明文。而系统也提供了解密方法decode(str)，看看以下代码是如何来完成sqlSessionFactory的创建。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930174415534.png" alt="image-20220930174415534"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930174428789.png" alt="image-20220930174428789"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930174439220.png" alt="image-20220930174439220"></p><ul><li><h5 id="根据以上，我们完全可以在jdbc-配置密文，满足对系统的需要。"><a href="#根据以上，我们完全可以在jdbc-配置密文，满足对系统的需要。" class="headerlink" title="根据以上，我们完全可以在jdbc 配置密文，满足对系统的需要。"></a>根据以上，我们完全可以在jdbc 配置密文，满足对系统的需要。</h5></li></ul><h4 id="3-1-4-优先级"><a href="#3-1-4-优先级" class="headerlink" title="3.1.4    优先级"></a>3.1.4    优先级</h4><ul><li><h4 id="Mybatis-支持3中配置方式可能同时出现，并且属性还会重复配置，这3中方式是存在优先级的，Mybatis-会按照以下顺序来加载："><a href="#Mybatis-支持3中配置方式可能同时出现，并且属性还会重复配置，这3中方式是存在优先级的，Mybatis-会按照以下顺序来加载：" class="headerlink" title="Mybatis 支持3中配置方式可能同时出现，并且属性还会重复配置，这3中方式是存在优先级的，Mybatis 会按照以下顺序来加载："></a>Mybatis 支持3中配置方式可能同时出现，并且属性还会重复配置，这3中方式是存在优先级的，Mybatis 会按照以下顺序来加载：</h4></li></ul><ol><li><h4 id="properties-元素体内指定的属性首先被读取"><a href="#properties-元素体内指定的属性首先被读取" class="headerlink" title="properties 元素体内指定的属性首先被读取"></a>properties 元素体内指定的属性首先被读取</h4></li><li><h4 id="根据properties元素中的resouce属性读取路径下的属性文件，或者根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性"><a href="#根据properties元素中的resouce属性读取路径下的属性文件，或者根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性" class="headerlink" title="根据properties元素中的resouce属性读取路径下的属性文件，或者根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性"></a>根据properties元素中的resouce属性读取路径下的属性文件，或者根据url属性指定的路径读取属性文件，并覆盖已读取的同名属性</h4></li><li><h4 id="读取作为方法参数传递的属性，并覆盖已读取的同名属性。"><a href="#读取作为方法参数传递的属性，并覆盖已读取的同名属性。" class="headerlink" title="读取作为方法参数传递的属性，并覆盖已读取的同名属性。"></a>读取作为方法参数传递的属性，并覆盖已读取的同名属性。</h4></li></ol><ul><li><h4 id="x3D-x3D-因此，通过方法参数传递的属性具有最高的优先级-x3D-x3D-，-x3D-x3D-resource-x2F-url-属性中指定的配置文件次之-x3D-x3D-x3D-x3D-，最低优先级的是properties-属性中指定的属性-x3D-x3D-，因此实际操作中我们需要注意以下3点。"><a href="#x3D-x3D-因此，通过方法参数传递的属性具有最高的优先级-x3D-x3D-，-x3D-x3D-resource-x2F-url-属性中指定的配置文件次之-x3D-x3D-x3D-x3D-，最低优先级的是properties-属性中指定的属性-x3D-x3D-，因此实际操作中我们需要注意以下3点。" class="headerlink" title="&#x3D;&#x3D;因此，通过方法参数传递的属性具有最高的优先级&#x3D;&#x3D;，&#x3D;&#x3D;resource&#x2F;url 属性中指定的配置文件次之&#x3D;&#x3D;&#x3D;&#x3D;，最低优先级的是properties 属性中指定的属性&#x3D;&#x3D;，因此实际操作中我们需要注意以下3点。"></a>&#x3D;&#x3D;因此，通过方法参数传递的属性具有最高的优先级&#x3D;&#x3D;，&#x3D;&#x3D;resource&#x2F;url 属性中指定的配置文件次之&#x3D;&#x3D;&#x3D;&#x3D;，最低优先级的是properties 属性中指定的属性&#x3D;&#x3D;，因此实际操作中我们需要注意以下3点。</h4></li></ul><ol><li><h4 id="x3D-x3D-注意-x3D-x3D-："><a href="#x3D-x3D-注意-x3D-x3D-：" class="headerlink" title="&#x3D;&#x3D;注意&#x3D;&#x3D;："></a>&#x3D;&#x3D;注意&#x3D;&#x3D;：</h4><ol><li><h4 id="不要使用混合的方式，会使得管理混乱"><a href="#不要使用混合的方式，会使得管理混乱" class="headerlink" title="不要使用混合的方式，会使得管理混乱"></a>不要使用混合的方式，会使得管理混乱</h4></li><li><h4 id="首先的方式是使用properties-文件"><a href="#首先的方式是使用properties-文件" class="headerlink" title="首先的方式是使用properties 文件"></a>首先的方式是使用properties 文件</h4></li><li><h4 id="如果我们需要对其使用加密或者其他加工以满足特殊的要求，不妨按前面给到的处理方法，这样的好处是使得配置都来自同一个配置文件，就不容易产生没有必要的歧义，也为了日后统一管理提供了方便。"><a href="#如果我们需要对其使用加密或者其他加工以满足特殊的要求，不妨按前面给到的处理方法，这样的好处是使得配置都来自同一个配置文件，就不容易产生没有必要的歧义，也为了日后统一管理提供了方便。" class="headerlink" title="如果我们需要对其使用加密或者其他加工以满足特殊的要求，不妨按前面给到的处理方法，这样的好处是使得配置都来自同一个配置文件，就不容易产生没有必要的歧义，也为了日后统一管理提供了方便。"></a>如果我们需要对其使用加密或者其他加工以满足特殊的要求，不妨按前面给到的处理方法，这样的好处是使得配置都来自同一个配置文件，就不容易产生没有必要的歧义，也为了日后统一管理提供了方便。</h4></li></ol></li></ol><h3 id="3-2-设置"><a href="#3-2-设置" class="headerlink" title="3.2   设置"></a>3.2   设置</h3><ul><li><h4 id="设置-settings-在mybatis-中是最复杂的配置，同时也是最为重要的配置之一。他会改变Mybatis运行时的行为，即使不配置settings，Mybatis也是可以正常的工作。不过了解setting的配置内容，以及它们的作用仍然十分必要。"><a href="#设置-settings-在mybatis-中是最复杂的配置，同时也是最为重要的配置之一。他会改变Mybatis运行时的行为，即使不配置settings，Mybatis也是可以正常的工作。不过了解setting的配置内容，以及它们的作用仍然十分必要。" class="headerlink" title="设置(settings)  在mybatis 中是最复杂的配置，同时也是最为重要的配置之一。他会改变Mybatis运行时的行为，即使不配置settings，Mybatis也是可以正常的工作。不过了解setting的配置内容，以及它们的作用仍然十分必要。"></a>设置(settings)  在mybatis 中是最复杂的配置，同时也是最为重要的配置之一。他会改变Mybatis运行时的行为，即使不配置settings，Mybatis也是可以正常的工作。不过了解setting的配置内容，以及它们的作用仍然十分必要。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930213516888.png" alt="image-20220930213516888"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930213735247.png" alt="image-20220930213735247"></p><ul><li><h4 id="以上等等，详情查文档及google。"><a href="#以上等等，详情查文档及google。" class="headerlink" title="以上等等，详情查文档及google。"></a>以上等等，详情查文档及google。</h4></li></ul><h3 id="3-3-别名"><a href="#3-3-别名" class="headerlink" title="3.3    别名"></a>3.3    别名</h3><ul><li><h4 id="别名-typeAliases-是一个指代的名称，用简短的名称去替代遇到的较长的类全限定名。并且这个别名可以在Mybatis上下文中使用，别名在Mybatis里面分为系统定义别名和自定义别名。Mybatis中别名是-x3D-x3D-不区分大小写的-x3D-x3D-。一个typeAliases-的实例实在解析配置文件时生成的，然后-x3D-x3D-长期保存在Configuration对象中-x3D-x3D-，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。"><a href="#别名-typeAliases-是一个指代的名称，用简短的名称去替代遇到的较长的类全限定名。并且这个别名可以在Mybatis上下文中使用，别名在Mybatis里面分为系统定义别名和自定义别名。Mybatis中别名是-x3D-x3D-不区分大小写的-x3D-x3D-。一个typeAliases-的实例实在解析配置文件时生成的，然后-x3D-x3D-长期保存在Configuration对象中-x3D-x3D-，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。" class="headerlink" title="别名(typeAliases)  是一个指代的名称，用简短的名称去替代遇到的较长的类全限定名。并且这个别名可以在Mybatis上下文中使用，别名在Mybatis里面分为系统定义别名和自定义别名。Mybatis中别名是&#x3D;&#x3D;不区分大小写的&#x3D;&#x3D;。一个typeAliases 的实例实在解析配置文件时生成的，然后&#x3D;&#x3D;长期保存在Configuration对象中&#x3D;&#x3D;，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。"></a>别名(typeAliases)  是一个指代的名称，用简短的名称去替代遇到的较长的类全限定名。并且这个别名可以在Mybatis上下文中使用，别名在Mybatis里面分为系统定义别名和自定义别名。Mybatis中别名是&#x3D;&#x3D;不区分大小写的&#x3D;&#x3D;。一个typeAliases 的实例实在解析配置文件时生成的，然后&#x3D;&#x3D;长期保存在Configuration对象中&#x3D;&#x3D;，当我们使用它时，再把它拿出来，这样就没有必要运行的时候再次生成它的实例了。</h4></li></ul><h4 id="3-3-1-系统定义别名"><a href="#3-3-1-系统定义别名" class="headerlink" title="3.3.1   系统定义别名"></a>3.3.1   系统定义别名</h4><ul><li><h4 id="Mybatis系统定义了一些经常使用的类型的别名，-x3D-x3D-例如，数值，字符串，日期和集合等。-x3D-x3D"><a href="#Mybatis系统定义了一些经常使用的类型的别名，-x3D-x3D-例如，数值，字符串，日期和集合等。-x3D-x3D" class="headerlink" title="Mybatis系统定义了一些经常使用的类型的别名，&#x3D;&#x3D;例如，数值，字符串，日期和集合等。&#x3D;&#x3D;"></a>Mybatis系统定义了一些经常使用的类型的别名，&#x3D;&#x3D;例如，数值，字符串，日期和集合等。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930214625109.png" alt="image-20220930214625109"></p><ul><li><h4 id="x3D-x3D-在对应类型前-加个下划线-x3D-x3D-。-系统定义的别名，我们无需重复注册他们。"><a href="#x3D-x3D-在对应类型前-加个下划线-x3D-x3D-。-系统定义的别名，我们无需重复注册他们。" class="headerlink" title="&#x3D;&#x3D;在对应类型前 加个下划线&#x3D;&#x3D;。 系统定义的别名，我们无需重复注册他们。"></a>&#x3D;&#x3D;在对应类型前 加个下划线&#x3D;&#x3D;。 系统定义的别名，我们无需重复注册他们。</h4></li></ul><h4 id="3-3-2-自定义别名"><a href="#3-3-2-自定义别名" class="headerlink" title="3.3.2  自定义别名"></a>3.3.2  自定义别名</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--给单独的实体类取别名--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;typeAlias type=&quot;com.ovesh.domain.User&quot; alias=&quot;user&quot;/&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--批量给实体类取别名：指定包下面所有的类的别名默认为其类名，不区分大小写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.ovesh.domain&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><h4 id="如果POJO过多时，配置也是非常多的，这时可以通过Mybatis-的自动扫描来自定义别名。"><a href="#如果POJO过多时，配置也是非常多的，这时可以通过Mybatis-的自动扫描来自定义别名。" class="headerlink" title="如果POJO过多时，配置也是非常多的，这时可以通过Mybatis 的自动扫描来自定义别名。"></a>如果POJO过多时，配置也是非常多的，这时可以通过Mybatis 的自动扫描来自定义别名。</h4></li><li><h4 id="x3D-x3D-现在配置文件中配置（1）-x3D-x3D"><a href="#x3D-x3D-现在配置文件中配置（1）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;现在配置文件中配置（1）&#x3D;&#x3D;"></a>&#x3D;&#x3D;现在配置文件中配置（1）&#x3D;&#x3D;</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;typeAliases<br>&lt;package name =&quot; com.ovesh.pojo1&quot; /&gt;<br>&lt;package name =&quot;com.ovesh.pojo2&quot; /&gt;<br>/typeAlieses&gt;<br></code></pre></td></tr></table></figure><ul><li><h4 id="x3D-x3D-然后在代码中通过注解来定义别名（2）-x3D-x3D"><a href="#x3D-x3D-然后在代码中通过注解来定义别名（2）-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;然后在代码中通过注解来定义别名（2）&#x3D;&#x3D;"></a>&#x3D;&#x3D;然后在代码中通过注解来定义别名（2）&#x3D;&#x3D;</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;role&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span>&#123;<br><span class="hljs-comment">// some code</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h4 id="当有以上的（1）（2）配置，Mybatis就会自动扫描包，将扫描到的类依赖装载到上下文，以便将来使用。这样就算多个POJO也可以通过包扫描的方式来装载到Mybatis的上下文中了。"><a href="#当有以上的（1）（2）配置，Mybatis就会自动扫描包，将扫描到的类依赖装载到上下文，以便将来使用。这样就算多个POJO也可以通过包扫描的方式来装载到Mybatis的上下文中了。" class="headerlink" title="当有以上的（1）（2）配置，Mybatis就会自动扫描包，将扫描到的类依赖装载到上下文，以便将来使用。这样就算多个POJO也可以通过包扫描的方式来装载到Mybatis的上下文中了。"></a>当有以上的（1）（2）配置，Mybatis就会自动扫描包，将扫描到的类依赖装载到上下文，以便将来使用。这样就算多个POJO也可以通过包扫描的方式来装载到Mybatis的上下文中了。</h4></li></ol><ul><li><h4 id="x3D-x3D-注意-x3D-x3D-：如果配置了包的扫描路径，但是没有注解-Alias，Mybatis也会装载，-x3D-x3D-只是说他将把你的类名的第一个字母变为小写，作为Mybatis的别名-x3D-x3D-。要特别注意避免出现重复名的场景，-x3D-x3D-建议使用-部分包名加类名的限定-x3D-x3D-。"><a href="#x3D-x3D-注意-x3D-x3D-：如果配置了包的扫描路径，但是没有注解-Alias，Mybatis也会装载，-x3D-x3D-只是说他将把你的类名的第一个字母变为小写，作为Mybatis的别名-x3D-x3D-。要特别注意避免出现重复名的场景，-x3D-x3D-建议使用-部分包名加类名的限定-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;注意&#x3D;&#x3D;：如果配置了包的扫描路径，但是没有注解@Alias，Mybatis也会装载，&#x3D;&#x3D;只是说他将把你的类名的第一个字母变为小写，作为Mybatis的别名&#x3D;&#x3D;。要特别注意避免出现重复名的场景，&#x3D;&#x3D;建议使用 部分包名加类名的限定&#x3D;&#x3D;。"></a>&#x3D;&#x3D;注意&#x3D;&#x3D;：如果配置了包的扫描路径，但是没有注解@Alias，Mybatis也会装载，&#x3D;&#x3D;只是说他将把你的类名的第一个字母变为小写，作为Mybatis的别名&#x3D;&#x3D;。要特别注意避免出现重复名的场景，&#x3D;&#x3D;建议使用 部分包名加类名的限定&#x3D;&#x3D;。</h4></li></ul><h3 id="3-4-typeHandler-类处理器"><a href="#3-4-typeHandler-类处理器" class="headerlink" title="3.4    typeHandler 类处理器"></a>3.4    typeHandler 类处理器</h3><ul><li><h4 id="Mybatis-在预处理语句（PrepareStament）中设置了一个参数，或者从（ResultSet）中取出一个值时，都会用注册了的typeHandler进行处理。"><a href="#Mybatis-在预处理语句（PrepareStament）中设置了一个参数，或者从（ResultSet）中取出一个值时，都会用注册了的typeHandler进行处理。" class="headerlink" title="Mybatis 在预处理语句（PrepareStament）中设置了一个参数，或者从（ResultSet）中取出一个值时，都会用注册了的typeHandler进行处理。"></a>Mybatis 在预处理语句（PrepareStament）中设置了一个参数，或者从（ResultSet）中取出一个值时，都会用注册了的typeHandler进行处理。</h4></li></ul><p>TypeHandler被称作类型处理器，<a href="https://so.csdn.net/so/search?q=MyBatis&spm=1001.2101.3001.7020">MyBatis</a>在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时，都会用类型处理器将Java对象转化为数据库支持的类型或者将获取到数据库值以合适的方式转换成 Java类型。</p><p><a href="https://blog.csdn.net/weixin_38308374/article/details/113827825">https://blog.csdn.net/weixin_38308374/article/details/113827825</a></p><ul><li><h4 id="和起别名类似，也有系统和自定义两种。"><a href="#和起别名类似，也有系统和自定义两种。" class="headerlink" title="和起别名类似，也有系统和自定义两种。"></a>和起别名类似，也有系统和自定义两种。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930220314422.png" alt="image-20220930220314422"></p><h4 id="3-4-1-系统定义的typeHandler"><a href="#3-4-1-系统定义的typeHandler" class="headerlink" title="3.4.1   系统定义的typeHandler"></a>3.4.1   系统定义的typeHandler</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223004092.png" alt="image-20220930223004092"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223505882.png" alt="image-20220930223505882"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223804951.png" alt="image-20220930223804951"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223829014.png" alt="image-20220930223829014"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223835860.png" alt="image-20220930223835860"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930223816451.png" alt="image-20220930223816451"></p><h4 id="3-4-2-自定义typeHandler"><a href="#3-4-2-自定义typeHandler" class="headerlink" title="3.4.2   自定义typeHandler"></a>3.4.2   自定义typeHandler</h4><ul><li><h4 id="一般情况下，系统定义的typeHandler-已经能够应付大部分的场景了，但是我们不排除不够用的场景。比如当需要处理特殊的javaType，和对应处理数据库的那些类型（jdbcType），比如字典项的枚举。"><a href="#一般情况下，系统定义的typeHandler-已经能够应付大部分的场景了，但是我们不排除不够用的场景。比如当需要处理特殊的javaType，和对应处理数据库的那些类型（jdbcType），比如字典项的枚举。" class="headerlink" title="一般情况下，系统定义的typeHandler 已经能够应付大部分的场景了，但是我们不排除不够用的场景。比如当需要处理特殊的javaType，和对应处理数据库的那些类型（jdbcType），比如字典项的枚举。"></a>一般情况下，系统定义的typeHandler 已经能够应付大部分的场景了，但是我们不排除不够用的场景。比如当需要处理特殊的javaType，和对应处理数据库的那些类型（jdbcType），比如字典项的枚举。</h4></li><li><h4 id="自定义typeHandler-的实现流程。"><a href="#自定义typeHandler-的实现流程。" class="headerlink" title="自定义typeHandler 的实现流程。"></a>自定义typeHandler 的实现流程。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224516207.png" alt="image-20220930224516207"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224524564.png" alt="image-20220930224524564"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224538599.png" alt="image-20220930224538599"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224554937.png" alt="image-20220930224554937"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224602767.png" alt="image-20220930224602767"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224654002.png" alt="image-20220930224654002"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224701336.png" alt="image-20220930224701336"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224714134.png" alt="image-20220930224714134"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224719988.png" alt="image-20220930224719988"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224920768.png" alt="image-20220930224920768"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930224931516.png" alt="image-20220930224931516"></p><h4 id="3-4-3-枚举类型-typeHandler"><a href="#3-4-3-枚举类型-typeHandler" class="headerlink" title="3.4.3   枚举类型 typeHandler"></a>3.4.3   枚举类型 typeHandler</h4><ul><li><h4 id="上一小节给出了自定义java-类型的typeHandlers，但是在Mybatis中枚举类型的typeHandler-则有自己的特殊规则，Mybatis-内部提供了-两个转化枚举类型的typerHandler"><a href="#上一小节给出了自定义java-类型的typeHandlers，但是在Mybatis中枚举类型的typeHandler-则有自己的特殊规则，Mybatis-内部提供了-两个转化枚举类型的typerHandler" class="headerlink" title="上一小节给出了自定义java 类型的typeHandlers，但是在Mybatis中枚举类型的typeHandler 则有自己的特殊规则，Mybatis 内部提供了 两个转化枚举类型的typerHandler :"></a>上一小节给出了自定义java 类型的typeHandlers，但是在Mybatis中枚举类型的typeHandler 则有自己的特殊规则，Mybatis 内部提供了 两个转化枚举类型的typerHandler :</h4><ul><li><h4 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930225753896.png" alt="image-20220930225753896"></h4></li></ul></li></ul><ol><li><h4 id="其中-EnumTypeHandler-是使用枚举字符串名称作为参数传递的，EnumOdrinalTypeHandler是使用整数下标作为参数传递的。"><a href="#其中-EnumTypeHandler-是使用枚举字符串名称作为参数传递的，EnumOdrinalTypeHandler是使用整数下标作为参数传递的。" class="headerlink" title="其中,EnumTypeHandler 是使用枚举字符串名称作为参数传递的，EnumOdrinalTypeHandler是使用整数下标作为参数传递的。"></a>其中,EnumTypeHandler 是使用枚举字符串名称作为参数传递的，EnumOdrinalTypeHandler是使用整数下标作为参数传递的。</h4></li><li><h4 id="如果枚举和数据库字典保持一致，我们使用他们就行了，然而并不是所有类型都那么巧合，因此有时我们更希望用自定义的typeHandler处理他们，所以我们也需要去了解，自定义typeHandler-实现枚举映射。"><a href="#如果枚举和数据库字典保持一致，我们使用他们就行了，然而并不是所有类型都那么巧合，因此有时我们更希望用自定义的typeHandler处理他们，所以我们也需要去了解，自定义typeHandler-实现枚举映射。" class="headerlink" title="如果枚举和数据库字典保持一致，我们使用他们就行了，然而并不是所有类型都那么巧合，因此有时我们更希望用自定义的typeHandler处理他们，所以我们也需要去了解，自定义typeHandler 实现枚举映射。"></a>如果枚举和数据库字典保持一致，我们使用他们就行了，然而并不是所有类型都那么巧合，因此有时我们更希望用自定义的typeHandler处理他们，所以我们也需要去了解，自定义typeHandler 实现枚举映射。</h4></li><li><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4></li><li><h4 id="常规的类实现"><a href="#常规的类实现" class="headerlink" title="常规的类实现"></a>常规的类实现</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930230513913.png" alt="image-20220930230513913"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930230526135.png" alt="image-20220930230526135"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930230531653.png" alt="image-20220930230531653"></p><h5 id="3-4-3-1-EnumOrdinalTypeHandler"><a href="#3-4-3-1-EnumOrdinalTypeHandler" class="headerlink" title="3.4.3.1  EnumOrdinalTypeHandler"></a>3.4.3.1  EnumOrdinalTypeHandler</h5><ul><li><h4 id="在没有配置的时候，这个是Mybatis-默认的枚举类型的处理器，为了能让EnumOrdinalTypeHandler-能够处理它，需要在Mybatis配置文件中配置："><a href="#在没有配置的时候，这个是Mybatis-默认的枚举类型的处理器，为了能让EnumOrdinalTypeHandler-能够处理它，需要在Mybatis配置文件中配置：" class="headerlink" title="在没有配置的时候，这个是Mybatis 默认的枚举类型的处理器，为了能让EnumOrdinalTypeHandler 能够处理它，需要在Mybatis配置文件中配置："></a>在没有配置的时候，这个是Mybatis 默认的枚举类型的处理器，为了能让EnumOrdinalTypeHandler 能够处理它，需要在Mybatis配置文件中配置：</h4></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span></span><br><span class="hljs-tag">&lt;<span class="hljs-attr">typeHandler</span></span><br><span class="hljs-tag"><span class="hljs-attr">handler</span> = <span class="hljs-string">&quot;org.apche.ibatis.type.EnumOrdnalTypeHandler&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br>/typeHandlers&gt;<br></code></pre></td></tr></table></figure><ul><li><h4 id="这样当Mybatis-遇到这个枚举类型（Enum-Sex-前面定义的-就可以识别这个枚举了，然后我们给出userMapper-xml"><a href="#这样当Mybatis-遇到这个枚举类型（Enum-Sex-前面定义的-就可以识别这个枚举了，然后我们给出userMapper-xml" class="headerlink" title="这样当Mybatis 遇到这个枚举类型（Enum Sex 前面定义的)就可以识别这个枚举了，然后我们给出userMapper.xml"></a>这样当Mybatis 遇到这个枚举类型（Enum Sex 前面定义的)就可以识别这个枚举了，然后我们给出userMapper.xml</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930231048614.png" alt="image-20220930231048614"></p></li><li><h4 id="再来个测试类，测试接口"><a href="#再来个测试类，测试接口" class="headerlink" title="再来个测试类，测试接口"></a>再来个测试类，测试接口</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930231125401.png" alt="image-20220930231125401"></p><ul><li><h4 id="并且我们要确保-引入这个映射器到Mybatis上下文中。"><a href="#并且我们要确保-引入这个映射器到Mybatis上下文中。" class="headerlink" title="并且我们要确保 引入这个映射器到Mybatis上下文中。"></a>并且我们要确保 引入这个映射器到Mybatis上下文中。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930231437530.png" alt="image-20220930231437530"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930231507076.png" alt="image-20220930231507076"></p><h5 id="3-4-3-2-EnumTypeHandler"><a href="#3-4-3-2-EnumTypeHandler" class="headerlink" title="3.4.3.2  EnumTypeHandler"></a>3.4.3.2  EnumTypeHandler</h5><ul><li><h4 id="EnumTypeHandler-是使用枚举名称去处理java-枚举类型，EnumTypeHandler-对应的是一个字符串，让我们来看看它的用法。"><a href="#EnumTypeHandler-是使用枚举名称去处理java-枚举类型，EnumTypeHandler-对应的是一个字符串，让我们来看看它的用法。" class="headerlink" title="EnumTypeHandler   是使用枚举名称去处理java 枚举类型，EnumTypeHandler 对应的是一个字符串，让我们来看看它的用法。"></a>EnumTypeHandler   是使用枚举名称去处理java 枚举类型，EnumTypeHandler 对应的是一个字符串，让我们来看看它的用法。</h4></li><li><h4 id="首先定义一个字符串，varchar-型的字典项，例如将（Sex-修改为varchar。-然后修改映射XML文件，这时我们在映射文件里面做了全部的限定描述-javaType-jdbcType-typeHandle-这样我们就不用在Mybatis配置文件中再进行配置了"><a href="#首先定义一个字符串，varchar-型的字典项，例如将（Sex-修改为varchar。-然后修改映射XML文件，这时我们在映射文件里面做了全部的限定描述-javaType-jdbcType-typeHandle-这样我们就不用在Mybatis配置文件中再进行配置了" class="headerlink" title="首先定义一个字符串，varchar 型的字典项，例如将（Sex)修改为varchar。   然后修改映射XML文件，这时我们在映射文件里面做了全部的限定描述(javaType,jdbcType,typeHandle),这样我们就不用在Mybatis配置文件中再进行配置了."></a>首先定义一个字符串，varchar 型的字典项，例如将（Sex)修改为varchar。   然后修改映射XML文件，这时我们在映射文件里面做了全部的限定描述(javaType,jdbcType,typeHandle),这样我们就不用在Mybatis配置文件中再进行配置了.</h4></li><li><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意 "></a>特别注意 <typeHandler/></h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232041177.png" alt="image-20220930232041177"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232133820.png" alt="image-20220930232133820"></p><ul><li><h4 id="修改后的效果。"><a href="#修改后的效果。" class="headerlink" title="修改后的效果。"></a>修改后的效果。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232305296.png" alt="image-20220930232305296"></p><h5 id="3-4-3-3-自定义枚举类的typeHandler"><a href="#3-4-3-3-自定义枚举类的typeHandler" class="headerlink" title="3.4.3.3  自定义枚举类的typeHandler"></a>3.4.3.3  自定义枚举类的typeHandler</h5><ul><li><h4 id="使用自定义typeHandler-的配置流程"><a href="#使用自定义typeHandler-的配置流程" class="headerlink" title="使用自定义typeHandler 的配置流程"></a>使用自定义typeHandler 的配置流程</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232405355.png" alt="image-20220930232405355"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232434376.png" alt="image-20220930232434376"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232446237.png" alt="image-20220930232446237"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220930232452677.png" alt="image-20220930232452677"></p><h3 id="3-5-Objecy-Factory"><a href="#3-5-Objecy-Factory" class="headerlink" title="3.5   Objecy Factory"></a>3.5   Objecy Factory</h3><ul><li><h4 id="Mybatis在构建一个结果返回时，都会使用ObjectFactory-对象工厂-去构建POJO，在Mybatis中可以定制自己的对象工厂，一般使用的是默认的ObjectFactory即可，但也可以定制特定的工厂，按照一以下的配置流程。"><a href="#Mybatis在构建一个结果返回时，都会使用ObjectFactory-对象工厂-去构建POJO，在Mybatis中可以定制自己的对象工厂，一般使用的是默认的ObjectFactory即可，但也可以定制特定的工厂，按照一以下的配置流程。" class="headerlink" title="Mybatis在构建一个结果返回时，都会使用ObjectFactory(对象工厂)去构建POJO，在Mybatis中可以定制自己的对象工厂，一般使用的是默认的ObjectFactory即可，但也可以定制特定的工厂，按照一以下的配置流程。"></a>Mybatis在构建一个结果返回时，都会使用ObjectFactory(对象工厂)去构建POJO，在Mybatis中可以定制自己的对象工厂，一般使用的是默认的ObjectFactory即可，但也可以定制特定的工厂，按照一以下的配置流程。</h4></li></ul><ol><li><h4 id="定义新的ObjectFactory"><a href="#定义新的ObjectFactory" class="headerlink" title="定义新的ObjectFactory"></a>定义新的ObjectFactory</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001131544223.png" alt="image-20221001131544223"></p><ol><li><h4 id="配置一个对象工厂MyObjectFactory，对他的要求是实现ObjectFactory的接口。实际上-x3D-x3D-DefaultObjectFactory-已经实现了ObjectFactory的接口-x3D-x3D-，我们可以通过继承它来简化编码。"><a href="#配置一个对象工厂MyObjectFactory，对他的要求是实现ObjectFactory的接口。实际上-x3D-x3D-DefaultObjectFactory-已经实现了ObjectFactory的接口-x3D-x3D-，我们可以通过继承它来简化编码。" class="headerlink" title="配置一个对象工厂MyObjectFactory，对他的要求是实现ObjectFactory的接口。实际上&#x3D;&#x3D;DefaultObjectFactory  已经实现了ObjectFactory的接口&#x3D;&#x3D;，我们可以通过继承它来简化编码。"></a>配置一个对象工厂MyObjectFactory，对他的要求是实现ObjectFactory的接口。实际上&#x3D;&#x3D;DefaultObjectFactory  已经实现了ObjectFactory的接口&#x3D;&#x3D;，我们可以通过继承它来简化编码。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001131805934.png" alt="image-20221001131805934"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001131813738.png" alt="image-20221001131813738"></p><ul><li><h4 id="测试结果分析："><a href="#测试结果分析：" class="headerlink" title="测试结果分析："></a>测试结果分析：</h4><ul><li><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001131839772.png" alt="image-20221001131839772"></li></ul></li></ul><h3 id="3-6-插件"><a href="#3-6-插件" class="headerlink" title="3.6      插件"></a>3.6      插件</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001132417544.png" alt="image-20221001132417544"></p><h3 id="3-7-environments-配置环境"><a href="#3-7-environments-配置环境" class="headerlink" title="3.7    environments  配置环境"></a>3.7    environments  配置环境</h3><h4 id="3-7-1-概述"><a href="#3-7-1-概述" class="headerlink" title="3.7.1  概述"></a>3.7.1  概述</h4><ul><li><h4 id="配置环境可以注册多个数据源-dataSource-每一个数据源分为两大部分：一个是数据源的配置，另一个是数据库事务的配置。如下面的连接池的数据源配置："><a href="#配置环境可以注册多个数据源-dataSource-每一个数据源分为两大部分：一个是数据源的配置，另一个是数据库事务的配置。如下面的连接池的数据源配置：" class="headerlink" title="配置环境可以注册多个数据源(dataSource),每一个数据源分为两大部分：一个是数据源的配置，另一个是数据库事务的配置。如下面的连接池的数据源配置："></a>配置环境可以注册多个数据源(dataSource),每一个数据源分为两大部分：一个是数据源的配置，另一个是数据库事务的配置。如下面的连接池的数据源配置：</h4></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--采用JDBC管理事务--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.driver&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.url&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.username&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;database.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><h4 id="environments中的属性default-表明在缺省的情况下，我们将启用哪个数据源配置"><a href="#environments中的属性default-表明在缺省的情况下，我们将启用哪个数据源配置" class="headerlink" title="environments中的属性default,表明在缺省的情况下，我们将启用哪个数据源配置"></a>environments中的属性default,表明在缺省的情况下，我们将启用哪个数据源配置</h4></li><li><h4 id="environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis上下文使用它"><a href="#environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis上下文使用它" class="headerlink" title="environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis上下文使用它"></a>environment元素是配置一个数据源的开始，属性id是设置这个数据源的标志，以便Mybatis上下文使用它</h4></li><li><h4 id="transactionManngaer配置的是数据库事务，其中type类型有3中配置方式："><a href="#transactionManngaer配置的是数据库事务，其中type类型有3中配置方式：" class="headerlink" title="transactionManngaer配置的是数据库事务，其中type类型有3中配置方式："></a>transactionManngaer配置的是数据库事务，其中type类型有3中配置方式：</h4><ol><li><h4 id="JDBC，采用JDBC方式管理事务，在独立编码中我们尝常常使用"><a href="#JDBC，采用JDBC方式管理事务，在独立编码中我们尝常常使用" class="headerlink" title="JDBC，采用JDBC方式管理事务，在独立编码中我们尝常常使用"></a>JDBC，采用JDBC方式管理事务，在独立编码中我们尝常常使用</h4></li><li><h4 id="MANAGED，采用容器方式管理事务，在JNDI数据源中常用"><a href="#MANAGED，采用容器方式管理事务，在JNDI数据源中常用" class="headerlink" title="MANAGED，采用容器方式管理事务，在JNDI数据源中常用"></a>MANAGED，采用容器方式管理事务，在JNDI数据源中常用</h4></li><li><h4 id="自定义，由使用者自定义数据库事务管理方法，适用于特俗应用"><a href="#自定义，由使用者自定义数据库事务管理方法，适用于特俗应用" class="headerlink" title="自定义，由使用者自定义数据库事务管理方法，适用于特俗应用"></a>自定义，由使用者自定义数据库事务管理方法，适用于特俗应用</h4><ul><li><h4 id="property元素则是可以配置数据源的各类属性，"><a href="#property元素则是可以配置数据源的各类属性，" class="headerlink" title="property元素则是可以配置数据源的各类属性，"></a>property元素则是可以配置数据源的各类属性，</h4></li><li><h4 id="dataSource-标签，是配置数据库连接的信息，type属性是我们对数据库连接方式的配置，Mybatis也提供了几种配置方式。"><a href="#dataSource-标签，是配置数据库连接的信息，type属性是我们对数据库连接方式的配置，Mybatis也提供了几种配置方式。" class="headerlink" title="dataSource 标签，是配置数据库连接的信息，type属性是我们对数据库连接方式的配置，Mybatis也提供了几种配置方式。"></a>dataSource 标签，是配置数据库连接的信息，type属性是我们对数据库连接方式的配置，Mybatis也提供了几种配置方式。</h4><ul><li><h4 id="UNPOOLED，非连接池数据库"><a href="#UNPOOLED，非连接池数据库" class="headerlink" title="UNPOOLED，非连接池数据库"></a>UNPOOLED，非连接池数据库</h4></li><li><h4 id="POOLED，连接池数据库"><a href="#POOLED，连接池数据库" class="headerlink" title="POOLED，连接池数据库"></a>POOLED，连接池数据库</h4></li><li><h4 id="JNDI，JNDI数据源"><a href="#JNDI，JNDI数据源" class="headerlink" title="JNDI，JNDI数据源"></a>JNDI，JNDI数据源</h4></li><li><h4 id="自定义数据源。"><a href="#自定义数据源。" class="headerlink" title="自定义数据源。"></a>自定义数据源。</h4></li><li><h4 id="其中配置的property元素就是定义数据库的各类参数。"><a href="#其中配置的property元素就是定义数据库的各类参数。" class="headerlink" title="其中配置的property元素就是定义数据库的各类参数。"></a>其中配置的property元素就是定义数据库的各类参数。</h4></li></ul></li></ul></li></ol></li></ol><h4 id="3-7-2-数据库事务"><a href="#3-7-2-数据库事务" class="headerlink" title="3.7.2    数据库事务"></a>3.7.2    数据库事务</h4><ul><li><h4 id="数据库事务-Mybatis-是交由SqlSession去控制的，我们可以通过SqlSession提交（commit）或者回滚（rollback），sql操作成功就提交，失败就回滚。"><a href="#数据库事务-Mybatis-是交由SqlSession去控制的，我们可以通过SqlSession提交（commit）或者回滚（rollback），sql操作成功就提交，失败就回滚。" class="headerlink" title="数据库事务 Mybatis 是交由SqlSession去控制的，我们可以通过SqlSession提交（commit）或者回滚（rollback），sql操作成功就提交，失败就回滚。"></a>数据库事务 Mybatis 是交由SqlSession去控制的，我们可以通过SqlSession提交（commit）或者回滚（rollback），sql操作成功就提交，失败就回滚。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001154913208.png" alt="image-20221001154913208"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001161009379.png" alt="image-20221001161009379"></p><h4 id="3-7-3-数据源"><a href="#3-7-3-数据源" class="headerlink" title="3.7.3  数据源"></a>3.7.3  数据源</h4><ul><li><h4 id="Mybatis内部提供了三种，只需要修改type为需要的即可。"><a href="#Mybatis内部提供了三种，只需要修改type为需要的即可。" class="headerlink" title="Mybatis内部提供了三种，只需要修改type为需要的即可。"></a>Mybatis内部提供了三种，只需要修改type为需要的即可。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001174448257.png" alt="image-20221001174448257"></p><ul><li><h4 id="对于自定义数据源，必须实现DataSourceFactory接口，比如我们需要实现DBCP，配置如下："><a href="#对于自定义数据源，必须实现DataSourceFactory接口，比如我们需要实现DBCP，配置如下：" class="headerlink" title="对于自定义数据源，必须实现DataSourceFactory接口，比如我们需要实现DBCP，配置如下："></a>对于自定义数据源，必须实现DataSourceFactory接口，比如我们需要实现DBCP，配置如下：</h4></li><li><h4 id="写个配置类"><a href="#写个配置类" class="headerlink" title="写个配置类"></a>写个配置类</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001174702401.png" alt="image-20221001174702401"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001174707877.png" alt="image-20221001174707877"></p><ul><li><h4 id="在配置文件中引用配置类"><a href="#在配置文件中引用配置类" class="headerlink" title="在配置文件中引用配置类"></a>在配置文件中引用配置类</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001174744536.png" alt="image-20221001174744536"></p><h3 id="3-8-databaseProvider-数据库厂商标识"><a href="#3-8-databaseProvider-数据库厂商标识" class="headerlink" title="3.8    databaseProvider 数据库厂商标识"></a>3.8    databaseProvider 数据库厂商标识</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001175956645.png" alt="image-20221001175956645"></p><h4 id="3-8-1-使用系统默认规则"><a href="#3-8-1-使用系统默认规则" class="headerlink" title="3.8.1   使用系统默认规则"></a>3.8.1   使用系统默认规则</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001180138714.png" alt="image-20221001180138714"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001180151067.png" alt="image-20221001180151067"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001180205439.png" alt="image-20221001180205439"></p><h4 id="3-8-2-不使用系统默认规则"><a href="#3-8-2-不使用系统默认规则" class="headerlink" title="3.8.2   不使用系统默认规则"></a>3.8.2   不使用系统默认规则</h4><ul><li><h4 id="自定义规则，-x3D-x3D-只要实现databaseIDProvider接口，并且实现配置即可。-x3D-x3D-示例如下："><a href="#自定义规则，-x3D-x3D-只要实现databaseIDProvider接口，并且实现配置即可。-x3D-x3D-示例如下：" class="headerlink" title="自定义规则，&#x3D;&#x3D;只要实现databaseIDProvider接口，并且实现配置即可。&#x3D;&#x3D; 示例如下："></a>自定义规则，&#x3D;&#x3D;只要实现databaseIDProvider接口，并且实现配置即可。&#x3D;&#x3D; 示例如下：</h4></li><li><h4 id="实现配置类"><a href="#实现配置类" class="headerlink" title="实现配置类"></a>实现配置类</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001180351455.png" alt="image-20221001180351455"></p><ul><li><h4 id="在配置文件中引用配置标签"><a href="#在配置文件中引用配置标签" class="headerlink" title="在配置文件中引用配置标签"></a>在配置文件中引用配置标签</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001180441096.png" alt="image-20221001180441096"></p><ol><li><h4 id="把type修改为我们自己的实现类，类里面setProperties方法里面的参数传递进去的将会是XML里面的配置的信息，我们保存在类的变量是properties，方便以后读出，在getDataBaseID中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseID。"><a href="#把type修改为我们自己的实现类，类里面setProperties方法里面的参数传递进去的将会是XML里面的配置的信息，我们保存在类的变量是properties，方便以后读出，在getDataBaseID中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseID。" class="headerlink" title="把type修改为我们自己的实现类，类里面setProperties方法里面的参数传递进去的将会是XML里面的配置的信息，我们保存在类的变量是properties，方便以后读出，在getDataBaseID中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseID。"></a>把type修改为我们自己的实现类，类里面setProperties方法里面的参数传递进去的将会是XML里面的配置的信息，我们保存在类的变量是properties，方便以后读出，在getDataBaseID中，传递的参数是数据库数据源，我们获取其名称，然后通过properties的键值找到对应的databaseID。</h4></li></ol><ul><li><h4 id="注意：如有特殊要求，我们可以根据自己所需要的规则来编写databaseIdProvider，配置mapper，使用规则和默认规则是一致的。"><a href="#注意：如有特殊要求，我们可以根据自己所需要的规则来编写databaseIdProvider，配置mapper，使用规则和默认规则是一致的。" class="headerlink" title="注意：如有特殊要求，我们可以根据自己所需要的规则来编写databaseIdProvider，配置mapper，使用规则和默认规则是一致的。"></a>注意：如有特殊要求，我们可以根据自己所需要的规则来编写databaseIdProvider，配置mapper，使用规则和默认规则是一致的。</h4></li></ul><h3 id="3-9-引入映射器的方法"><a href="#3-9-引入映射器的方法" class="headerlink" title="3.9   引入映射器的方法"></a>3.9   引入映射器的方法</h3><ul><li><h4 id="x3D-x3D-映射器是Mybatis-最复杂，最核心的组件-x3D-x3D-。包括如何引入映射器，和它的参数类型，动态sql，定义sql，缓存信息等。"><a href="#x3D-x3D-映射器是Mybatis-最复杂，最核心的组件-x3D-x3D-。包括如何引入映射器，和它的参数类型，动态sql，定义sql，缓存信息等。" class="headerlink" title="&#x3D;&#x3D;映射器是Mybatis 最复杂，最核心的组件&#x3D;&#x3D;。包括如何引入映射器，和它的参数类型，动态sql，定义sql，缓存信息等。"></a>&#x3D;&#x3D;映射器是Mybatis 最复杂，最核心的组件&#x3D;&#x3D;。包括如何引入映射器，和它的参数类型，动态sql，定义sql，缓存信息等。</h4></li></ul><ol><li><h4 id="前面介绍了映射器定义命名空间的方法，-x3D-x3D-命名空间对应的是一个接口的全路径，而不是实现类-x3D-x3D-。"><a href="#前面介绍了映射器定义命名空间的方法，-x3D-x3D-命名空间对应的是一个接口的全路径，而不是实现类-x3D-x3D-。" class="headerlink" title="前面介绍了映射器定义命名空间的方法，&#x3D;&#x3D;命名空间对应的是一个接口的全路径，而不是实现类&#x3D;&#x3D;。"></a>前面介绍了映射器定义命名空间的方法，&#x3D;&#x3D;命名空间对应的是一个接口的全路径，而不是实现类&#x3D;&#x3D;。</h4></li><li><h4 id="实现映射器的接口-即DAO-层。"><a href="#实现映射器的接口-即DAO-层。" class="headerlink" title="实现映射器的接口 即DAO 层。"></a>实现映射器的接口 即DAO 层。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181450819.png" alt="image-20221001181450819"></p><ol><li><h4 id="给出XML文件，即mapper-xml-注意不是Mybatis的配置文件而是另外的XML文件，如userMapper-xml"><a href="#给出XML文件，即mapper-xml-注意不是Mybatis的配置文件而是另外的XML文件，如userMapper-xml" class="headerlink" title="给出XML文件，即mapper.xml (注意不是Mybatis的配置文件而是另外的XML文件，如userMapper.xml)"></a>给出XML文件，即mapper.xml (注意不是Mybatis的配置文件而是另外的XML文件，如userMapper.xml)</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181526760.png" alt="image-20221001181526760"></p><ul><li><h4 id="引入映射器的方法很多，一般分为："><a href="#引入映射器的方法很多，一般分为：" class="headerlink" title="引入映射器的方法很多，一般分为："></a>引入映射器的方法很多，一般分为：</h4></li></ul><ol><li><h4 id="x3D-x3D-用文件路径引入映射器-x3D-x3D-，如："><a href="#x3D-x3D-用文件路径引入映射器-x3D-x3D-，如：" class="headerlink" title="&#x3D;&#x3D;用文件路径引入映射器&#x3D;&#x3D;，如："></a>&#x3D;&#x3D;用文件路径引入映射器&#x3D;&#x3D;，如：</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181651765.png" alt="image-20221001181651765"></p></li><li><h4 id="x3D-x3D-用包名引入映射器-x3D-x3D-，如："><a href="#x3D-x3D-用包名引入映射器-x3D-x3D-，如：" class="headerlink" title="&#x3D;&#x3D;用包名引入映射器&#x3D;&#x3D;，如："></a>&#x3D;&#x3D;用包名引入映射器&#x3D;&#x3D;，如：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181715892.png" alt="image-20221001181715892"></p><ol><li><h4 id="x3D-x3D-用类注册引入映射器-x3D-x3D-，如："><a href="#x3D-x3D-用类注册引入映射器-x3D-x3D-，如：" class="headerlink" title="&#x3D;&#x3D;用类注册引入映射器&#x3D;&#x3D;，如："></a>&#x3D;&#x3D;用类注册引入映射器&#x3D;&#x3D;，如：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181738427.png" alt="image-20221001181738427"></p><ol><li><h4 id="用userMapper-xml-应用映射器，如："><a href="#用userMapper-xml-应用映射器，如：" class="headerlink" title="用userMapper.xml 应用映射器，如："></a>用userMapper.xml 应用映射器，如：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001181825924.png" alt="image-20221001181825924"></p><ul><li><h4 id="可以根据实际的需要选择恰当的引入方法。"><a href="#可以根据实际的需要选择恰当的引入方法。" class="headerlink" title="可以根据实际的需要选择恰当的引入方法。"></a>可以根据实际的需要选择恰当的引入方法。</h4></li></ul><h2 id="第四章-映射器"><a href="#第四章-映射器" class="headerlink" title="第四章  映射器"></a>第四章  映射器</h2><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001215419497.png" alt="image-20221001215419497"></p><h3 id="4-1-映射器的主要元素"><a href="#4-1-映射器的主要元素" class="headerlink" title="4.1   映射器的主要元素"></a>4.1   映射器的主要元素</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001215803129.png" alt="image-20221001215803129"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001220630307.png" alt="image-20221001220630307"></p><h3 id="4-2-select-元素"><a href="#4-2-select-元素" class="headerlink" title="4.2   select 元素"></a>4.2   select 元素</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><ul><li><h4 id="select-元素的配置"><a href="#select-元素的配置" class="headerlink" title="select 元素的配置"></a>select 元素的配置</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001220745092.png" alt="image-20221001220745092"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001221120766.png" alt="image-20221001221120766"></p><h4 id="4-2-2-简易数据类型的例子"><a href="#4-2-2-简易数据类型的例子" class="headerlink" title="4.2.2   简易数据类型的例子"></a>4.2.2   简易数据类型的例子</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001221757416.png" alt="image-20221001221757416"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001221808986.png" alt="image-20221001221808986"></p><ol><li><h4 id="UserDao-中定义方法"><a href="#UserDao-中定义方法" class="headerlink" title="UserDao 中定义方法"></a>UserDao 中定义方法</h4></li><li><h4 id="再userMapper-中学sql。"><a href="#再userMapper-中学sql。" class="headerlink" title="再userMapper 中学sql。"></a>再userMapper 中学sql。</h4></li></ol><ul><li><h4 id="id-标出了这条sql"><a href="#id-标出了这条sql" class="headerlink" title="id 标出了这条sql"></a>id 标出了这条sql</h4></li><li><h4 id="parameterType-定义了参数类型"><a href="#parameterType-定义了参数类型" class="headerlink" title="parameterType 定义了参数类型"></a>parameterType 定义了参数类型</h4></li><li><h4 id="resultType-定义sql返回值类型。"><a href="#resultType-定义sql返回值类型。" class="headerlink" title="resultType 定义sql返回值类型。"></a>resultType 定义sql返回值类型。</h4></li><li><h4 id="x3D-x3D-注意-以上仅仅是入门实例，以后遇到的会更加复杂-x3D-x3D-。"><a href="#x3D-x3D-注意-以上仅仅是入门实例，以后遇到的会更加复杂-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;注意 以上仅仅是入门实例，以后遇到的会更加复杂&#x3D;&#x3D;。"></a>&#x3D;&#x3D;注意 以上仅仅是入门实例，以后遇到的会更加复杂&#x3D;&#x3D;。</h4></li></ul><h4 id="4-2-3-自动映射"><a href="#4-2-3-自动映射" class="headerlink" title="4.2.3   自动映射"></a>4.2.3   自动映射</h4><ul><li><h4 id="有这样一个参数，autoMappingBehavior，当它不设置为NONE时，Mybatis-会提供自动映射功能，只要返回的sql列名和javaBean属性一样。Mybatis就会帮助我们回填这些字段而无需任何配置。"><a href="#有这样一个参数，autoMappingBehavior，当它不设置为NONE时，Mybatis-会提供自动映射功能，只要返回的sql列名和javaBean属性一样。Mybatis就会帮助我们回填这些字段而无需任何配置。" class="headerlink" title="有这样一个参数，autoMappingBehavior，当它不设置为NONE时，Mybatis 会提供自动映射功能，只要返回的sql列名和javaBean属性一样。Mybatis就会帮助我们回填这些字段而无需任何配置。"></a>有这样一个参数，autoMappingBehavior，当它不设置为NONE时，Mybatis 会提供自动映射功能，只要返回的sql列名和javaBean属性一样。Mybatis就会帮助我们回填这些字段而无需任何配置。</h4></li><li><h4 id="x3D-x3D-实际情况中，大部分数据库规范都要求每个单词下划分隔离，而java则采用驼峰命名法，于是使用列的别名就可以使得Mybatis自动映射，或者直接再配置文件中开启驼峰命名方式。-x3D-x3D"><a href="#x3D-x3D-实际情况中，大部分数据库规范都要求每个单词下划分隔离，而java则采用驼峰命名法，于是使用列的别名就可以使得Mybatis自动映射，或者直接再配置文件中开启驼峰命名方式。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;实际情况中，大部分数据库规范都要求每个单词下划分隔离，而java则采用驼峰命名法，于是使用列的别名就可以使得Mybatis自动映射，或者直接再配置文件中开启驼峰命名方式。&#x3D;&#x3D;"></a>&#x3D;&#x3D;实际情况中，大部分数据库规范都要求每个单词下划分隔离，而java则采用驼峰命名法，于是使用列的别名就可以使得Mybatis自动映射，或者直接再配置文件中开启驼峰命名方式。&#x3D;&#x3D;</h4></li><li><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4></li><li><h4 id="定义javaBean"><a href="#定义javaBean" class="headerlink" title="定义javaBean"></a>定义javaBean</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001222836232.png" alt="image-20221001222836232"></p><ul><li><h4 id="数据库建表字段-要与-javaBean名字“-相似”"><a href="#数据库建表字段-要与-javaBean名字“-相似”" class="headerlink" title="数据库建表字段 要与 javaBean名字“ 相似”"></a>数据库建表字段 要与 javaBean名字“ 相似”</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001222918084.png" alt="image-20221001222918084"></p><ul><li><h4 id="写mapper-xml-映射语句"><a href="#写mapper-xml-映射语句" class="headerlink" title="写mapper.xml 映射语句"></a>写mapper.xml 映射语句</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001223117400.png" alt="image-20221001223117400"></p><ul><li><h4 id="写Dao层接口，方法"><a href="#写Dao层接口，方法" class="headerlink" title="写Dao层接口，方法"></a>写Dao层接口，方法</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001223143263.png" alt="image-20221001223143263"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001223946601.png" alt="image-20221001223946601"></p><ul><li><h4 id="自动映射可以在settings-元素中配置autoMappingBehavior属性值来设置策略"><a href="#自动映射可以在settings-元素中配置autoMappingBehavior属性值来设置策略" class="headerlink" title="自动映射可以在settings 元素中配置autoMappingBehavior属性值来设置策略"></a>自动映射可以在settings 元素中配置autoMappingBehavior属性值来设置策略</h4><ul><li><h4 id="NONE，取消自动映射"><a href="#NONE，取消自动映射" class="headerlink" title="NONE，取消自动映射"></a>NONE，取消自动映射</h4></li><li><h4 id="partial，只会自动映射，没有定义嵌套结果集映射的结果集"><a href="#partial，只会自动映射，没有定义嵌套结果集映射的结果集" class="headerlink" title="partial，只会自动映射，没有定义嵌套结果集映射的结果集"></a>partial，只会自动映射，没有定义嵌套结果集映射的结果集</h4></li><li><h4 id="FULL，会自动映射任意复杂的结果集（无论是否嵌套）。"><a href="#FULL，会自动映射任意复杂的结果集（无论是否嵌套）。" class="headerlink" title="FULL，会自动映射任意复杂的结果集（无论是否嵌套）。"></a>FULL，会自动映射任意复杂的结果集（无论是否嵌套）。</h4></li></ul></li><li><h4 id="注意：-x3D-x3D-如果数据库是规范命名的，即每个单词都用下划线分割，POJO采用驼峰命名-x3D-x3D-，那么也可以设置-x3D-x3D-mapUnderscoreToCamelCase为True-x3D-x3D-，这样就可以实现从数据库到POJO的自动映射了。"><a href="#注意：-x3D-x3D-如果数据库是规范命名的，即每个单词都用下划线分割，POJO采用驼峰命名-x3D-x3D-，那么也可以设置-x3D-x3D-mapUnderscoreToCamelCase为True-x3D-x3D-，这样就可以实现从数据库到POJO的自动映射了。" class="headerlink" title="注意：&#x3D;&#x3D;如果数据库是规范命名的，即每个单词都用下划线分割，POJO采用驼峰命名&#x3D;&#x3D;，那么也可以设置&#x3D;&#x3D;mapUnderscoreToCamelCase为True&#x3D;&#x3D;，这样就可以实现从数据库到POJO的自动映射了。"></a>注意：&#x3D;&#x3D;如果数据库是规范命名的，即每个单词都用下划线分割，POJO采用驼峰命名&#x3D;&#x3D;，那么也可以设置&#x3D;&#x3D;mapUnderscoreToCamelCase为True&#x3D;&#x3D;，这样就可以实现从数据库到POJO的自动映射了。</h4></li></ul><h4 id="4-2-4-传递多个参数"><a href="#4-2-4-传递多个参数" class="headerlink" title="4.2.4   传递多个参数"></a>4.2.4   传递多个参数</h4><ul><li><h4 id="当需要传递多个参数给映射器时，又是不一样的情况。"><a href="#当需要传递多个参数给映射器时，又是不一样的情况。" class="headerlink" title="当需要传递多个参数给映射器时，又是不一样的情况。"></a>当需要传递多个参数给映射器时，又是不一样的情况。</h4></li></ul><h5 id="4-2-4-1-使用Map-传递参数"><a href="#4-2-4-1-使用Map-传递参数" class="headerlink" title="4.2.4.1  使用Map 传递参数"></a>4.2.4.1  使用Map 传递参数</h5><ul><li><h4 id="我们可以使用Mybatis提供的Map接口作为参数来实现。"><a href="#我们可以使用Mybatis提供的Map接口作为参数来实现。" class="headerlink" title="我们可以使用Mybatis提供的Map接口作为参数来实现。"></a>我们可以使用Mybatis提供的Map接口作为参数来实现。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001224444432.png" alt="image-20221001224444432"></p><ul><li><h4 id="注意：-x3D-x3D-parameterType是-map，resultType-也变成了resultMap。-x3D-x3D"><a href="#注意：-x3D-x3D-parameterType是-map，resultType-也变成了resultMap。-x3D-x3D" class="headerlink" title="注意： &#x3D;&#x3D;parameterType是 map，resultType 也变成了resultMap。&#x3D;&#x3D;"></a>注意： &#x3D;&#x3D;parameterType是 map，resultType 也变成了resultMap。&#x3D;&#x3D;</h4></li><li><h4 id="对于Dao-层，提供一个方法："><a href="#对于Dao-层，提供一个方法：" class="headerlink" title="对于Dao 层，提供一个方法："></a>对于Dao 层，提供一个方法：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001224616261.png" alt="image-20221001224616261"></p><ul><li><h4 id="传递的参数是Map。"><a href="#传递的参数是Map。" class="headerlink" title="传递的参数是Map。"></a>传递的参数是Map。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001224635130.png" alt="image-20221001224635130"></p><ul><li><h4 id="这么做虽然简单易用，但是有一个弊端：这样设置的参数使用了Map，而Map需要键值对-对应，由于业务关联性不强，所以需要比较深入的看代码。造成-x3D-x3D-可读性下降-x3D-x3D-，-x3D-x3D-Mybatis为我们提供了更好的实现方法，那就是注解的形式-x3D-x3D-。"><a href="#这么做虽然简单易用，但是有一个弊端：这样设置的参数使用了Map，而Map需要键值对-对应，由于业务关联性不强，所以需要比较深入的看代码。造成-x3D-x3D-可读性下降-x3D-x3D-，-x3D-x3D-Mybatis为我们提供了更好的实现方法，那就是注解的形式-x3D-x3D-。" class="headerlink" title="这么做虽然简单易用，但是有一个弊端：这样设置的参数使用了Map，而Map需要键值对 对应，由于业务关联性不强，所以需要比较深入的看代码。造成&#x3D;&#x3D;可读性下降&#x3D;&#x3D;，&#x3D;&#x3D;Mybatis为我们提供了更好的实现方法，那就是注解的形式&#x3D;&#x3D;。"></a>这么做虽然简单易用，但是有一个弊端：这样设置的参数使用了Map，而Map需要键值对 对应，由于业务关联性不强，所以需要比较深入的看代码。造成&#x3D;&#x3D;可读性下降&#x3D;&#x3D;，&#x3D;&#x3D;Mybatis为我们提供了更好的实现方法，那就是注解的形式&#x3D;&#x3D;。</h4></li></ul><h5 id="4-2-4-2-使用注解方式传递参数"><a href="#4-2-4-2-使用注解方式传递参数" class="headerlink" title="4.2.4.2     使用注解方式传递参数"></a>4.2.4.2     使用注解方式传递参数</h5><ul><li><h4 id="我们可以使用Mybatis-的注解参数，-Param来实现参数传递。"><a href="#我们可以使用Mybatis-的注解参数，-Param来实现参数传递。" class="headerlink" title="我们可以使用Mybatis 的注解参数，@Param来实现参数传递。"></a>我们可以使用Mybatis 的注解参数，@Param来实现参数传递。</h4></li><li><h4 id="修改Dao层方法。"><a href="#修改Dao层方法。" class="headerlink" title="修改Dao层方法。"></a>修改Dao层方法。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001225329507.png" alt="image-20221001225329507"></p><ul><li><h4 id="把映射器Mapper-xml-x3D-x3D-修改为无需定义参数类型-x3D-x3D-。"><a href="#把映射器Mapper-xml-x3D-x3D-修改为无需定义参数类型-x3D-x3D-。" class="headerlink" title="把映射器Mapper.xml &#x3D;&#x3D;修改为无需定义参数类型&#x3D;&#x3D;。"></a>把映射器Mapper.xml &#x3D;&#x3D;修改为无需定义参数类型&#x3D;&#x3D;。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001225401850.png" alt="image-20221001225401850"></p><ul><li><h4 id="通过-Param提供的名称，Mybatis就能自动把参数参入到sql语句中。"><a href="#通过-Param提供的名称，Mybatis就能自动把参数参入到sql语句中。" class="headerlink" title="通过@Param提供的名称，Mybatis就能自动把参数参入到sql语句中。"></a>通过@Param提供的名称，Mybatis就能自动把参数参入到sql语句中。</h4></li><li><h4 id="注意：-x3D-x3D-当需要传入的参数过多时，那么用注解的方法就显得很繁琐-x3D-x3D-，所以Mybatis还提供了JavaBean定义参数的方式来解决这个问题。"><a href="#注意：-x3D-x3D-当需要传入的参数过多时，那么用注解的方法就显得很繁琐-x3D-x3D-，所以Mybatis还提供了JavaBean定义参数的方式来解决这个问题。" class="headerlink" title="注意：&#x3D;&#x3D;当需要传入的参数过多时，那么用注解的方法就显得很繁琐&#x3D;&#x3D;，所以Mybatis还提供了JavaBean定义参数的方式来解决这个问题。"></a>注意：&#x3D;&#x3D;当需要传入的参数过多时，那么用注解的方法就显得很繁琐&#x3D;&#x3D;，所以Mybatis还提供了JavaBean定义参数的方式来解决这个问题。</h4></li></ul><h5 id="4-2-4-3-使用javaBean-传递参数"><a href="#4-2-4-3-使用javaBean-传递参数" class="headerlink" title="4.2.4.3  使用javaBean  传递参数"></a>4.2.4.3  使用javaBean  传递参数</h5><ol><li><h4 id="参数过多时，Mybatis运行组织一个javaBean，-x3D-x3D-通过简单的setter，getter，方法-x3D-x3D-来设置参数，这样就可以提高我们的代码可读性。"><a href="#参数过多时，Mybatis运行组织一个javaBean，-x3D-x3D-通过简单的setter，getter，方法-x3D-x3D-来设置参数，这样就可以提高我们的代码可读性。" class="headerlink" title="参数过多时，Mybatis运行组织一个javaBean，&#x3D;&#x3D;通过简单的setter，getter，方法&#x3D;&#x3D;来设置参数，这样就可以提高我们的代码可读性。"></a>参数过多时，Mybatis运行组织一个javaBean，&#x3D;&#x3D;通过简单的setter，getter，方法&#x3D;&#x3D;来设置参数，这样就可以提高我们的代码可读性。</h4></li></ol><ul><li><h4 id="首先先实现这个参数的实现类：如RoleParam"><a href="#首先先实现这个参数的实现类：如RoleParam" class="headerlink" title="首先先实现这个参数的实现类：如RoleParam"></a>首先先实现这个参数的实现类：如RoleParam</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001225853292.png" alt="image-20221001225853292"></p><ul><li><h4 id="然后再修改映射器中的配置。再paramType中写入参数配置类的路径位置，返回结果用：resultMap"><a href="#然后再修改映射器中的配置。再paramType中写入参数配置类的路径位置，返回结果用：resultMap" class="headerlink" title="然后再修改映射器中的配置。再paramType中写入参数配置类的路径位置，返回结果用：resultMap"></a>然后再修改映射器中的配置。再paramType中写入参数配置类的路径位置，返回结果用：resultMap</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001225939624.png" alt="image-20221001225939624"></p><ul><li><h4 id="x3D-x3D-同样的在Dao层实现接口层，传递一个-配置的参数类对象。RoleParam。-x3D-x3D"><a href="#x3D-x3D-同样的在Dao层实现接口层，传递一个-配置的参数类对象。RoleParam。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;同样的在Dao层实现接口层，传递一个 配置的参数类对象。RoleParam。&#x3D;&#x3D;"></a>&#x3D;&#x3D;同样的在Dao层实现接口层，传递一个 配置的参数类对象。RoleParam。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001230113948.png" alt="image-20221001230113948"></p><h5 id="4-2-4-4-总结"><a href="#4-2-4-4-总结" class="headerlink" title="4.2.4.4  总结"></a>4.2.4.4  总结</h5><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001230135889.png" alt="image-20221001230135889"></p><h4 id="4-2-5-使用resultMap映射结果集"><a href="#4-2-5-使用resultMap映射结果集" class="headerlink" title="4.2.5     使用resultMap映射结果集"></a>4.2.5     使用resultMap映射结果集</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001231450456.png" alt="image-20221001231450456"></p><ul><li><h4 id="resultMap的配置"><a href="#resultMap的配置" class="headerlink" title="resultMap的配置"></a>resultMap的配置</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001231457959.png"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221001231520264.png" alt="image-20221001231520264"></p><h3 id="4-3-insert-元素"><a href="#4-3-insert-元素" class="headerlink" title="4.3   insert 元素"></a>4.3   insert 元素</h3><h4 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h4><ul><li><h4 id="Mybatis-会在插入之后返回一个整数，表示你进行操作后插入的记录数。"><a href="#Mybatis-会在插入之后返回一个整数，表示你进行操作后插入的记录数。" class="headerlink" title="Mybatis 会在插入之后返回一个整数，表示你进行操作后插入的记录数。"></a>Mybatis 会在插入之后返回一个整数，表示你进行操作后插入的记录数。</h4></li><li><h4 id="Insert-元素配置详情"><a href="#Insert-元素配置详情" class="headerlink" title="Insert 元素配置详情"></a>Insert 元素配置详情</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003194543850.png" alt="image-20221003194543850"></p><ol><li><h4 id="虽然以上的元素有很多，但是实际操作用到的元素只有几个，例如插入角色："><a href="#虽然以上的元素有很多，但是实际操作用到的元素只有几个，例如插入角色：" class="headerlink" title="虽然以上的元素有很多，但是实际操作用到的元素只有几个，例如插入角色："></a>虽然以上的元素有很多，但是实际操作用到的元素只有几个，例如插入角色：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003194710117.png" alt="image-20221003194710117"></p><ul><li><h4 id="指明id-，"><a href="#指明id-，" class="headerlink" title="指明id ，"></a>指明id ，</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003194843662.png" alt="image-20221003194843662"></p></li><li><h4 id="指明参数类型。"><a href="#指明参数类型。" class="headerlink" title="指明参数类型。"></a>指明参数类型。</h4></li></ul><h4 id="4-3-2-主键回填和自定义"><a href="#4-3-2-主键回填和自定义" class="headerlink" title="4.3.2  主键回填和自定义"></a>4.3.2  主键回填和自定义</h4><ul><li><h4 id="场景：-数据库中主键自增，如mysql主键需要根据规则生成，在插入后，我们往往需要这个主键，而Mybatis-提供了方法。"><a href="#场景：-数据库中主键自增，如mysql主键需要根据规则生成，在插入后，我们往往需要这个主键，而Mybatis-提供了方法。" class="headerlink" title="场景：  数据库中主键自增，如mysql主键需要根据规则生成，在插入后，我们往往需要这个主键，而Mybatis 提供了方法。"></a>场景：  数据库中主键自增，如mysql主键需要根据规则生成，在插入后，我们往往需要这个主键，而Mybatis 提供了方法。</h4></li></ul><ol><li><h4 id="首先我们可以使用-x3D-x3D-keyProperty属性指定哪个是主键字段-x3D-x3D-，同时-x3D-x3D-使用useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成-x3D-x3D-。"><a href="#首先我们可以使用-x3D-x3D-keyProperty属性指定哪个是主键字段-x3D-x3D-，同时-x3D-x3D-使用useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成-x3D-x3D-。" class="headerlink" title="首先我们可以使用&#x3D;&#x3D;keyProperty属性指定哪个是主键字段&#x3D;&#x3D;，同时&#x3D;&#x3D;使用useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成&#x3D;&#x3D;。"></a>首先我们可以使用&#x3D;&#x3D;keyProperty属性指定哪个是主键字段&#x3D;&#x3D;，同时&#x3D;&#x3D;使用useGeneratedKeys属性告诉Mybatis这个主键是否使用数据库内置策略生成&#x3D;&#x3D;。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003195654458.png" alt="image-20221003195654458"></p><ul><li><h4 id="这样我们传入role对象就不需要设置id的值，Mybatis会用数据库的设置进行处理，这样做的好处就是在Mybatis插入时，他会回填javaBean的id值。"><a href="#这样我们传入role对象就不需要设置id的值，Mybatis会用数据库的设置进行处理，这样做的好处就是在Mybatis插入时，他会回填javaBean的id值。" class="headerlink" title="这样我们传入role对象就不需要设置id的值，Mybatis会用数据库的设置进行处理，这样做的好处就是在Mybatis插入时，他会回填javaBean的id值。"></a>这样我们传入role对象就不需要设置id的值，Mybatis会用数据库的设置进行处理，这样做的好处就是在Mybatis插入时，他会回填javaBean的id值。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003200022020.png" alt="image-20221003200022020"></p><ol><li><h4 id="注意：-实际工作并不是以上那么简单，还需要根据一些特殊的关系来设置主键id的值，"><a href="#注意：-实际工作并不是以上那么简单，还需要根据一些特殊的关系来设置主键id的值，" class="headerlink" title="注意： 实际工作并不是以上那么简单，还需要根据一些特殊的关系来设置主键id的值，"></a>注意： 实际工作并不是以上那么简单，还需要根据一些特殊的关系来设置主键id的值，</h4><ol><li><h4 id="假如：我们取消t-role-的id-自增的规则，-x3D-x3D-我们的要求是：如果t-role-没有记录，那么设置id-x3D-1，-fou’ze我们就取最大的id-2，来设置新的主键-x3D-x3D-，对于这样的要求-Mybatis-也提供了方法。"><a href="#假如：我们取消t-role-的id-自增的规则，-x3D-x3D-我们的要求是：如果t-role-没有记录，那么设置id-x3D-1，-fou’ze我们就取最大的id-2，来设置新的主键-x3D-x3D-，对于这样的要求-Mybatis-也提供了方法。" class="headerlink" title="假如：我们取消t_role 的id 自增的规则，&#x3D;&#x3D;我们的要求是：如果t_role 没有记录，那么设置id &#x3D;1， fou’ze我们就取最大的id +2，来设置新的主键&#x3D;&#x3D;，对于这样的要求,Mybatis 也提供了方法。"></a>假如：我们取消t_role 的id 自增的规则，&#x3D;&#x3D;我们的要求是：如果t_role 没有记录，那么设置id &#x3D;1， fou’ze我们就取最大的id +2，来设置新的主键&#x3D;&#x3D;，对于这样的要求,Mybatis 也提供了方法。</h4></li></ol></li></ol><ul><li><h4 id="以下即是例子：-使用自定义主键规则生成主键。"><a href="#以下即是例子：-使用自定义主键规则生成主键。" class="headerlink" title="以下即是例子：  使用自定义主键规则生成主键。"></a>以下即是例子：  使用自定义主键规则生成主键。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003200549680.png" alt="image-20221003200549680"></p><ul><li><h4 id="足以体现Mybatis-的灵活性。"><a href="#足以体现Mybatis-的灵活性。" class="headerlink" title="足以体现Mybatis 的灵活性。"></a>足以体现Mybatis 的灵活性。</h4></li></ul><h3 id="4-4-update-元素和delete元素"><a href="#4-4-update-元素和delete元素" class="headerlink" title="4.4    update 元素和delete元素"></a>4.4    update 元素和delete元素</h3><ul><li><h4 id="和insert-元素一样，执行操作完成后Mybatis会返回一个整数，标出执行后受影响的记录条数。"><a href="#和insert-元素一样，执行操作完成后Mybatis会返回一个整数，标出执行后受影响的记录条数。" class="headerlink" title="和insert 元素一样，执行操作完成后Mybatis会返回一个整数，标出执行后受影响的记录条数。"></a>和insert 元素一样，执行操作完成后Mybatis会返回一个整数，标出执行后受影响的记录条数。</h4></li><li><h4 id="更新和删除在映射器中的实现："><a href="#更新和删除在映射器中的实现：" class="headerlink" title="更新和删除在映射器中的实现："></a>更新和删除在映射器中的实现：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003201022513.png" alt="image-20221003201022513"></p><ul><li><h4 id="我们所面对的大部分删除更新场景都和上面类似，需要通过javaBean插入一张表的记录或者根据主键删除记录，对于参数的传递，可以参考select-元素-、"><a href="#我们所面对的大部分删除更新场景都和上面类似，需要通过javaBean插入一张表的记录或者根据主键删除记录，对于参数的传递，可以参考select-元素-、" class="headerlink" title="我们所面对的大部分删除更新场景都和上面类似，需要通过javaBean插入一张表的记录或者根据主键删除记录，对于参数的传递，可以参考select 元素 、"></a>我们所面对的大部分删除更新场景都和上面类似，需要通过javaBean插入一张表的记录或者根据主键删除记录，对于参数的传递，可以参考select 元素 、</h4></li></ul><h3 id="4-5-参数"><a href="#4-5-参数" class="headerlink" title="4.5  参数"></a>4.5  参数</h3><ul><li><h4 id="我们可以通过制定参数的类型让对应的typeHandler处理他们。"><a href="#我们可以通过制定参数的类型让对应的typeHandler处理他们。" class="headerlink" title="我们可以通过制定参数的类型让对应的typeHandler处理他们。"></a>我们可以通过制定参数的类型让对应的typeHandler处理他们。</h4></li><li><h4 id="x3D-x3D-定义参数属性的时候，Mybatis不允许换行。-x3D-x3D"><a href="#x3D-x3D-定义参数属性的时候，Mybatis不允许换行。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;定义参数属性的时候，Mybatis不允许换行。&#x3D;&#x3D;"></a>&#x3D;&#x3D;定义参数属性的时候，Mybatis不允许换行。&#x3D;&#x3D;</h4></li></ul><h4 id="4-5-1-参数配置"><a href="#4-5-1-参数配置" class="headerlink" title="4.5.1  参数配置"></a>4.5.1  参数配置</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003202938362.png" alt="image-20221003202938362"></p><ol><li><h4 id="可以指明参数的类型，指明typeHandler的类型"><a href="#可以指明参数的类型，指明typeHandler的类型" class="headerlink" title="可以指明参数的类型，指明typeHandler的类型"></a>可以指明参数的类型，指明typeHandler的类型</h4></li><li><h4 id="还能对整数型的参数设置其保存的精度。"><a href="#还能对整数型的参数设置其保存的精度。" class="headerlink" title="还能对整数型的参数设置其保存的精度。"></a>还能对整数型的参数设置其保存的精度。</h4></li></ol><h4 id="4-5-2-存储过程支持"><a href="#4-5-2-存储过程支持" class="headerlink" title="4.5.2   存储过程支持"></a>4.5.2   存储过程支持</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003203541837.png" alt="image-20221003203541837"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003203603902.png" alt="image-20221003203603902"></p><ol><li><h4 id="x3D-x3D-在大部分情况下，Mybatis-都会去推断我们的返回类型，所以无需去配置参数类型和结果类型，需要设置的往往是可能返回为空的字段类型-x3D-x3D-，因为为null，Mybatis-无法判断它的类型。"><a href="#x3D-x3D-在大部分情况下，Mybatis-都会去推断我们的返回类型，所以无需去配置参数类型和结果类型，需要设置的往往是可能返回为空的字段类型-x3D-x3D-，因为为null，Mybatis-无法判断它的类型。" class="headerlink" title="&#x3D;&#x3D;在大部分情况下，Mybatis 都会去推断我们的返回类型，所以无需去配置参数类型和结果类型，需要设置的往往是可能返回为空的字段类型&#x3D;&#x3D;，因为为null，Mybatis 无法判断它的类型。"></a>&#x3D;&#x3D;在大部分情况下，Mybatis 都会去推断我们的返回类型，所以无需去配置参数类型和结果类型，需要设置的往往是可能返回为空的字段类型&#x3D;&#x3D;，因为为null，Mybatis 无法判断它的类型。</h4></li></ol><h4 id="4-5-3-特殊字符串替换-和处理（-和"><a href="#4-5-3-特殊字符串替换-和处理（-和" class="headerlink" title="4.5.3  特殊字符串替换  和处理（ # 和 $)"></a>4.5.3  特殊字符串替换  和处理（ # 和 $)</h4><ul><li><h4 id="在Mybatis中，我们经常传递字符串，我们设置的参数-name-在大部分情况下Mybatis会创建预编译语句，然后Mybatis为它设值，-x3D-x3D-而有时我们需要的是传递sql语句本身，而不是sql所需要的参数，比如动态表格。（包含动态列。）我们需要传递sql的列明-x3D-x3D-，例子如下："><a href="#在Mybatis中，我们经常传递字符串，我们设置的参数-name-在大部分情况下Mybatis会创建预编译语句，然后Mybatis为它设值，-x3D-x3D-而有时我们需要的是传递sql语句本身，而不是sql所需要的参数，比如动态表格。（包含动态列。）我们需要传递sql的列明-x3D-x3D-，例子如下：" class="headerlink" title="在Mybatis中，我们经常传递字符串，我们设置的参数#(name),在大部分情况下Mybatis会创建预编译语句，然后Mybatis为它设值，&#x3D;&#x3D;而有时我们需要的是传递sql语句本身，而不是sql所需要的参数，比如动态表格。（包含动态列。）我们需要传递sql的列明&#x3D;&#x3D;，例子如下："></a>在Mybatis中，我们经常传递字符串，我们设置的参数#(name),在大部分情况下Mybatis会创建预编译语句，然后Mybatis为它设值，&#x3D;&#x3D;而有时我们需要的是传递sql语句本身，而不是sql所需要的参数，比如动态表格。（包含动态列。）我们需要传递sql的列明&#x3D;&#x3D;，例子如下：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003204724818.png" alt="image-20221003204724818"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> $ (columus) <span class="hljs-keyword">from</span> t_tablename;<br></code></pre></td></tr></table></figure><ul><li><h4 id="这样Mybatis-就不会帮我们转译-columus，而变为直出。而不是作为sql的参数进行设置，但是这样存在安全性问题，需要开发者自己去控制正确性和安全性的问题。"><a href="#这样Mybatis-就不会帮我们转译-columus，而变为直出。而不是作为sql的参数进行设置，但是这样存在安全性问题，需要开发者自己去控制正确性和安全性的问题。" class="headerlink" title="这样Mybatis 就不会帮我们转译 columus，而变为直出。而不是作为sql的参数进行设置，但是这样存在安全性问题，需要开发者自己去控制正确性和安全性的问题。"></a>这样Mybatis 就不会帮我们转译 columus，而变为直出。而不是作为sql的参数进行设置，但是这样存在安全性问题，需要开发者自己去控制正确性和安全性的问题。</h4></li></ul><h3 id="4-6-sql-元素"><a href="#4-6-sql-元素" class="headerlink" title="4.6   sql 元素"></a>4.6   sql 元素</h3><ul><li><h4 id="sql元素的意义，在与利用的重复性，避免多次重写，做无用功。"><a href="#sql元素的意义，在与利用的重复性，避免多次重写，做无用功。" class="headerlink" title="sql元素的意义，在与利用的重复性，避免多次重写，做无用功。"></a>sql元素的意义，在与利用的重复性，避免多次重写，做无用功。</h4></li><li><h4 id="sql-元素的使用"><a href="#sql-元素的使用" class="headerlink" title="sql 元素的使用"></a>sql 元素的使用</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003204959687.png" alt="image-20221003204959687"></p><ul><li><h4 id="我们用sql元素定义了role-columns，它可以-x3D-x3D-方便地使用include元素-x3D-x3D-到的refid属性进行引用，从而达到重用的功能。"><a href="#我们用sql元素定义了role-columns，它可以-x3D-x3D-方便地使用include元素-x3D-x3D-到的refid属性进行引用，从而达到重用的功能。" class="headerlink" title="我们用sql元素定义了role_columns，它可以&#x3D;&#x3D;方便地使用include元素&#x3D;&#x3D;到的refid属性进行引用，从而达到重用的功能。"></a>我们用sql元素定义了role_columns，它可以&#x3D;&#x3D;方便地使用include元素&#x3D;&#x3D;到的refid属性进行引用，从而达到重用的功能。</h4></li><li><h4 id="x3D-x3D-真实环境中我们也可以制定参数来使用他们-x3D-x3D-。"><a href="#x3D-x3D-真实环境中我们也可以制定参数来使用他们-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;真实环境中我们也可以制定参数来使用他们&#x3D;&#x3D;。"></a>&#x3D;&#x3D;真实环境中我们也可以制定参数来使用他们&#x3D;&#x3D;。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003205515686.png" alt="image-20221003205515686"></p><ul><li><h4 id="这样就可以给Mybatis加入参数，我们还可以这样给refid一个参数值，由程序指定引入sql："><a href="#这样就可以给Mybatis加入参数，我们还可以这样给refid一个参数值，由程序指定引入sql：" class="headerlink" title="这样就可以给Mybatis加入参数，我们还可以这样给refid一个参数值，由程序指定引入sql："></a>这样就可以给Mybatis加入参数，我们还可以这样给refid一个参数值，由程序指定引入sql：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221003205657341.png" alt="image-20221003205657341"></p><h3 id="4-7-resultMap-结果映射集"><a href="#4-7-resultMap-结果映射集" class="headerlink" title="4.7  resultMap  结果映射集"></a>4.7  resultMap  结果映射集</h3><ul><li><h4 id="resultMap-的作用：-定义映射规则，级联的更新，定制类型转换器等。"><a href="#resultMap-的作用：-定义映射规则，级联的更新，定制类型转换器等。" class="headerlink" title="resultMap  的作用： 定义映射规则，级联的更新，定制类型转换器等。"></a>resultMap  的作用： 定义映射规则，级联的更新，定制类型转换器等。</h4></li></ul><h4 id="4-7-1-resultMap-元素的构成"><a href="#4-7-1-resultMap-元素的构成" class="headerlink" title="4.7.1    resultMap  元素的构成"></a>4.7.1    resultMap  元素的构成</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004152448636.png" alt="image-20221004152448636"></p><ol><li><h4 id="其中，constructor-用于配置构造方法，当POJO不存在没有参数构造方法时，我们就可以用constructor进行配置。"><a href="#其中，constructor-用于配置构造方法，当POJO不存在没有参数构造方法时，我们就可以用constructor进行配置。" class="headerlink" title="其中，constructor 用于配置构造方法，当POJO不存在没有参数构造方法时，我们就可以用constructor进行配置。"></a>其中，constructor 用于配置构造方法，当POJO不存在没有参数构造方法时，我们就可以用constructor进行配置。</h4></li></ol><ul><li><h4 id="假设-RoleBean-不存在没有参数的构造方法：则配置如下："><a href="#假设-RoleBean-不存在没有参数的构造方法：则配置如下：" class="headerlink" title="假设 RoleBean 不存在没有参数的构造方法：则配置如下："></a>假设 RoleBean 不存在没有参数的构造方法：则配置如下：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004152735459.png" alt="image-20221004152735459"></p><ol><li><h4 id="Id元素是表示哪个列是主键，允许多个主键，多个主键则称为联合索引"><a href="#Id元素是表示哪个列是主键，允许多个主键，多个主键则称为联合索引" class="headerlink" title="Id元素是表示哪个列是主键，允许多个主键，多个主键则称为联合索引"></a>Id元素是表示哪个列是主键，允许多个主键，多个主键则称为联合索引</h4></li><li><h4 id="result-是配置-pojo-到sql-列明的映射关系。"><a href="#result-是配置-pojo-到sql-列明的映射关系。" class="headerlink" title="result 是配置 pojo 到sql 列明的映射关系。"></a>result 是配置 pojo 到sql 列明的映射关系。</h4></li></ol><ul><li><h4 id="他们的属性："><a href="#他们的属性：" class="headerlink" title="他们的属性："></a>他们的属性：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004152955496.png" alt="image-20221004152955496"></p><h4 id="4-7-2-使用map-存储结果集"><a href="#4-7-2-使用map-存储结果集" class="headerlink" title="4.7.2  使用map 存储结果集"></a>4.7.2  使用map 存储结果集</h4><ul><li><h4 id="一般来说，任何select语句都能使用map存储。"><a href="#一般来说，任何select语句都能使用map存储。" class="headerlink" title="一般来说，任何select语句都能使用map存储。"></a>一般来说，任何select语句都能使用map存储。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004153712608.png" alt="image-20221004153712608"></p><ul><li><h4 id="map-原则上可以匹配所有结果集，但是使用map接口意味着可读性下降，（并不是很推荐），更多时候我们使用pojo的方式。"><a href="#map-原则上可以匹配所有结果集，但是使用map接口意味着可读性下降，（并不是很推荐），更多时候我们使用pojo的方式。" class="headerlink" title="map 原则上可以匹配所有结果集，但是使用map接口意味着可读性下降，（并不是很推荐），更多时候我们使用pojo的方式。"></a>map 原则上可以匹配所有结果集，但是使用map接口意味着可读性下降，（并不是很推荐），更多时候我们使用pojo的方式。</h4></li></ul><h4 id="4-7-3-使用pojo-存储结果集"><a href="#4-7-3-使用pojo-存储结果集" class="headerlink" title="4.7.3    使用pojo 存储结果集"></a>4.7.3    使用pojo 存储结果集</h4><ul><li><h4 id="pojo是我们最常用的方式，也是推荐的方式，一方面可以使用自动映射，另一方面还可以-x3D-x3D-使用select-语句的属性-resultMap配置映射集合-x3D-x3D-，但使用前需要配置类似的resultMap。如下："><a href="#pojo是我们最常用的方式，也是推荐的方式，一方面可以使用自动映射，另一方面还可以-x3D-x3D-使用select-语句的属性-resultMap配置映射集合-x3D-x3D-，但使用前需要配置类似的resultMap。如下：" class="headerlink" title="pojo是我们最常用的方式，也是推荐的方式，一方面可以使用自动映射，另一方面还可以&#x3D;&#x3D;使用select 语句的属性 resultMap配置映射集合&#x3D;&#x3D;，但使用前需要配置类似的resultMap。如下："></a>pojo是我们最常用的方式，也是推荐的方式，一方面可以使用自动映射，另一方面还可以&#x3D;&#x3D;使用select 语句的属性 resultMap配置映射集合&#x3D;&#x3D;，但使用前需要配置类似的resultMap。如下：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004154017597.png" alt="image-20221004154017597"></p><ol><li><h4 id="x3D-x3D-resultMap元素的属性id-代表这个resultMap的标识，type代表着你需要映射的POJO-x3D-x3D-，我们可以使用-x3D-x3D-Mybatis-定义好的别名-x3D-x3D-，也可以-x3D-x3D-使用自定义类的全限定名-x3D-x3D"><a href="#x3D-x3D-resultMap元素的属性id-代表这个resultMap的标识，type代表着你需要映射的POJO-x3D-x3D-，我们可以使用-x3D-x3D-Mybatis-定义好的别名-x3D-x3D-，也可以-x3D-x3D-使用自定义类的全限定名-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;resultMap元素的属性id 代表这个resultMap的标识，type代表着你需要映射的POJO&#x3D;&#x3D;，我们可以使用&#x3D;&#x3D;Mybatis 定义好的别名&#x3D;&#x3D;，也可以&#x3D;&#x3D;使用自定义类的全限定名&#x3D;&#x3D;"></a>&#x3D;&#x3D;resultMap元素的属性id 代表这个resultMap的标识，type代表着你需要映射的POJO&#x3D;&#x3D;，我们可以使用&#x3D;&#x3D;Mybatis 定义好的别名&#x3D;&#x3D;，也可以&#x3D;&#x3D;使用自定义类的全限定名&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-id元素表示这个对象的主键-x3D-x3D-，-x3D-x3D-property代表着pojo的属性名称，column表示数据库sql-的列名-x3D-x3D-，于是pojo就和数据库sql的结果一一对应起来了。并在映射文件中的select-元素里做代码配置即可使用："><a href="#x3D-x3D-id元素表示这个对象的主键-x3D-x3D-，-x3D-x3D-property代表着pojo的属性名称，column表示数据库sql-的列名-x3D-x3D-，于是pojo就和数据库sql的结果一一对应起来了。并在映射文件中的select-元素里做代码配置即可使用：" class="headerlink" title="&#x3D;&#x3D;id元素表示这个对象的主键&#x3D;&#x3D;，&#x3D;&#x3D;property代表着pojo的属性名称，column表示数据库sql 的列名&#x3D;&#x3D;，于是pojo就和数据库sql的结果一一对应起来了。并在映射文件中的select 元素里做代码配置即可使用："></a>&#x3D;&#x3D;id元素表示这个对象的主键&#x3D;&#x3D;，&#x3D;&#x3D;property代表着pojo的属性名称，column表示数据库sql 的列名&#x3D;&#x3D;，于是pojo就和数据库sql的结果一一对应起来了。并在映射文件中的select 元素里做代码配置即可使用：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004154726897.png" alt="image-20221004154726897"></p><ul><li><h4 id="x3D-x3D-这里的resultMap-中的-“roleResultMap”-就是我们前面配置的。-x3D-x3D"><a href="#x3D-x3D-这里的resultMap-中的-“roleResultMap”-就是我们前面配置的。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;这里的resultMap 中的 “roleResultMap” 就是我们前面配置的。&#x3D;&#x3D;"></a>&#x3D;&#x3D;这里的resultMap 中的 “roleResultMap” 就是我们前面配置的。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004154945071.png" alt="image-20221004154945071"></p><h4 id="4-7-4-级联"><a href="#4-7-4-级联" class="headerlink" title="4.7.4    级联"></a>4.7.4    级联</h4><ul><li><h4 id="数据库中包含着一对多，一对一的关系，比方说一个角色可以分配给多个用户，也可以只分配给一个用户，有时候我们希望用户角色信息和用户信息一起显示出来，这个很常见。-比如："><a href="#数据库中包含着一对多，一对一的关系，比方说一个角色可以分配给多个用户，也可以只分配给一个用户，有时候我们希望用户角色信息和用户信息一起显示出来，这个很常见。-比如：" class="headerlink" title="数据库中包含着一对多，一对一的关系，比方说一个角色可以分配给多个用户，也可以只分配给一个用户，有时候我们希望用户角色信息和用户信息一起显示出来，这个很常见。 比如："></a>数据库中包含着一对多，一对一的关系，比方说一个角色可以分配给多个用户，也可以只分配给一个用户，有时候我们希望用户角色信息和用户信息一起显示出来，这个很常见。 比如：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004155215901.png" alt="image-20221004155215901"></p><ol><li><h4 id="x3D-x3D-这里的查询是把角色和用户的信息都查出来，我们希望的是在角色信息中多一个属性，即List-userList-这样取出来Role的同时也可以访问它下面的用户了，我们把这个叫做级联。-x3D-x3D"><a href="#x3D-x3D-这里的查询是把角色和用户的信息都查出来，我们希望的是在角色信息中多一个属性，即List-userList-这样取出来Role的同时也可以访问它下面的用户了，我们把这个叫做级联。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;这里的查询是把角色和用户的信息都查出来，我们希望的是在角色信息中多一个属性，即List userList ,这样取出来Role的同时也可以访问它下面的用户了，我们把这个叫做级联。&#x3D;&#x3D;"></a>&#x3D;&#x3D;这里的查询是把角色和用户的信息都查出来，我们希望的是在角色信息中多一个属性，即List<UserBean> userList ,这样取出来Role的同时也可以访问它下面的用户了，我们把这个叫做级联。&#x3D;&#x3D;</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004155406218.png" alt="image-20221004155406218"></p><ul><li><h4 id="Mybatis中级联分为3种，association，collection，discriminator-。"><a href="#Mybatis中级联分为3种，association，collection，discriminator-。" class="headerlink" title="Mybatis中级联分为3种，association，collection，discriminator 。"></a>Mybatis中级联分为3种，association，collection，discriminator 。</h4><ul><li><h4 id="assciation-代表一对一关系，比如中国公民和身份证是一对一关系"><a href="#assciation-代表一对一关系，比如中国公民和身份证是一对一关系" class="headerlink" title="assciation  代表一对一关系，比如中国公民和身份证是一对一关系"></a>assciation  代表一对一关系，比如中国公民和身份证是一对一关系</h4><ul><li><h4 id="collection，代表一对多关系，比如班级和学生是一对多关系，一个班级可以有多个学生"><a href="#collection，代表一对多关系，比如班级和学生是一对多关系，一个班级可以有多个学生" class="headerlink" title="collection，代表一对多关系，比如班级和学生是一对多关系，一个班级可以有多个学生"></a>collection，代表一对多关系，比如班级和学生是一对多关系，一个班级可以有多个学生</h4></li><li><h4 id="discriminator，是鉴别器，他可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集，比如：人分男女，你可以实例化一个人的对象，但是要根据情况用男人类或者女人类。"><a href="#discriminator，是鉴别器，他可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集，比如：人分男女，你可以实例化一个人的对象，但是要根据情况用男人类或者女人类。" class="headerlink" title="discriminator，是鉴别器，他可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集，比如：人分男女，你可以实例化一个人的对象，但是要根据情况用男人类或者女人类。"></a>discriminator，是鉴别器，他可以根据实际选择采用哪个类作为实例，允许你根据特定的条件去关联不同的结果集，比如：人分男女，你可以实例化一个人的对象，但是要根据情况用男人类或者女人类。</h4></li></ul></li></ul></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004155737416.png" alt="image-20221004155737416"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160545999.png" alt="image-20221004160545999"></p><h5 id="4-7-4-1-association-一对一级联"><a href="#4-7-4-1-association-一对一级联" class="headerlink" title="4.7.4.1  association 一对一级联"></a>4.7.4.1  association 一对一级联</h5><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160616578.png" alt="image-20221004160616578"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160708392.png" alt="image-20221004160708392"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160702437.png" alt="image-20221004160702437"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160744649.png" alt="image-20221004160744649"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160752072.png" alt="image-20221004160752072"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160757931.png" alt="image-20221004160757931"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160803105.png" alt="image-20221004160803105"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004160808554.png" alt="image-20221004160808554"></p><h3 id="4-8-缓存-cache"><a href="#4-8-缓存-cache" class="headerlink" title="4.8   缓存  cache"></a>4.8   缓存  cache</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004161043518.png" alt="image-20221004161043518"></p><h4 id="4-8-1-系统缓存-一级缓存和二级缓存"><a href="#4-8-1-系统缓存-一级缓存和二级缓存" class="headerlink" title="4.8.1  系统缓存(一级缓存和二级缓存)"></a>4.8.1  系统缓存(一级缓存和二级缓存)</h4><ul><li><h4 id="Mybtis对缓存提供支持，但是在没有配置的默认情况下，他只开启一级缓存（一级缓存知识相对于同一个SqlSession而言）。"><a href="#Mybtis对缓存提供支持，但是在没有配置的默认情况下，他只开启一级缓存（一级缓存知识相对于同一个SqlSession而言）。" class="headerlink" title="Mybtis对缓存提供支持，但是在没有配置的默认情况下，他只开启一级缓存（一级缓存知识相对于同一个SqlSession而言）。"></a>Mybtis对缓存提供支持，但是在没有配置的默认情况下，他只开启一级缓存（一级缓存知识相对于同一个SqlSession而言）。</h4></li></ul><ol><li><h4 id="在-参数和sql-完全一样的情况下，-x3D-x3D-使用个Sqlsession-调用mapper方法执行sql时，往往只执行一次sql，因为使用Sqlsession第一次查询后，Mybatis会将其放入换入缓存里。-x3D-x3D"><a href="#在-参数和sql-完全一样的情况下，-x3D-x3D-使用个Sqlsession-调用mapper方法执行sql时，往往只执行一次sql，因为使用Sqlsession第一次查询后，Mybatis会将其放入换入缓存里。-x3D-x3D" class="headerlink" title="在 参数和sql 完全一样的情况下，&#x3D;&#x3D;使用个Sqlsession  调用mapper方法执行sql时，往往只执行一次sql，因为使用Sqlsession第一次查询后，Mybatis会将其放入换入缓存里。&#x3D;&#x3D;"></a>在 参数和sql 完全一样的情况下，&#x3D;&#x3D;使用个Sqlsession  调用mapper方法执行sql时，往往只执行一次sql，因为使用Sqlsession第一次查询后，Mybatis会将其放入换入缓存里。&#x3D;&#x3D;</h4></li><li><h4 id="之后查询的时候，如果声明没有刷新，并且缓存没有超时的情况，SqlSession-都-只会-取出当前缓存的数据，而不会再次发送Sql到数据库。"><a href="#之后查询的时候，如果声明没有刷新，并且缓存没有超时的情况，SqlSession-都-只会-取出当前缓存的数据，而不会再次发送Sql到数据库。" class="headerlink" title="之后查询的时候，如果声明没有刷新，并且缓存没有超时的情况，SqlSession 都 只会 取出当前缓存的数据，而不会再次发送Sql到数据库。"></a>之后查询的时候，如果声明没有刷新，并且缓存没有超时的情况，SqlSession 都 只会 取出当前缓存的数据，而不会再次发送Sql到数据库。</h4></li></ol><ul><li><h4 id="注意：如果使用的是不同的SqlSesssion-对象，-x3D-x3D-因为不同SqlSession之间是相互隔离的，所以用相同的mapper，参数和方法，他并不会读取缓存，而是再次执行sql到数据库中查询，返回结果。-x3D-x3D"><a href="#注意：如果使用的是不同的SqlSesssion-对象，-x3D-x3D-因为不同SqlSession之间是相互隔离的，所以用相同的mapper，参数和方法，他并不会读取缓存，而是再次执行sql到数据库中查询，返回结果。-x3D-x3D" class="headerlink" title="注意：如果使用的是不同的SqlSesssion 对象，&#x3D;&#x3D;因为不同SqlSession之间是相互隔离的，所以用相同的mapper，参数和方法，他并不会读取缓存，而是再次执行sql到数据库中查询，返回结果。&#x3D;&#x3D;"></a>注意：如果使用的是不同的SqlSesssion 对象，&#x3D;&#x3D;因为不同SqlSession之间是相互隔离的，所以用相同的mapper，参数和方法，他并不会读取缓存，而是再次执行sql到数据库中查询，返回结果。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004161737158.png" alt="image-20221004161737158"></p><ol><li><h4 id="SqlsessionFactory-层面上的二级缓存是不开启的，二级缓存开启需要配置，实现二级缓存的时候，-x3D-x3D-Mybatis要求返回POJO必须是可序列化的-x3D-x3D-，也就是-x3D-x3D-实现Serializble-x3D-x3D-接口，配置很简单，只需要在XML配置文件中就可以开启缓存了。"><a href="#SqlsessionFactory-层面上的二级缓存是不开启的，二级缓存开启需要配置，实现二级缓存的时候，-x3D-x3D-Mybatis要求返回POJO必须是可序列化的-x3D-x3D-，也就是-x3D-x3D-实现Serializble-x3D-x3D-接口，配置很简单，只需要在XML配置文件中就可以开启缓存了。" class="headerlink" title="SqlsessionFactory 层面上的二级缓存是不开启的，二级缓存开启需要配置，实现二级缓存的时候，&#x3D;&#x3D;Mybatis要求返回POJO必须是可序列化的&#x3D;&#x3D;，也就是 &#x3D;&#x3D;实现Serializble&#x3D;&#x3D;接口，配置很简单，只需要在XML配置文件中就可以开启缓存了。"></a>SqlsessionFactory 层面上的二级缓存是不开启的，二级缓存开启需要配置，实现二级缓存的时候，&#x3D;&#x3D;Mybatis要求返回POJO必须是可序列化的&#x3D;&#x3D;，也就是 &#x3D;&#x3D;实现Serializble&#x3D;&#x3D;接口，配置很简单，只需要在XML配置文件中就可以开启缓存了。</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;cache/&gt;<br></code></pre></td></tr></table></figure><ul><li><h4 id="开启缓存，意味着："><a href="#开启缓存，意味着：" class="headerlink" title="开启缓存，意味着："></a>开启缓存，意味着：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004162807377.png" alt="image-20221004162807377"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004163138988.png" alt="image-20221004163138988"></p><ul><li><h4 id="二级缓存是在SqlSessionFactory层面所共享的。"><a href="#二级缓存是在SqlSessionFactory层面所共享的。" class="headerlink" title="二级缓存是在SqlSessionFactory层面所共享的。"></a>二级缓存是在SqlSessionFactory层面所共享的。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004163206394.png" alt="image-20221004163206394"></p><ul><li><h4 id="属性解析："><a href="#属性解析：" class="headerlink" title="属性解析："></a>属性解析：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004163243714.png" alt="image-20221004163243714"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004165754860.png" alt="image-20221004165754860"></p><h4 id="4-8-2-自定义缓存"><a href="#4-8-2-自定义缓存" class="headerlink" title="4.8.2  自定义缓存"></a>4.8.2  自定义缓存</h4><ul><li><h4 id="系统缓存是Mybatis应用机器上的本地缓存，但是在大型服务器上，会使用各类不同的缓存服务器，这个时候我们可以-x3D-x3D-定制缓存-x3D-x3D-，比如十分流行的Redis缓存，我们需要实现Mybatis-为我们提供的"><a href="#系统缓存是Mybatis应用机器上的本地缓存，但是在大型服务器上，会使用各类不同的缓存服务器，这个时候我们可以-x3D-x3D-定制缓存-x3D-x3D-，比如十分流行的Redis缓存，我们需要实现Mybatis-为我们提供的" class="headerlink" title="系统缓存是Mybatis应用机器上的本地缓存，但是在大型服务器上，会使用各类不同的缓存服务器，这个时候我们可以&#x3D;&#x3D;定制缓存&#x3D;&#x3D;，比如十分流行的Redis缓存，我们需要实现Mybatis 为我们提供的"></a>系统缓存是Mybatis应用机器上的本地缓存，但是在大型服务器上，会使用各类不同的缓存服务器，这个时候我们可以&#x3D;&#x3D;定制缓存&#x3D;&#x3D;，比如十分流行的Redis缓存，我们需要实现Mybatis 为我们提供的<img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004165947213.png" alt="image-20221004165947213"></h4></li><li><h4 id="接口详情："><a href="#接口详情：" class="headerlink" title="接口详情："></a>接口详情：</h4></li><li><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004170004692.png" alt="image-20221004170004692"></h4></li><li><h4 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004170048368.png" alt="image-20221004170048368"></h4></li><li><h4 id="配置自定义缓存类，并在-mapper-xml-文件中-配置。"><a href="#配置自定义缓存类，并在-mapper-xml-文件中-配置。" class="headerlink" title="配置自定义缓存类，并在 mapper.xml 文件中 配置。"></a>配置自定义缓存类，并在 mapper.xml 文件中 配置。</h4></li><li><h4 id="可以设置一些自定义缓存参数。"><a href="#可以设置一些自定义缓存参数。" class="headerlink" title="可以设置一些自定义缓存参数。"></a>可以设置一些自定义缓存参数。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004170125528.png" alt="image-20221004170125528"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004170215320.png" alt="image-20221004170215320"></p><ul><li><h4 id="通过在各种元素上配置-userCache-和-flushCache-来决定使用缓存和-是否刷新缓存。"><a href="#通过在各种元素上配置-userCache-和-flushCache-来决定使用缓存和-是否刷新缓存。" class="headerlink" title="通过在各种元素上配置 userCache  和 flushCache  来决定使用缓存和 是否刷新缓存。"></a>通过在各种元素上配置 userCache  和 flushCache  来决定使用缓存和 是否刷新缓存。</h4></li><li><h4 id="如："><a href="#如：" class="headerlink" title="如："></a>如：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;select flushCacahe =&quot;false&quot;  useCache = &quot;true&quot;/&gt; <br></code></pre></td></tr></table></figure><ul><li><h4 id="就算开启缓存。"><a href="#就算开启缓存。" class="headerlink" title="就算开启缓存。"></a>就算开启缓存。</h4></li></ul></li></ul><h2 id="第5章-动态-SQL"><a href="#第5章-动态-SQL" class="headerlink" title="第5章  动态 SQL"></a>第5章  动态 SQL</h2><ul><li><h4 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004173041539.png" alt="image-20221004173041539"></p><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1  概述"></a>5.1  概述</h3><ul><li><h4 id="Mybatis-的动态sql-包括-以下几种元素-kissing-smiling-eyes"><a href="#Mybatis-的动态sql-包括-以下几种元素-kissing-smiling-eyes" class="headerlink" title="Mybatis 的动态sql  包括 以下几种元素:kissing_smiling_eyes:"></a>Mybatis 的动态sql  包括 以下几种元素:kissing_smiling_eyes:</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004173424984.png" alt="image-20221004173424984"></p><h3 id="5-2-if-元素"><a href="#5-2-if-元素" class="headerlink" title="5.2  if 元素"></a>5.2  if 元素</h3><ul><li><h4 id="if-元素-即-判断语句-，相当于java中的if-。它常常与-test-联合使用。"><a href="#if-元素-即-判断语句-，相当于java中的if-。它常常与-test-联合使用。" class="headerlink" title="if 元素 即 判断语句 ，相当于java中的if  。它常常与 test 联合使用。"></a>if 元素 即 判断语句 ，相当于java中的if  。它常常与 test 联合使用。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004173828397.png" alt="image-20221004173828397"></p><ul><li><h4 id="这句话的含义：-x3D-x3D-当我们将参数roleName传递到映射器时，采取构造器对roleName-的模糊查询，如果这个参数为空，就不要去构造这个条件-x3D-x3D-，通过Mybatis条件语句我们可以节省很多拼接的工作。"><a href="#这句话的含义：-x3D-x3D-当我们将参数roleName传递到映射器时，采取构造器对roleName-的模糊查询，如果这个参数为空，就不要去构造这个条件-x3D-x3D-，通过Mybatis条件语句我们可以节省很多拼接的工作。" class="headerlink" title="这句话的含义：&#x3D;&#x3D;当我们将参数roleName传递到映射器时，采取构造器对roleName 的模糊查询，如果这个参数为空，就不要去构造这个条件&#x3D;&#x3D;，通过Mybatis条件语句我们可以节省很多拼接的工作。"></a>这句话的含义：&#x3D;&#x3D;当我们将参数roleName传递到映射器时，采取构造器对roleName 的模糊查询，如果这个参数为空，就不要去构造这个条件&#x3D;&#x3D;，通过Mybatis条件语句我们可以节省很多拼接的工作。</h4></li></ul><h3 id="5-3-choose，-when-，-otherwise-元素"><a href="#5-3-choose，-when-，-otherwise-元素" class="headerlink" title="5.3  choose， when ， otherwise  元素"></a>5.3  choose， when ， otherwise  元素</h3><ul><li><h4 id="当需要更多的选择条件时，if-元素就会有点力不从心，这时候我们就需要switch-case-这样的语句，而-choose，when，-otherwise-就是这样的元素。"><a href="#当需要更多的选择条件时，if-元素就会有点力不从心，这时候我们就需要switch-case-这样的语句，而-choose，when，-otherwise-就是这样的元素。" class="headerlink" title="当需要更多的选择条件时，if 元素就会有点力不从心，这时候我们就需要switch case 这样的语句，而 choose，when， otherwise 就是这样的元素。"></a>当需要更多的选择条件时，if 元素就会有点力不从心，这时候我们就需要switch case 这样的语句，而 choose，when， otherwise 就是这样的元素。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004174315355.png" alt="image-20221004174315355"></p><ul><li><h4 id="实例场景："><a href="#实例场景：" class="headerlink" title="实例场景："></a>实例场景：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004174326707.png" alt="image-20221004174326707"></p><h3 id="5-4-trim-，-where-，-set-元素"><a href="#5-4-trim-，-where-，-set-元素" class="headerlink" title="5.4  trim ， where ， set 元素"></a>5.4  trim ， where ， set 元素</h3><ul><li><h4 id="5-3-节的sql-语句-加入了-1-x3D-1-，如果没加入-那么sql-可能就会变成下面这样一条语句："><a href="#5-3-节的sql-语句-加入了-1-x3D-1-，如果没加入-那么sql-可能就会变成下面这样一条语句：" class="headerlink" title="5.3 节的sql 语句 加入了 1&#x3D;1 ，如果没加入 那么sql 可能就会变成下面这样一条语句："></a>5.3 节的sql 语句 加入了 1&#x3D;1 ，如果没加入 那么sql 可能就会变成下面这样一条语句：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004193601247.png" alt="image-20221004193601247"></p><ul><li><h4 id="显然会报语法错误。"><a href="#显然会报语法错误。" class="headerlink" title="显然会报语法错误。"></a>显然会报语法错误。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004193806153.png" alt="image-20221004193806153"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004193813890.png" alt="image-20221004193813890"></p><ul><li><h4 id="当where-元素里面的条件成立时，才会加入where-这个-sql关键字到组装sql-里面，否则不加入"><a href="#当where-元素里面的条件成立时，才会加入where-这个-sql关键字到组装sql-里面，否则不加入" class="headerlink" title="当where 元素里面的条件成立时，才会加入where 这个 sql关键字到组装sql 里面，否则不加入"></a>当where 元素里面的条件成立时，才会加入where 这个 sql关键字到组装sql 里面，否则不加入</h4></li><li><h4 id="有时我们需要去掉一些特殊的sql语句，比如常见的and，or，而是用trim元素可以达到我们预期的结果。"><a href="#有时我们需要去掉一些特殊的sql语句，比如常见的and，or，而是用trim元素可以达到我们预期的结果。" class="headerlink" title="有时我们需要去掉一些特殊的sql语句，比如常见的and，or，而是用trim元素可以达到我们预期的结果。"></a>有时我们需要去掉一些特殊的sql语句，比如常见的and，or，而是用trim元素可以达到我们预期的结果。</h4></li><li></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004194412141.png" alt="image-20221004194412141"></p><ul><li><h4 id="prefix-代表语句的前缀。而-prefixOverrides-代表的是你需要去掉的那种字符串，上面的写法基本与where-是等效的。"><a href="#prefix-代表语句的前缀。而-prefixOverrides-代表的是你需要去掉的那种字符串，上面的写法基本与where-是等效的。" class="headerlink" title="prefix 代表语句的前缀。而 prefixOverrides 代表的是你需要去掉的那种字符串，上面的写法基本与where 是等效的。"></a>prefix 代表语句的前缀。而 prefixOverrides 代表的是你需要去掉的那种字符串，上面的写法基本与where 是等效的。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004194712330.png" alt="image-20221004194712330"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004194745219.png" alt="image-20221004194745219"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004194751675.png" alt="image-20221004194751675"></p><ul><li><h4 id="当然也可以使用trim"><a href="#当然也可以使用trim" class="headerlink" title="当然也可以使用trim"></a>当然也可以使用trim</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004194858571.png" alt="image-20221004194858571"></p><h3 id="5-5-foreach-元素"><a href="#5-5-foreach-元素" class="headerlink" title="5.5  foreach  元素"></a>5.5  foreach  元素</h3><ul><li><h4 id="显然foreach-元素是一个循环语句，它的作用是遍历集合，它能够很好的支持数组和List，Set-接口，对此提供遍历的功能。"><a href="#显然foreach-元素是一个循环语句，它的作用是遍历集合，它能够很好的支持数组和List，Set-接口，对此提供遍历的功能。" class="headerlink" title="显然foreach  元素是一个循环语句，它的作用是遍历集合，它能够很好的支持数组和List，Set 接口，对此提供遍历的功能。"></a>显然foreach  元素是一个循环语句，它的作用是遍历集合，它能够很好的支持数组和List，Set 接口，对此提供遍历的功能。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004201404940.png" alt="image-20221004201404940"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004201411310.png" alt="image-20221004201411310"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004201416752.png" alt="image-20221004201416752"></p><ol><li><h4 id="x3D-x3D-collection-x3D-x3D-配置的sexList-是传递-进来的参数名称，-x3D-x3D-它可以是一个数组或者List，set-等集合-x3D-x3D"><a href="#x3D-x3D-collection-x3D-x3D-配置的sexList-是传递-进来的参数名称，-x3D-x3D-它可以是一个数组或者List，set-等集合-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;collection&#x3D;&#x3D;配置的sexList 是传递 进来的参数名称，&#x3D;&#x3D;它可以是一个数组或者List，set 等集合&#x3D;&#x3D;"></a>&#x3D;&#x3D;collection&#x3D;&#x3D;配置的sexList 是传递 进来的参数名称，&#x3D;&#x3D;它可以是一个数组或者List，set 等集合&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-item配置ide是循环中当前的元素-x3D-x3D"><a href="#x3D-x3D-item配置ide是循环中当前的元素-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;item配置ide是循环中当前的元素&#x3D;&#x3D;"></a>&#x3D;&#x3D;item配置ide是循环中当前的元素&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-index配置的是当前元素在集合的位置下标-x3D-x3D"><a href="#x3D-x3D-index配置的是当前元素在集合的位置下标-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;index配置的是当前元素在集合的位置下标&#x3D;&#x3D;"></a>&#x3D;&#x3D;index配置的是当前元素在集合的位置下标&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-open和close配置的是以什么符号将这些集合元素包装起来-x3D-x3D"><a href="#x3D-x3D-open和close配置的是以什么符号将这些集合元素包装起来-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;open和close配置的是以什么符号将这些集合元素包装起来&#x3D;&#x3D;"></a>&#x3D;&#x3D;open和close配置的是以什么符号将这些集合元素包装起来&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-separator是各个元素的间隔符。-x3D-x3D"><a href="#x3D-x3D-separator是各个元素的间隔符。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;separator是各个元素的间隔符。&#x3D;&#x3D;"></a>&#x3D;&#x3D;separator是各个元素的间隔符。&#x3D;&#x3D;</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004203247196.png" alt="image-20221004203247196"></p><h3 id="5-6-test-属性"><a href="#5-6-test-属性" class="headerlink" title="5.6  test 属性"></a>5.6  test 属性</h3><ul><li><h4 id="test-的属性用于条件判断的语句中，它在Mybatis中广泛使用，它的作用相当于判断真假。在大部分的场景中我们都用它判断空和没空，有时候我们需要判断字符串，枚举等，所以有必要深入了解。"><a href="#test-的属性用于条件判断的语句中，它在Mybatis中广泛使用，它的作用相当于判断真假。在大部分的场景中我们都用它判断空和没空，有时候我们需要判断字符串，枚举等，所以有必要深入了解。" class="headerlink" title="test 的属性用于条件判断的语句中，它在Mybatis中广泛使用，它的作用相当于判断真假。在大部分的场景中我们都用它判断空和没空，有时候我们需要判断字符串，枚举等，所以有必要深入了解。"></a>test 的属性用于条件判断的语句中，它在Mybatis中广泛使用，它的作用相当于判断真假。在大部分的场景中我们都用它判断空和没空，有时候我们需要判断字符串，枚举等，所以有必要深入了解。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004204518678.png" alt="image-20221004204518678"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004204526538.png" alt="image-20221004204526538"></p><h3 id="5-7-bind-元素"><a href="#5-7-bind-元素" class="headerlink" title="5.7  bind 元素"></a>5.7  bind 元素</h3><ul><li><h4 id="bind-元素的作用是通过OGNL表达式去定义一个上下文变量，这样更方便我们使用，在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到-concat-和-和参数相连接，然而在其他数据库中用的不同，-x3D-x3D-所有有了bind元素，我们只需要使用mybatis的语法即可把需要的参数连接。-x3D-x3D"><a href="#bind-元素的作用是通过OGNL表达式去定义一个上下文变量，这样更方便我们使用，在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到-concat-和-和参数相连接，然而在其他数据库中用的不同，-x3D-x3D-所有有了bind元素，我们只需要使用mybatis的语法即可把需要的参数连接。-x3D-x3D" class="headerlink" title="bind 元素的作用是通过OGNL表达式去定义一个上下文变量，这样更方便我们使用，在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到 concat 和 % 和参数相连接，然而在其他数据库中用的不同，&#x3D;&#x3D;所有有了bind元素，我们只需要使用mybatis的语法即可把需要的参数连接。&#x3D;&#x3D;"></a>bind 元素的作用是通过OGNL表达式去定义一个上下文变量，这样更方便我们使用，在我们进行模糊查询的时候，如果是MySQL数据库，我们常常用到 concat 和 % 和参数相连接，然而在其他数据库中用的不同，&#x3D;&#x3D;所有有了bind元素，我们只需要使用mybatis的语法即可把需要的参数连接。&#x3D;&#x3D;</h4></li><li><h4 id="比如："><a href="#比如：" class="headerlink" title="比如："></a>比如：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004205353031.png" alt="image-20221004205353031"></p><ul><li><h4 id="这里的-parameter-代表的是传递进来的参数，它和通配符连接后，赋值给了pattern，我们就可以在select-语句中使用这个变量了进行模糊查询了，所有数据库都可以使用这样的语句。-提高了其可移植性"><a href="#这里的-parameter-代表的是传递进来的参数，它和通配符连接后，赋值给了pattern，我们就可以在select-语句中使用这个变量了进行模糊查询了，所有数据库都可以使用这样的语句。-提高了其可移植性" class="headerlink" title="这里的_parameter  代表的是传递进来的参数，它和通配符连接后，赋值给了pattern，我们就可以在select 语句中使用这个变量了进行模糊查询了，所有数据库都可以使用这样的语句。 提高了其可移植性"></a>这里的_parameter  代表的是传递进来的参数，它和通配符连接后，赋值给了pattern，我们就可以在select 语句中使用这个变量了进行模糊查询了，所有数据库都可以使用这样的语句。 提高了其可移植性</h4></li><li><h4 id="我们传递的参数可能不止一个，我们可以传递多个参数：。"><a href="#我们传递的参数可能不止一个，我们可以传递多个参数：。" class="headerlink" title="我们传递的参数可能不止一个，我们可以传递多个参数：。"></a>我们传递的参数可能不止一个，我们可以传递多个参数：。</h4></li><li><h4 id="先定义接口方法："><a href="#先定义接口方法：" class="headerlink" title="先定义接口方法："></a>先定义接口方法：</h4><ul><li><h4 id="传递多个参数。"><a href="#传递多个参数。" class="headerlink" title="传递多个参数。"></a>传递多个参数。</h4></li></ul></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004210319434.png" alt="image-20221004210319434"></p><ul><li><h4 id="然后，定义映射文件，定义两个新的变量去执行模糊查询。"><a href="#然后，定义映射文件，定义两个新的变量去执行模糊查询。" class="headerlink" title="然后，定义映射文件，定义两个新的变量去执行模糊查询。"></a>然后，定义映射文件，定义两个新的变量去执行模糊查询。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221004210631461.png" alt="image-20221004210631461"></p><h2 id="第6章-Mybatis-的解析和运行原理"><a href="#第6章-Mybatis-的解析和运行原理" class="headerlink" title="第6章  Mybatis 的解析和运行原理"></a>第6章  Mybatis 的解析和运行原理</h2><h3 id="6-1-涉及的技术难点简介"><a href="#6-1-涉及的技术难点简介" class="headerlink" title="6.1   涉及的技术难点简介"></a>6.1   涉及的技术难点简介</h3><ul><li><h4 id="Mapper-仅仅是一个接口，而不是一个包含逻辑的实现类，我们知道接口是不能执行的，那么它是怎么运行的呢？"><a href="#Mapper-仅仅是一个接口，而不是一个包含逻辑的实现类，我们知道接口是不能执行的，那么它是怎么运行的呢？" class="headerlink" title="Mapper 仅仅是一个接口，而不是一个包含逻辑的实现类，我们知道接口是不能执行的，那么它是怎么运行的呢？"></a>Mapper 仅仅是一个接口，而不是一个包含逻辑的实现类，我们知道接口是不能执行的，那么它是怎么运行的呢？</h4><ul><li><h4 id="答案是使用了动态代理。"><a href="#答案是使用了动态代理。" class="headerlink" title="答案是使用了动态代理。"></a>答案是使用了动态代理。</h4></li></ul></li><li><h4 id="显然Mapper产生了代理类，这个代理类是Mybatis为我们创建的，为此我们先来学习动态代理。"><a href="#显然Mapper产生了代理类，这个代理类是Mybatis为我们创建的，为此我们先来学习动态代理。" class="headerlink" title="显然Mapper产生了代理类，这个代理类是Mybatis为我们创建的，为此我们先来学习动态代理。"></a>显然Mapper产生了代理类，这个代理类是Mybatis为我们创建的，为此我们先来学习动态代理。</h4></li><li><h4 id="什么是动态代理？"><a href="#什么是动态代理？" class="headerlink" title="什么是动态代理？"></a>什么是动态代理？</h4></li><li><h4 id="本质上就是一个服务的中介。如一个公司的客服，我会认为客服就代表着对方的公司，而不管真正为我服务的’‘你‘’是怎么样的。"><a href="#本质上就是一个服务的中介。如一个公司的客服，我会认为客服就代表着对方的公司，而不管真正为我服务的’‘你‘’是怎么样的。" class="headerlink" title="本质上就是一个服务的中介。如一个公司的客服，我会认为客服就代表着对方的公司，而不管真正为我服务的’‘你‘’是怎么样的。"></a>本质上就是一个服务的中介。如一个公司的客服，我会认为客服就代表着对方的公司，而不管真正为我服务的’‘你‘’是怎么样的。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005210032596.png" alt="image-20221005210032596"></p><ul><li><h4 id="其次，为什么要使用代理模式？"><a href="#其次，为什么要使用代理模式？" class="headerlink" title="其次，为什么要使用代理模式？"></a>其次，为什么要使用代理模式？</h4></li></ul><ol><li><h4 id="通过代理，-x3D-x3D-一方面可以控制如何访问真正的服务对象，提供额外服务，另一方面有机会通过重写一些类来满足特定的需要-x3D-x3D-，正如客服也可以根据公司的业务规则，提供一些服务，这时候就不要我们花费更多的心思了。"><a href="#通过代理，-x3D-x3D-一方面可以控制如何访问真正的服务对象，提供额外服务，另一方面有机会通过重写一些类来满足特定的需要-x3D-x3D-，正如客服也可以根据公司的业务规则，提供一些服务，这时候就不要我们花费更多的心思了。" class="headerlink" title="通过代理，&#x3D;&#x3D;一方面可以控制如何访问真正的服务对象，提供额外服务，另一方面有机会通过重写一些类来满足特定的需要&#x3D;&#x3D;，正如客服也可以根据公司的业务规则，提供一些服务，这时候就不要我们花费更多的心思了。"></a>通过代理，&#x3D;&#x3D;一方面可以控制如何访问真正的服务对象，提供额外服务，另一方面有机会通过重写一些类来满足特定的需要&#x3D;&#x3D;，正如客服也可以根据公司的业务规则，提供一些服务，这时候就不要我们花费更多的心思了。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005210513351.png" alt="image-20221005210513351"></p><ol><li><h4 id="一般而言，动态代理分为两种："><a href="#一般而言，动态代理分为两种：" class="headerlink" title="一般而言，动态代理分为两种："></a>一般而言，动态代理分为两种：</h4><ol><li><h4 id="一是JDK反射机制提供的代理"><a href="#一是JDK反射机制提供的代理" class="headerlink" title="一是JDK反射机制提供的代理"></a>一是JDK反射机制提供的代理</h4></li><li><h4 id="另一种是CGLIB代理。"><a href="#另一种是CGLIB代理。" class="headerlink" title="另一种是CGLIB代理。"></a>另一种是CGLIB代理。</h4></li></ol></li></ol><ul><li><h4 id="x3D-x3D-在JDK提供的代理，我们必须要提供接口-x3D-x3D-，而-x3D-x3D-CGLIB则不需要提供接口-x3D-x3D-，在Mybatis里面-x3D-x3D-两种动态代理技术都已经使用-x3D-x3D-了，在此之前，我们需要熟悉反射技术。"><a href="#x3D-x3D-在JDK提供的代理，我们必须要提供接口-x3D-x3D-，而-x3D-x3D-CGLIB则不需要提供接口-x3D-x3D-，在Mybatis里面-x3D-x3D-两种动态代理技术都已经使用-x3D-x3D-了，在此之前，我们需要熟悉反射技术。" class="headerlink" title="&#x3D;&#x3D;在JDK提供的代理，我们必须要提供接口&#x3D;&#x3D;，而&#x3D;&#x3D;CGLIB则不需要提供接口&#x3D;&#x3D;，在Mybatis里面&#x3D;&#x3D;两种动态代理技术都已经使用&#x3D;&#x3D;了，在此之前，我们需要熟悉反射技术。"></a>&#x3D;&#x3D;在JDK提供的代理，我们必须要提供接口&#x3D;&#x3D;，而&#x3D;&#x3D;CGLIB则不需要提供接口&#x3D;&#x3D;，在Mybatis里面&#x3D;&#x3D;两种动态代理技术都已经使用&#x3D;&#x3D;了，在此之前，我们需要熟悉反射技术。</h4></li></ul><h4 id="6-1-1-反射技术"><a href="#6-1-1-反射技术" class="headerlink" title="6.1.1  反射技术"></a>6.1.1  反射技术</h4><ul><li><h4 id="反射技术已经很成熟了，如下例子："><a href="#反射技术已经很成熟了，如下例子：" class="headerlink" title="反射技术已经很成熟了，如下例子："></a>反射技术已经很成熟了，如下例子：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005211138122.png" alt="image-20221005211138122"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005211145019.png" alt="image-20221005211145019"></p><ul><li><h4 id="这段代码通过反射技术去创建ReflectService对象，获取方法后通过放射调用"><a href="#这段代码通过反射技术去创建ReflectService对象，获取方法后通过放射调用" class="headerlink" title="这段代码通过反射技术去创建ReflectService对象，获取方法后通过放射调用"></a>这段代码通过反射技术去创建ReflectService对象，获取方法后通过放射调用</h4></li><li><h4 id="反射调用的最大好处：-x3D-x3D-配置性大大提高，就如同Spring-IOC容器一样，我们可以给很多配置设置参数-x3D-x3D-，使得JAVA应用程序能够顺利运行起来，-x3D-x3D-大大提高了java的灵活性和可配置性，降低了模块间的某和性-x3D-x3D-。"><a href="#反射调用的最大好处：-x3D-x3D-配置性大大提高，就如同Spring-IOC容器一样，我们可以给很多配置设置参数-x3D-x3D-，使得JAVA应用程序能够顺利运行起来，-x3D-x3D-大大提高了java的灵活性和可配置性，降低了模块间的某和性-x3D-x3D-。" class="headerlink" title="反射调用的最大好处：&#x3D;&#x3D;配置性大大提高，就如同Spring IOC容器一样，我们可以给很多配置设置参数&#x3D;&#x3D;，使得JAVA应用程序能够顺利运行起来，&#x3D;&#x3D;大大提高了java的灵活性和可配置性，降低了模块间的某和性&#x3D;&#x3D;。"></a>反射调用的最大好处：&#x3D;&#x3D;配置性大大提高，就如同Spring IOC容器一样，我们可以给很多配置设置参数&#x3D;&#x3D;，使得JAVA应用程序能够顺利运行起来，&#x3D;&#x3D;大大提高了java的灵活性和可配置性，降低了模块间的某和性&#x3D;&#x3D;。</h4></li></ul><h4 id="6-1-2-JDK-动态代理"><a href="#6-1-2-JDK-动态代理" class="headerlink" title="6.1.2  JDK 动态代理"></a>6.1.2  JDK 动态代理</h4><ul><li><h4 id="JDK的动态代理，由-java-lang-reflect-包提供，实现它需要完成几个步骤："><a href="#JDK的动态代理，由-java-lang-reflect-包提供，实现它需要完成几个步骤：" class="headerlink" title="JDK的动态代理，由 java.lang.reflect.*包提供，实现它需要完成几个步骤："></a>JDK的动态代理，由 java.lang.reflect.*包提供，实现它需要完成几个步骤：</h4><ul><li><h4 id="编写服务类和接口，这个是真正的服务提供者，-x3D-x3D-在JDK代理中接口是必须的-x3D-x3D"><a href="#编写服务类和接口，这个是真正的服务提供者，-x3D-x3D-在JDK代理中接口是必须的-x3D-x3D" class="headerlink" title="编写服务类和接口，这个是真正的服务提供者，&#x3D;&#x3D;在JDK代理中接口是必须的&#x3D;&#x3D;"></a>编写服务类和接口，这个是真正的服务提供者，&#x3D;&#x3D;在JDK代理中接口是必须的&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-编写代理类，提供绑定和代理方法-x3D-x3D-。"><a href="#x3D-x3D-编写代理类，提供绑定和代理方法-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;编写代理类，提供绑定和代理方法&#x3D;&#x3D;。"></a>&#x3D;&#x3D;编写代理类，提供绑定和代理方法&#x3D;&#x3D;。</h4></li></ul></li><li><h4 id="JDK代理的最大的缺点就是需要提供接口，-x3D-x3D-Mybatis的mapper就是一个接口-它采用的是JDK的动态代理。-x3D-x3D"><a href="#JDK代理的最大的缺点就是需要提供接口，-x3D-x3D-Mybatis的mapper就是一个接口-它采用的是JDK的动态代理。-x3D-x3D" class="headerlink" title="JDK代理的最大的缺点就是需要提供接口，&#x3D;&#x3D;Mybatis的mapper就是一个接口,它采用的是JDK的动态代理。&#x3D;&#x3D;"></a>JDK代理的最大的缺点就是需要提供接口，&#x3D;&#x3D;Mybatis的mapper就是一个接口,它采用的是JDK的动态代理。&#x3D;&#x3D;</h4></li></ul><ol><li><h4 id="我们先给出一个服务接口。"><a href="#我们先给出一个服务接口。" class="headerlink" title="我们先给出一个服务接口。"></a>我们先给出一个服务接口。</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ovesh.service;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Ovesh</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/10/5 21:27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HelloService</span> &#123;<br><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="实现类。"><a href="#实现类。" class="headerlink" title="实现类。"></a>实现类。</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">package com.ovesh.impl;<br><br>import com.ovesh.service.HelloService;<br><br>/**<br> * @description:TODO<br> * @Author: Ovesh<br> * @Date: 2022/10/5 21:29<br> * @Version 1.0<br> */<br>public class HelloServiceImpl implements HelloService &#123;<br>    @Override<br>    public void sayHello(String name) &#123;<br>        System.out.println(&quot;hello&quot; + name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="代理类："><a href="#代理类：" class="headerlink" title="代理类："></a>代理类：</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ovesh.proxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:TODO 代理类，提供真实对象的绑定和代理方法。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Ovesh</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/10/5 21:31</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定委托对象并返回一个代理类。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">bind</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),<br>                target.getClass().getInterfaces()<br>                , <span class="hljs-built_in">this</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过代理对象调用方法首先进入这个方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proxy  代理对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method 被调用方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args   方法的参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;-----我是JDK 动态代理--------&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//todo  方法调用前</span><br>        System.err.println(<span class="hljs-string">&quot;我准备说  hello  &quot;</span>);<br>        <span class="hljs-comment">//todo  执行方法，相当于调用 helloServiceImpl 类的sayHello方法</span><br>        result = method.invoke(target, args);<br>        <span class="hljs-comment">//todo  反射方法调用后</span><br>        System.err.println(<span class="hljs-string">&quot;我说过hello 了&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h4 id="上面的代码让JDK产生一个代理对象，这个代理对象有三个参数："><a href="#上面的代码让JDK产生一个代理对象，这个代理对象有三个参数：" class="headerlink" title="上面的代码让JDK产生一个代理对象，这个代理对象有三个参数："></a>上面的代码让JDK产生一个代理对象，这个代理对象有三个参数：</h4><ol><li><h4 id="第一个：target-getClass-getClassLoader-是类加载器"><a href="#第一个：target-getClass-getClassLoader-是类加载器" class="headerlink" title="第一个：target.getClass().getClassLoader() 是类加载器"></a>第一个：target.getClass().getClassLoader() 是类加载器</h4></li><li><h4 id="第二个，target-getClass-getInterfaces-是接口-代理对象挂在哪个接口下"><a href="#第二个，target-getClass-getInterfaces-是接口-代理对象挂在哪个接口下" class="headerlink" title="第二个，target.getClass().getInterfaces()是接口(代理对象挂在哪个接口下)"></a>第二个，target.getClass().getInterfaces()是接口(代理对象挂在哪个接口下)</h4></li><li><h4 id="第三个参数this-代表当前HelloServiceProxy类，换句话说就是使用HelloServiceProxy的代理方法作为对象的代理执行者。"><a href="#第三个参数this-代表当前HelloServiceProxy类，换句话说就是使用HelloServiceProxy的代理方法作为对象的代理执行者。" class="headerlink" title="第三个参数this 代表当前HelloServiceProxy类，换句话说就是使用HelloServiceProxy的代理方法作为对象的代理执行者。"></a>第三个参数this 代表当前HelloServiceProxy类，换句话说就是使用HelloServiceProxy的代理方法作为对象的代理执行者。</h4></li></ol></li></ol><ul><li><h4 id="一旦绑定后，在进入代理对象方法调用的时候，就会到HelloServiceProxy的代理方法上，代理方法有三个参数："><a href="#一旦绑定后，在进入代理对象方法调用的时候，就会到HelloServiceProxy的代理方法上，代理方法有三个参数：" class="headerlink" title="一旦绑定后，在进入代理对象方法调用的时候，就会到HelloServiceProxy的代理方法上，代理方法有三个参数："></a>一旦绑定后，在进入代理对象方法调用的时候，就会到HelloServiceProxy的代理方法上，代理方法有三个参数：</h4><ul><li><h4 id="第一个proxy是代理对象"><a href="#第一个proxy是代理对象" class="headerlink" title="第一个proxy是代理对象"></a>第一个proxy是代理对象</h4></li><li><h4 id="第二个是当前调用的那个方法"><a href="#第二个是当前调用的那个方法" class="headerlink" title="第二个是当前调用的那个方法"></a>第二个是当前调用的那个方法</h4></li><li><h4 id="第三个是方法的参数。"><a href="#第三个是方法的参数。" class="headerlink" title="第三个是方法的参数。"></a>第三个是方法的参数。</h4></li></ul></li><li><h4 id="x3D-x3D-比如-现在-HelloServiceImpl-对象（obj）用bind方法绑定后，返回其占位，我们再调用proxy-sayHello-“张三”-那么它就会进入到HelloServiceProxy的invoke-方法-x3D-x3D-，而invoke参数中，第一个便是代理对象proxy，方法便是sayHello，参数是-张三。"><a href="#x3D-x3D-比如-现在-HelloServiceImpl-对象（obj）用bind方法绑定后，返回其占位，我们再调用proxy-sayHello-“张三”-那么它就会进入到HelloServiceProxy的invoke-方法-x3D-x3D-，而invoke参数中，第一个便是代理对象proxy，方法便是sayHello，参数是-张三。" class="headerlink" title="&#x3D;&#x3D;比如 现在 HelloServiceImpl 对象（obj）用bind方法绑定后，返回其占位，我们再调用proxy.sayHello(“张三”),那么它就会进入到HelloServiceProxy的invoke()方法&#x3D;&#x3D;，而invoke参数中，第一个便是代理对象proxy，方法便是sayHello，参数是 张三。"></a>&#x3D;&#x3D;比如 现在 HelloServiceImpl 对象（obj）用bind方法绑定后，返回其占位，我们再调用proxy.sayHello(“张三”),那么它就会进入到HelloServiceProxy的invoke()方法&#x3D;&#x3D;，而invoke参数中，第一个便是代理对象proxy，方法便是sayHello，参数是 张三。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005220557164.png" alt="image-20221005220557164"></p><h4 id="6-1-3-CGLIB-动态代理"><a href="#6-1-3-CGLIB-动态代理" class="headerlink" title="6.1.3  CGLIB 动态代理"></a>6.1.3  CGLIB 动态代理</h4><ul><li><h4 id="JDK提供的动态代理存在一个缺陷，就是必须提供接口才能使用，为了解决这个缺陷，我们可以使用开源框架：-CGLIB。他是一种流行的动态代理。"><a href="#JDK提供的动态代理存在一个缺陷，就是必须提供接口才能使用，为了解决这个缺陷，我们可以使用开源框架：-CGLIB。他是一种流行的动态代理。" class="headerlink" title="JDK提供的动态代理存在一个缺陷，就是必须提供接口才能使用，为了解决这个缺陷，我们可以使用开源框架： CGLIB。他是一种流行的动态代理。"></a>JDK提供的动态代理存在一个缺陷，就是必须提供接口才能使用，为了解决这个缺陷，我们可以使用开源框架： CGLIB。他是一种流行的动态代理。</h4></li></ul><ol><li><h4 id="如何使用CGLIB动态代理呢？HelloService-和-HelloServciceImpl-都不需要改变，-x3D-x3D-但我们要实现CGLIB的代理类。它的实现MethodInterceptor-的代理方法-x3D-x3D-如下："><a href="#如何使用CGLIB动态代理呢？HelloService-和-HelloServciceImpl-都不需要改变，-x3D-x3D-但我们要实现CGLIB的代理类。它的实现MethodInterceptor-的代理方法-x3D-x3D-如下：" class="headerlink" title="如何使用CGLIB动态代理呢？HelloService 和 HelloServciceImpl 都不需要改变，&#x3D;&#x3D;但我们要实现CGLIB的代理类。它的实现MethodInterceptor 的代理方法&#x3D;&#x3D;如下："></a>如何使用CGLIB动态代理呢？HelloService 和 HelloServciceImpl 都不需要改变，&#x3D;&#x3D;但我们要实现CGLIB的代理类。它的实现MethodInterceptor 的代理方法&#x3D;&#x3D;如下：</h4></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ovesh.proxy;<br><br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>:TODO</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Ovesh</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/10/5 22:15</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServiceCglib</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建代理对象.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target=target;<br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        enhancer.setSuperclass(<span class="hljs-built_in">this</span>.target.getClass());<br>        <span class="hljs-comment">//todo  回调方法</span><br>        enhancer.setCallback(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//todo  创建代理对象</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 回调方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> objects</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        System.err.println(<span class="hljs-string">&quot;----------这是CGLIB的动态代理对象----------&quot;</span>);<br>        <span class="hljs-comment">//todo 反射方法前调用</span><br>        System.err.println(<span class="hljs-string">&quot;我准备说hello&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">invokeSuper</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, objects);<br>        <span class="hljs-comment">//todo 反射方法后调用</span><br>        System.out.println(<span class="hljs-string">&quot;我说过hello了&quot;</span>);<br>        <span class="hljs-keyword">return</span> invokeSuper;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-构建SqlSessionFactory-过程"><a href="#6-2-构建SqlSessionFactory-过程" class="headerlink" title="6.2   构建SqlSessionFactory 过程"></a>6.2   构建SqlSessionFactory 过程</h3><ul><li><h4 id="SqlSessionFactory是Mybatis-的核心类之一，她最重要的作用就是提供创建Mybatis核心接口的SqlSession，所以我们需要创建SqlSessionFactory，-x3D-x3D-为此我们需要提供配置文件和相关的参数-x3D-x3D-，"><a href="#SqlSessionFactory是Mybatis-的核心类之一，她最重要的作用就是提供创建Mybatis核心接口的SqlSession，所以我们需要创建SqlSessionFactory，-x3D-x3D-为此我们需要提供配置文件和相关的参数-x3D-x3D-，" class="headerlink" title="SqlSessionFactory是Mybatis 的核心类之一，她最重要的作用就是提供创建Mybatis核心接口的SqlSession，所以我们需要创建SqlSessionFactory，&#x3D;&#x3D;为此我们需要提供配置文件和相关的参数&#x3D;&#x3D;，"></a>SqlSessionFactory是Mybatis 的核心类之一，她最重要的作用就是提供创建Mybatis核心接口的SqlSession，所以我们需要创建SqlSessionFactory，&#x3D;&#x3D;为此我们需要提供配置文件和相关的参数&#x3D;&#x3D;，</h4></li><li><h4 id="而Mybatis是一个复杂的系统，采用-x3D-x3D-构造模式-x3D-x3D-去创建SqlSessionFactory，我们可以通过SqlSessionFactoryBuilder去构建，构建分为两步："><a href="#而Mybatis是一个复杂的系统，采用-x3D-x3D-构造模式-x3D-x3D-去创建SqlSessionFactory，我们可以通过SqlSessionFactoryBuilder去构建，构建分为两步：" class="headerlink" title="而Mybatis是一个复杂的系统，采用&#x3D;&#x3D;构造模式&#x3D;&#x3D;去创建SqlSessionFactory，我们可以通过SqlSessionFactoryBuilder去构建，构建分为两步："></a>而Mybatis是一个复杂的系统，采用&#x3D;&#x3D;构造模式&#x3D;&#x3D;去创建SqlSessionFactory，我们可以通过SqlSessionFactoryBuilder去构建，构建分为两步：</h4><ul><li><h4 id="第一步，-x3D-x3D-通过XMLConfigBuilder-解析XML配置文件，读出配置参数，并将读取的数据存入到ibatis包下的Configuration类中-x3D-x3D-。Mybatis几乎所有的配置都是存在这里"><a href="#第一步，-x3D-x3D-通过XMLConfigBuilder-解析XML配置文件，读出配置参数，并将读取的数据存入到ibatis包下的Configuration类中-x3D-x3D-。Mybatis几乎所有的配置都是存在这里" class="headerlink" title="第一步，&#x3D;&#x3D;通过XMLConfigBuilder 解析XML配置文件，读出配置参数，并将读取的数据存入到ibatis包下的Configuration类中&#x3D;&#x3D;。Mybatis几乎所有的配置都是存在这里"></a>第一步，&#x3D;&#x3D;通过XMLConfigBuilder 解析XML配置文件，读出配置参数，并将读取的数据存入到ibatis包下的Configuration类中&#x3D;&#x3D;。Mybatis几乎所有的配置都是存在这里</h4></li><li><h4 id="第二步，使用Confinguration对象去创建SqlSessionFactory，Mybats中的SqlSessionFactory是一个接口，而不是实现类，为此Mybatis提供了一个默认的SqlSessionFactory实现类，我们一般会使用它。"><a href="#第二步，使用Confinguration对象去创建SqlSessionFactory，Mybats中的SqlSessionFactory是一个接口，而不是实现类，为此Mybatis提供了一个默认的SqlSessionFactory实现类，我们一般会使用它。" class="headerlink" title="第二步，使用Confinguration对象去创建SqlSessionFactory，Mybats中的SqlSessionFactory是一个接口，而不是实现类，为此Mybatis提供了一个默认的SqlSessionFactory实现类，我们一般会使用它。"></a>第二步，使用Confinguration对象去创建SqlSessionFactory，Mybats中的SqlSessionFactory是一个接口，而不是实现类，为此Mybatis提供了一个默认的SqlSessionFactory实现类，我们一般会使用它<img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006094655444.png" alt="image-20221006094655444">。</h4></li><li><h4 id="大部分情况下我们都不要自己去创建新的SqlSessionFactory实现类"><a href="#大部分情况下我们都不要自己去创建新的SqlSessionFactory实现类" class="headerlink" title="大部分情况下我们都不要自己去创建新的SqlSessionFactory实现类"></a>大部分情况下我们都不要自己去创建新的SqlSessionFactory实现类</h4></li><li><h4 id="这种-x3D-x3D-创建模式是一种Builder-模式-x3D-x3D-，-x3D-x3D-对于复杂的对象，直接使用构造方法构建是有苦难的，因此我们更希望一步步有秩序地来构建它-x3D-x3D-，从而降低复杂性，这个时候-x3D-x3D-使用一个参数总领全局，如Configuration类，然后分布构建，例如-DefaultSqlSessionFactory类就可以构建一个复杂的对象，例如SqlSessionFactory，-x3D-x3D-这种设计模式值得学习。"><a href="#这种-x3D-x3D-创建模式是一种Builder-模式-x3D-x3D-，-x3D-x3D-对于复杂的对象，直接使用构造方法构建是有苦难的，因此我们更希望一步步有秩序地来构建它-x3D-x3D-，从而降低复杂性，这个时候-x3D-x3D-使用一个参数总领全局，如Configuration类，然后分布构建，例如-DefaultSqlSessionFactory类就可以构建一个复杂的对象，例如SqlSessionFactory，-x3D-x3D-这种设计模式值得学习。" class="headerlink" title="这种&#x3D;&#x3D;创建模式是一种Builder 模式&#x3D;&#x3D;，&#x3D;&#x3D;对于复杂的对象，直接使用构造方法构建是有苦难的，因此我们更希望一步步有秩序地来构建它&#x3D;&#x3D;，从而降低复杂性，这个时候&#x3D;&#x3D;使用一个参数总领全局，如Configuration类，然后分布构建，例如  DefaultSqlSessionFactory类就可以构建一个复杂的对象，例如SqlSessionFactory，&#x3D;&#x3D;这种设计模式值得学习。"></a>这种&#x3D;&#x3D;创建模式是一种Builder 模式&#x3D;&#x3D;，&#x3D;&#x3D;对于复杂的对象，直接使用构造方法构建是有苦难的，因此我们更希望一步步有秩序地来构建它&#x3D;&#x3D;，从而降低复杂性，这个时候&#x3D;&#x3D;使用一个参数总领全局，如Configuration类，然后分布构建，例如  DefaultSqlSessionFactory类就可以构建一个复杂的对象，例如SqlSessionFactory，&#x3D;&#x3D;这种设计模式值得学习。</h4></li></ul></li></ul><h4 id="6-2-1-构建Configuration"><a href="#6-2-1-构建Configuration" class="headerlink" title="6.2.1  构建Configuration"></a>6.2.1  构建Configuration</h4><ul><li><h4 id="x3D-x3D-在SqlSessionFactory-构建中，Configuration是最重要的-x3D-x3D-，它的作用如下："><a href="#x3D-x3D-在SqlSessionFactory-构建中，Configuration是最重要的-x3D-x3D-，它的作用如下：" class="headerlink" title="&#x3D;&#x3D;在SqlSessionFactory 构建中，Configuration是最重要的&#x3D;&#x3D;，它的作用如下："></a>&#x3D;&#x3D;在SqlSessionFactory 构建中，Configuration是最重要的&#x3D;&#x3D;，它的作用如下：</h4><ul><li><h4 id="读入配置文件，包括基础配置的XML文件和映射器的XMl文件"><a href="#读入配置文件，包括基础配置的XML文件和映射器的XMl文件" class="headerlink" title="读入配置文件，包括基础配置的XML文件和映射器的XMl文件"></a>读入配置文件，包括基础配置的XML文件和映射器的XMl文件</h4></li><li><h4 id="初始化基础配置，比如Mybatis的别名等，一些重要的类对象，例如，插件，映射器，ObjectFactory，和typeHandler对象"><a href="#初始化基础配置，比如Mybatis的别名等，一些重要的类对象，例如，插件，映射器，ObjectFactory，和typeHandler对象" class="headerlink" title="初始化基础配置，比如Mybatis的别名等，一些重要的类对象，例如，插件，映射器，ObjectFactory，和typeHandler对象"></a>初始化基础配置，比如Mybatis的别名等，一些重要的类对象，例如，插件，映射器，ObjectFactory，和typeHandler对象</h4></li><li><h4 id="提供单例，为后续创建SqlSessionFactory服务并提供配置的参数"><a href="#提供单例，为后续创建SqlSessionFactory服务并提供配置的参数" class="headerlink" title="提供单例，为后续创建SqlSessionFactory服务并提供配置的参数"></a>提供单例，为后续创建SqlSessionFactory服务并提供配置的参数</h4></li><li><h4 id="执行一些重要的对象方法，初始化配置信息。"><a href="#执行一些重要的对象方法，初始化配置信息。" class="headerlink" title="执行一些重要的对象方法，初始化配置信息。"></a>执行一些重要的对象方法，初始化配置信息。</h4></li></ul></li><li><h4 id="显然Configuration不会是一个很简单的类，-x3D-x3D-Mybatis的配置信息都会来自于此-x3D-x3D-，（可以看看源码），第2章得配置，都会被读入这里并保存为一个单例。Configuration是通过XMLConfigBuilder-去构建的，-x3D-x3D-首先Mybatis-会读出所有XML配置的信息，然后，将这些信息保存到Configuration类的单例中，他会做如下初始化。-x3D-x3D-："><a href="#显然Configuration不会是一个很简单的类，-x3D-x3D-Mybatis的配置信息都会来自于此-x3D-x3D-，（可以看看源码），第2章得配置，都会被读入这里并保存为一个单例。Configuration是通过XMLConfigBuilder-去构建的，-x3D-x3D-首先Mybatis-会读出所有XML配置的信息，然后，将这些信息保存到Configuration类的单例中，他会做如下初始化。-x3D-x3D-：" class="headerlink" title="显然Configuration不会是一个很简单的类，&#x3D;&#x3D;Mybatis的配置信息都会来自于此&#x3D;&#x3D;，（可以看看源码），第2章得配置，都会被读入这里并保存为一个单例。Configuration是通过XMLConfigBuilder 去构建的，&#x3D;&#x3D;首先Mybatis 会读出所有XML配置的信息，然后，将这些信息保存到Configuration类的单例中，他会做如下初始化。&#x3D;&#x3D;："></a>显然Configuration不会是一个很简单的类，&#x3D;&#x3D;Mybatis的配置信息都会来自于此&#x3D;&#x3D;，（可以看看源码），第2章得配置，都会被读入这里并保存为一个单例。Configuration是通过XMLConfigBuilder 去构建的，&#x3D;&#x3D;首先Mybatis 会读出所有XML配置的信息，然后，将这些信息保存到Configuration类的单例中，他会做如下初始化。&#x3D;&#x3D;：</h4><ul><li><h4 id="properties-全局参数"><a href="#properties-全局参数" class="headerlink" title="properties 全局参数"></a>properties 全局参数</h4></li><li><h4 id="settings-设置"><a href="#settings-设置" class="headerlink" title="settings 设置"></a>settings 设置</h4></li><li><h4 id="typeAliases别名"><a href="#typeAliases别名" class="headerlink" title="typeAliases别名"></a>typeAliases别名</h4></li><li><h4 id="tyopeHandler-类处理器"><a href="#tyopeHandler-类处理器" class="headerlink" title="tyopeHandler 类处理器"></a>tyopeHandler 类处理器</h4></li><li><h4 id="ObjectFactory对象"><a href="#ObjectFactory对象" class="headerlink" title="ObjectFactory对象"></a>ObjectFactory对象</h4></li><li><h4 id="plugin插件"><a href="#plugin插件" class="headerlink" title="plugin插件"></a>plugin插件</h4></li><li><h4 id="environment-环境"><a href="#environment-环境" class="headerlink" title="environment 环境"></a>environment 环境</h4></li><li><h4 id="DatabaseIdProvider-数据库标识"><a href="#DatabaseIdProvider-数据库标识" class="headerlink" title="DatabaseIdProvider 数据库标识"></a>DatabaseIdProvider 数据库标识</h4></li><li><h4 id="Mapper映射器。"><a href="#Mapper映射器。" class="headerlink" title="Mapper映射器。"></a>Mapper映射器。</h4></li></ul></li></ul><h4 id="6-2-2-映射器的内部组成"><a href="#6-2-2-映射器的内部组成" class="headerlink" title="6.2.2  映射器的内部组成"></a>6.2.2  映射器的内部组成</h4><ul><li><h4 id="由于插件需要频繁地访问映射器地内部组成，我们有必要单独研究一下映射器的内部组成，所以这节是本章重点之一，使用插件前务必掌握好本章内容"><a href="#由于插件需要频繁地访问映射器地内部组成，我们有必要单独研究一下映射器的内部组成，所以这节是本章重点之一，使用插件前务必掌握好本章内容" class="headerlink" title="由于插件需要频繁地访问映射器地内部组成，我们有必要单独研究一下映射器的内部组成，所以这节是本章重点之一，使用插件前务必掌握好本章内容"></a>由于插件需要频繁地访问映射器地内部组成，我们有必要单独研究一下映射器的内部组成，所以这节是本章重点之一，使用插件前务必掌握好本章内容</h4></li><li><h4 id="一般而言，一个映射器由3个部分组成："><a href="#一般而言，一个映射器由3个部分组成：" class="headerlink" title="一般而言，一个映射器由3个部分组成："></a>一般而言，一个映射器由3个部分组成：</h4><ul><li><h4 id="x3D-x3D-MappedStatement-x3D-x3D-，他保存映射器的一个节点-select-insert-delete-update-，-x3D-x3D-包括许多我们配置的SQL，SQL的id，缓存信息，resultMap，parameterType，resultType，languageDriver等重要配置内容-x3D-x3D"><a href="#x3D-x3D-MappedStatement-x3D-x3D-，他保存映射器的一个节点-select-insert-delete-update-，-x3D-x3D-包括许多我们配置的SQL，SQL的id，缓存信息，resultMap，parameterType，resultType，languageDriver等重要配置内容-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;MappedStatement&#x3D;&#x3D;，他保存映射器的一个节点(select|insert|delete|update)，&#x3D;&#x3D;包括许多我们配置的SQL，SQL的id，缓存信息，resultMap，parameterType，resultType，languageDriver等重要配置内容&#x3D;&#x3D;"></a>&#x3D;&#x3D;MappedStatement&#x3D;&#x3D;，他保存映射器的一个节点(select|insert|delete|update)，&#x3D;&#x3D;包括许多我们配置的SQL，SQL的id，缓存信息，resultMap，parameterType，resultType，languageDriver等重要配置内容&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-SqlSoource-x3D-x3D-，他是-x3D-x3D-提供BoundSql对象-x3D-x3D-的地方，他是MappedStatement的一个属性"><a href="#x3D-x3D-SqlSoource-x3D-x3D-，他是-x3D-x3D-提供BoundSql对象-x3D-x3D-的地方，他是MappedStatement的一个属性" class="headerlink" title="&#x3D;&#x3D;SqlSoource&#x3D;&#x3D;，他是&#x3D;&#x3D;提供BoundSql对象&#x3D;&#x3D;的地方，他是MappedStatement的一个属性"></a>&#x3D;&#x3D;SqlSoource&#x3D;&#x3D;，他是&#x3D;&#x3D;提供BoundSql对象&#x3D;&#x3D;的地方，他是MappedStatement的一个属性</h4></li><li><h4 id="x3D-x3D-BoundSql-x3D-x3D-，它是-x3D-x3D-建立SQl和参数的地方-x3D-x3D-，他有-x3D-x3D-三个常用的属性：SQL，parameterObject，parameterMappings-x3D-x3D-。"><a href="#x3D-x3D-BoundSql-x3D-x3D-，它是-x3D-x3D-建立SQl和参数的地方-x3D-x3D-，他有-x3D-x3D-三个常用的属性：SQL，parameterObject，parameterMappings-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;BoundSql&#x3D;&#x3D;，它是&#x3D;&#x3D;建立SQl和参数的地方&#x3D;&#x3D;，他有&#x3D;&#x3D;三个常用的属性：SQL，parameterObject，parameterMappings&#x3D;&#x3D;。"></a>&#x3D;&#x3D;BoundSql&#x3D;&#x3D;，它是&#x3D;&#x3D;建立SQl和参数的地方&#x3D;&#x3D;，他有&#x3D;&#x3D;三个常用的属性：SQL，parameterObject，parameterMappings&#x3D;&#x3D;。</h4></li></ul></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006101649836.png" alt="image-20221006101649836"></p><ul><li><h4 id="MappendStatement对象涉及的东西较多，我们一般都不去修改它，因为容易产生错误。SqlSession是接口，它的主要作用是根据参数和其他的规则组装SQl（包括动态Sql）"><a href="#MappendStatement对象涉及的东西较多，我们一般都不去修改它，因为容易产生错误。SqlSession是接口，它的主要作用是根据参数和其他的规则组装SQl（包括动态Sql）" class="headerlink" title="MappendStatement对象涉及的东西较多，我们一般都不去修改它，因为容易产生错误。SqlSession是接口，它的主要作用是根据参数和其他的规则组装SQl（包括动态Sql）"></a>MappendStatement对象涉及的东西较多，我们一般都不去修改它，因为容易产生错误。SqlSession是接口，它的主要作用是根据参数和其他的规则组装SQl（包括动态Sql）</h4></li><li><h4 id="对于参数和SQL而言，主要的规则都反映在BoundSql类对象上，在插件中往往需要拿到它，-x3D-x3D-进而可以拿到当前正在运行的SQL和参数以及参数规则，做出适当的修改-x3D-x3D-，来满足我们的特殊需求"><a href="#对于参数和SQL而言，主要的规则都反映在BoundSql类对象上，在插件中往往需要拿到它，-x3D-x3D-进而可以拿到当前正在运行的SQL和参数以及参数规则，做出适当的修改-x3D-x3D-，来满足我们的特殊需求" class="headerlink" title="对于参数和SQL而言，主要的规则都反映在BoundSql类对象上，在插件中往往需要拿到它，&#x3D;&#x3D;进而可以拿到当前正在运行的SQL和参数以及参数规则，做出适当的修改&#x3D;&#x3D;，来满足我们的特殊需求"></a>对于参数和SQL而言，主要的规则都反映在BoundSql类对象上，在插件中往往需要拿到它，&#x3D;&#x3D;进而可以拿到当前正在运行的SQL和参数以及参数规则，做出适当的修改&#x3D;&#x3D;，来满足我们的特殊需求</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006102701905.png" alt="image-20221006102701905"></p><h4 id="6-2-3-构建SqlSessionFactory"><a href="#6-2-3-构建SqlSessionFactory" class="headerlink" title="6.2.3   构建SqlSessionFactory"></a>6.2.3   构建SqlSessionFactory</h4><ul><li><h4 id="有了Configuraton-对象构建的-SqlSessionFactory-就很简单了，我们只需要写很简短的代码就行。"><a href="#有了Configuraton-对象构建的-SqlSessionFactory-就很简单了，我们只需要写很简短的代码就行。" class="headerlink" title="有了Configuraton 对象构建的 SqlSessionFactory 就很简单了，我们只需要写很简短的代码就行。"></a>有了Configuraton 对象构建的 SqlSessionFactory 就很简单了，我们只需要写很简短的代码就行。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>.build(inputStream);<br></code></pre></td></tr></table></figure><ul><li><h4 id="Mybatis-会根据Configuration-的配置-读取所配置的信息，构建SqlSessionFactory-对象。"><a href="#Mybatis-会根据Configuration-的配置-读取所配置的信息，构建SqlSessionFactory-对象。" class="headerlink" title="Mybatis 会根据Configuration 的配置 读取所配置的信息，构建SqlSessionFactory 对象。"></a>Mybatis 会根据Configuration 的配置 读取所配置的信息，构建SqlSessionFactory 对象。</h4></li></ul><h3 id="6-3-SqlSession-运行过程"><a href="#6-3-SqlSession-运行过程" class="headerlink" title="6.3   SqlSession 运行过程"></a>6.3   SqlSession 运行过程</h3><ul><li><h4 id="SqlSession-的执行过程-是重点和难点，也是整个Mybatis-最难以理解的部分。-x3D-x3D-SqlSession-是一个接口，使用它并不复杂，我们构建SqlSessionFactory-就可以轻易拿到SqlSession-了-x3D-x3D-。SqlSession-给出了-x3D-x3D-增删改查的方法-x3D-x3D-，在旧版本中常常使用，但是在新版的Mybatis中，我们更倾向于使用Mapper，所以他是最为常用和重要的接口之一"><a href="#SqlSession-的执行过程-是重点和难点，也是整个Mybatis-最难以理解的部分。-x3D-x3D-SqlSession-是一个接口，使用它并不复杂，我们构建SqlSessionFactory-就可以轻易拿到SqlSession-了-x3D-x3D-。SqlSession-给出了-x3D-x3D-增删改查的方法-x3D-x3D-，在旧版本中常常使用，但是在新版的Mybatis中，我们更倾向于使用Mapper，所以他是最为常用和重要的接口之一" class="headerlink" title="SqlSession 的执行过程 是重点和难点，也是整个Mybatis 最难以理解的部分。&#x3D;&#x3D;SqlSession 是一个接口，使用它并不复杂，我们构建SqlSessionFactory 就可以轻易拿到SqlSession 了&#x3D;&#x3D;。SqlSession 给出了&#x3D;&#x3D;增删改查的方法&#x3D;&#x3D;，在旧版本中常常使用，但是在新版的Mybatis中，我们更倾向于使用Mapper，所以他是最为常用和重要的接口之一"></a>SqlSession 的执行过程 是重点和难点，也是整个Mybatis 最难以理解的部分。&#x3D;&#x3D;SqlSession 是一个接口，使用它并不复杂，我们构建SqlSessionFactory 就可以轻易拿到SqlSession 了&#x3D;&#x3D;。SqlSession 给出了&#x3D;&#x3D;增删改查的方法&#x3D;&#x3D;，在旧版本中常常使用，但是在新版的Mybatis中，我们更倾向于使用Mapper，所以他是最为常用和重要的接口之一</h4></li><li><h4 id="虽然获取SqlSession很简单，但是它的内部实现相当复杂，后面我们循序渐进地了解与学习。"><a href="#虽然获取SqlSession很简单，但是它的内部实现相当复杂，后面我们循序渐进地了解与学习。" class="headerlink" title="虽然获取SqlSession很简单，但是它的内部实现相当复杂，后面我们循序渐进地了解与学习。"></a>虽然获取SqlSession很简单，但是它的内部实现相当复杂，后面我们循序渐进地了解与学习。</h4></li></ul><h4 id="6-3-1-映射器的动态代理"><a href="#6-3-1-映射器的动态代理" class="headerlink" title="6.3.1  映射器的动态代理"></a>6.3.1  映射器的动态代理</h4><ul><li><h4 id="x3D-x3D-Mapper映射是通过动态代理来实现的-x3D-x3D-。"><a href="#x3D-x3D-Mapper映射是通过动态代理来实现的-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;Mapper映射是通过动态代理来实现的&#x3D;&#x3D;。"></a>&#x3D;&#x3D;Mapper映射是通过动态代理来实现的&#x3D;&#x3D;。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006104231974.png" alt="image-20221006104231974"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006104239501.png" alt="image-20221006104239501"></p><ul><li><h4 id="以上代码可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法则被放到了MapperProxy类中。"><a href="#以上代码可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法则被放到了MapperProxy类中。" class="headerlink" title="以上代码可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法则被放到了MapperProxy类中。"></a>以上代码可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法则被放到了MapperProxy类中。</h4></li><li><h4 id="看看MapperProxy的源码："><a href="#看看MapperProxy的源码：" class="headerlink" title="看看MapperProxy的源码："></a>看看MapperProxy的源码：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006104533525.png" alt="image-20221006104533525"></p><ul><li><h4 id="上面运用了invoke方法，-x3D-x3D-一旦Mapper是一个代理对象，那么他就会运行到invoke方法里面-x3D-x3D-，-x3D-x3D-invoke首先判断他是否是一个类。显然Mapper是接口，不是类，所以判定失败，那么就会生成MapperMethod-对象-x3D-x3D-，-x3D-x3D-他是通过-cachedMapperMethod-方法对其初始化的，然后执行execute方法，把SqlSession-和当前运行的参数传递进去-x3D-x3D"><a href="#上面运用了invoke方法，-x3D-x3D-一旦Mapper是一个代理对象，那么他就会运行到invoke方法里面-x3D-x3D-，-x3D-x3D-invoke首先判断他是否是一个类。显然Mapper是接口，不是类，所以判定失败，那么就会生成MapperMethod-对象-x3D-x3D-，-x3D-x3D-他是通过-cachedMapperMethod-方法对其初始化的，然后执行execute方法，把SqlSession-和当前运行的参数传递进去-x3D-x3D" class="headerlink" title="上面运用了invoke方法，&#x3D;&#x3D;一旦Mapper是一个代理对象，那么他就会运行到invoke方法里面&#x3D;&#x3D;，&#x3D;&#x3D;invoke首先判断他是否是一个类。显然Mapper是接口，不是类，所以判定失败，那么就会生成MapperMethod 对象&#x3D;&#x3D;，&#x3D;&#x3D;他是通过 cachedMapperMethod 方法对其初始化的，然后执行execute方法，把SqlSession  和当前运行的参数传递进去.&#x3D;&#x3D;"></a>上面运用了invoke方法，&#x3D;&#x3D;一旦Mapper是一个代理对象，那么他就会运行到invoke方法里面&#x3D;&#x3D;，&#x3D;&#x3D;invoke首先判断他是否是一个类。显然Mapper是接口，不是类，所以判定失败，那么就会生成MapperMethod 对象&#x3D;&#x3D;，&#x3D;&#x3D;他是通过 cachedMapperMethod 方法对其初始化的，然后执行execute方法，把SqlSession  和当前运行的参数传递进去.&#x3D;&#x3D;</h4></li><li><h4 id="看看-execute-方法的源码"><a href="#看看-execute-方法的源码" class="headerlink" title="看看  execute 方法的源码:"></a>看看  execute 方法的源码:</h4></li><li><h4 id="MapperMethod-采用命令模式运行-根据上下文跳转-他可能跳转到许多方法中-我们不需要完全明白"><a href="#MapperMethod-采用命令模式运行-根据上下文跳转-他可能跳转到许多方法中-我们不需要完全明白" class="headerlink" title="MapperMethod 采用命令模式运行,根据上下文跳转,他可能跳转到许多方法中,我们不需要完全明白,"></a>MapperMethod 采用命令模式运行,根据上下文跳转,他可能跳转到许多方法中,我们不需要完全明白,</h4></li></ul><ol><li><h4 id="x3D-x3D-所有Mybatis为什么只用Mapper接口便能够隐形SQL-x3D-x3D"><a href="#x3D-x3D-所有Mybatis为什么只用Mapper接口便能够隐形SQL-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;所有Mybatis为什么只用Mapper接口便能够隐形SQL?&#x3D;&#x3D;"></a>&#x3D;&#x3D;所有Mybatis为什么只用Mapper接口便能够隐形SQL?&#x3D;&#x3D;</h4><ol><li><h4 id="x3D-x3D-因为映射器的XML文件的命名空间对应的便是这个接口的全路径-那么它根据全路径和方法名便能够绑定起来-通过动态代理技术-让这个接口跑起来-而后采用命令模式-最后还是使用SqlSession接口的方法使得它能执行查询-有了这层封装我们便可以使用接口编程-这样就更简单了-x3D-x3D"><a href="#x3D-x3D-因为映射器的XML文件的命名空间对应的便是这个接口的全路径-那么它根据全路径和方法名便能够绑定起来-通过动态代理技术-让这个接口跑起来-而后采用命令模式-最后还是使用SqlSession接口的方法使得它能执行查询-有了这层封装我们便可以使用接口编程-这样就更简单了-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;因为映射器的XML文件的命名空间对应的便是这个接口的全路径,那么它根据全路径和方法名便能够绑定起来,通过动态代理技术,让这个接口跑起来,而后采用命令模式,最后还是使用SqlSession接口的方法使得它能执行查询,有了这层封装我们便可以使用接口编程,这样就更简单了.&#x3D;&#x3D;"></a>&#x3D;&#x3D;因为映射器的XML文件的命名空间对应的便是这个接口的全路径,那么它根据全路径和方法名便能够绑定起来,通过动态代理技术,让这个接口跑起来,而后采用命令模式,最后还是使用SqlSession接口的方法使得它能执行查询,有了这层封装我们便可以使用接口编程,这样就更简单了.&#x3D;&#x3D;</h4></li></ol></li></ol><h4 id="6-3-2-SqlSession-下的四大对象"><a href="#6-3-2-SqlSession-下的四大对象" class="headerlink" title="6.3.2    SqlSession 下的四大对象"></a>6.3.2    SqlSession 下的四大对象</h4><ul><li><h4 id="通过类名和方法名字就可以匹配到我们配置的SQL-我们不需要去关心这些细节-我们关系的是设计框架-Mapper-执行的过程是通过Executor-statementHandler-ParameterHandler-和-ResultHandler-来完成数据库操作和结果返回的"><a href="#通过类名和方法名字就可以匹配到我们配置的SQL-我们不需要去关心这些细节-我们关系的是设计框架-Mapper-执行的过程是通过Executor-statementHandler-ParameterHandler-和-ResultHandler-来完成数据库操作和结果返回的" class="headerlink" title="通过类名和方法名字就可以匹配到我们配置的SQL.我们不需要去关心这些细节,我们关系的是设计框架,Mapper 执行的过程是通过Executor, statementHandler, ParameterHandler 和 ResultHandler 来完成数据库操作和结果返回的"></a>通过类名和方法名字就可以匹配到我们配置的SQL.我们不需要去关心这些细节,我们关系的是设计框架,Mapper 执行的过程是通过Executor, statementHandler, ParameterHandler 和 ResultHandler 来完成数据库操作和结果返回的</h4><ul><li><h4 id="x3D-x3D-Executor代表执行器-x3D-x3D-由他来-x3D-x3D-调度-statementHandler-ParameterHandler-ResultHandler等来执行对应的SQL-x3D-x3D"><a href="#x3D-x3D-Executor代表执行器-x3D-x3D-由他来-x3D-x3D-调度-statementHandler-ParameterHandler-ResultHandler等来执行对应的SQL-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;Executor代表执行器&#x3D;&#x3D;,由他来&#x3D;&#x3D;调度 statementHandler,ParameterHandler,ResultHandler等来执行对应的SQL&#x3D;&#x3D;."></a>&#x3D;&#x3D;Executor代表执行器&#x3D;&#x3D;,由他来&#x3D;&#x3D;调度 statementHandler,ParameterHandler,ResultHandler等来执行对应的SQL&#x3D;&#x3D;.</h4></li><li><h4 id="x3D-x3D-StatementHandler-的作用是使用数据库的Statement-PreparedStatement-执行操作-x3D-x3D-他是-x3D-x3D-四大对象的核心-起到承上启下的作用-x3D-x3D"><a href="#x3D-x3D-StatementHandler-的作用是使用数据库的Statement-PreparedStatement-执行操作-x3D-x3D-他是-x3D-x3D-四大对象的核心-起到承上启下的作用-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;StatementHandler 的作用是使用数据库的Statement(PreparedStatement)执行操作&#x3D;&#x3D;,他是&#x3D;&#x3D;四大对象的核心,起到承上启下的作用&#x3D;&#x3D;"></a>&#x3D;&#x3D;StatementHandler 的作用是使用数据库的Statement(PreparedStatement)执行操作&#x3D;&#x3D;,他是&#x3D;&#x3D;四大对象的核心,起到承上启下的作用&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-ParameterHandler-用于SQL-对参数的处理-x3D-x3D"><a href="#x3D-x3D-ParameterHandler-用于SQL-对参数的处理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ParameterHandler 用于SQL 对参数的处理&#x3D;&#x3D;"></a>&#x3D;&#x3D;ParameterHandler 用于SQL 对参数的处理&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-ResultHandler-是进行最后数据集-ResultSet-的封装返回处理的-x3D-x3D"><a href="#x3D-x3D-ResultHandler-是进行最后数据集-ResultSet-的封装返回处理的-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;ResultHandler 是进行最后数据集(ResultSet) 的封装返回处理的.&#x3D;&#x3D;"></a>&#x3D;&#x3D;ResultHandler 是进行最后数据集(ResultSet) 的封装返回处理的.&#x3D;&#x3D;</h4></li></ul></li><li><h4 id="x3D-x3D-下面我们一一分析-这四个对象的生成和运作原理-这已经是Mybatis的底层运行原理-对java-基础不牢固的我来说是一次挑战-x3D-x3D"><a href="#x3D-x3D-下面我们一一分析-这四个对象的生成和运作原理-这已经是Mybatis的底层运行原理-对java-基础不牢固的我来说是一次挑战-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;下面我们一一分析 这四个对象的生成和运作原理,这已经是Mybatis的底层运行原理,对java 基础不牢固的我来说是一次挑战.&#x3D;&#x3D;"></a>&#x3D;&#x3D;下面我们一一分析 这四个对象的生成和运作原理,这已经是Mybatis的底层运行原理,对java 基础不牢固的我来说是一次挑战.&#x3D;&#x3D;</h4></li></ul><h5 id="6-3-2-1-执行器"><a href="#6-3-2-1-执行器" class="headerlink" title="6.3.2.1    执行器"></a>6.3.2.1    执行器</h5><ul><li><h4 id="执行器-Executor-起到了至关重要的作用-他是一个真正执行java和数据库交互的东西-在Mybatis-中存在三种执行器-我们可以在Mybatis的配置文件中进行选择"><a href="#执行器-Executor-起到了至关重要的作用-他是一个真正执行java和数据库交互的东西-在Mybatis-中存在三种执行器-我们可以在Mybatis的配置文件中进行选择" class="headerlink" title="执行器(Executor) 起到了至关重要的作用,他是一个真正执行java和数据库交互的东西,在Mybatis 中存在三种执行器,我们可以在Mybatis的配置文件中进行选择.:"></a>执行器(Executor) 起到了至关重要的作用,他是一个真正执行java和数据库交互的东西,在Mybatis 中存在三种执行器,我们可以在Mybatis的配置文件中进行选择.:</h4><ul><li><h4 id="SIMPLE-简易执行器-不配置它就是默认执行器"><a href="#SIMPLE-简易执行器-不配置它就是默认执行器" class="headerlink" title="SIMPLE,简易执行器,不配置它就是默认执行器"></a>SIMPLE,简易执行器,不配置它就是默认执行器</h4></li><li><h4 id="REUSE-是一种执行器重用预处理语言"><a href="#REUSE-是一种执行器重用预处理语言" class="headerlink" title="REUSE,是一种执行器重用预处理语言"></a>REUSE,是一种执行器重用预处理语言</h4></li><li><h4 id="BATCH-执行器重用语句和批量更新-它是针对批量专用的执行器"><a href="#BATCH-执行器重用语句和批量更新-它是针对批量专用的执行器" class="headerlink" title="BATCH,执行器重用语句和批量更新,它是针对批量专用的执行器."></a>BATCH,执行器重用语句和批量更新,它是针对批量专用的执行器.</h4></li></ul></li><li><h4 id="他们都提供了-查询和更新的方法-以及相关的事务方法-这些和其他框架并无不同-不过我们也应该了解他们是如何构造的-看看-如何创建Executor-执行器的执行"><a href="#他们都提供了-查询和更新的方法-以及相关的事务方法-这些和其他框架并无不同-不过我们也应该了解他们是如何构造的-看看-如何创建Executor-执行器的执行" class="headerlink" title="他们都提供了  查询和更新的方法,以及相关的事务方法,这些和其他框架并无不同,不过我们也应该了解他们是如何构造的.看看 如何创建Executor,执行器的执行:"></a>他们都提供了  查询和更新的方法,以及相关的事务方法,这些和其他框架并无不同,不过我们也应该了解他们是如何构造的.看看 如何创建Executor,执行器的执行:</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006122050522.png" alt="image-20221006122050522"></p><ul><li><h4 id="如同描述一样-Mybatis将根据配置类型去确定你需要创建三种执行器中的哪一种-在创建对象后-它会去执行这样一段代码"><a href="#如同描述一样-Mybatis将根据配置类型去确定你需要创建三种执行器中的哪一种-在创建对象后-它会去执行这样一段代码" class="headerlink" title="如同描述一样,Mybatis将根据配置类型去确定你需要创建三种执行器中的哪一种,在创建对象后,它会去执行这样一段代码:"></a>如同描述一样,Mybatis将根据配置类型去确定你需要创建三种执行器中的哪一种,在创建对象后,它会去执行这样一段代码:</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">interceptorChain.pluginAll(executor);<br></code></pre></td></tr></table></figure><ul><li><h4 id="这就是Mybatis-的插件-这里他将为我们构建一层层的动态代理对象-在调度真实的Executor方法之前主席那个配置插件的代码可以修改"><a href="#这就是Mybatis-的插件-这里他将为我们构建一层层的动态代理对象-在调度真实的Executor方法之前主席那个配置插件的代码可以修改" class="headerlink" title="这就是Mybatis 的插件,这里他将为我们构建一层层的动态代理对象,在调度真实的Executor方法之前主席那个配置插件的代码可以修改."></a>这就是Mybatis 的插件,这里他将为我们构建一层层的动态代理对象,在调度真实的Executor方法之前主席那个配置插件的代码可以修改.</h4></li></ul><ol><li><h4 id="显然Mybatis根据configuration-来构建statementHandler-然后prepareStatement方法-对SQL编译并对参数进行初始化"><a href="#显然Mybatis根据configuration-来构建statementHandler-然后prepareStatement方法-对SQL编译并对参数进行初始化" class="headerlink" title="显然Mybatis根据configuration 来构建statementHandler,然后prepareStatement方法,对SQL编译并对参数进行初始化."></a>显然Mybatis根据configuration 来构建statementHandler,然后prepareStatement方法,对SQL编译并对参数进行初始化.</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221006174716748.png" alt="image-20221006174716748"></p><ul><li><h4 id="一条查询Sql的执行过程："><a href="#一条查询Sql的执行过程：" class="headerlink" title="一条查询Sql的执行过程："></a>一条查询Sql的执行过程：</h4></li></ul><ol><li><h4 id="Executor会先调用StatementHandle的prepare（）方法编译SQL语句，同时设置运行的基本参数，然后用parameterize-方法调用ParameterHandler-设置参数，完成预编译。跟着就是执行查询，而update-也是这样的，最后如果需要查询，我们就用ResultSetHandler封装结果返回给调用者。"><a href="#Executor会先调用StatementHandle的prepare（）方法编译SQL语句，同时设置运行的基本参数，然后用parameterize-方法调用ParameterHandler-设置参数，完成预编译。跟着就是执行查询，而update-也是这样的，最后如果需要查询，我们就用ResultSetHandler封装结果返回给调用者。" class="headerlink" title="Executor会先调用StatementHandle的prepare（）方法编译SQL语句，同时设置运行的基本参数，然后用parameterize() 方法调用ParameterHandler 设置参数，完成预编译。跟着就是执行查询，而update() 也是这样的，最后如果需要查询，我们就用ResultSetHandler封装结果返回给调用者。"></a>Executor会先调用StatementHandle的prepare（）方法编译SQL语句，同时设置运行的基本参数，然后用parameterize() 方法调用ParameterHandler 设置参数，完成预编译。跟着就是执行查询，而update() 也是这样的，最后如果需要查询，我们就用ResultSetHandler封装结果返回给调用者。</h4></li></ol><h5 id="6-3-2-3-参数处理器"><a href="#6-3-2-3-参数处理器" class="headerlink" title="6.3.2.3  参数处理器"></a>6.3.2.3  参数处理器</h5><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007220246471.png" alt="image-20221007220246471"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007220253557.png" alt="image-20221007220253557"></p><h5 id="6-3-2-4-结果处理器"><a href="#6-3-2-4-结果处理器" class="headerlink" title="6.3.2.4    结果处理器"></a>6.3.2.4    结果处理器</h5><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007220318022.png" alt="image-20221007220318022"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007220324718.png" alt="image-20221007220324718"></p><h5 id="6-3-3-SqlSession-运行总结"><a href="#6-3-3-SqlSession-运行总结" class="headerlink" title="6.3.3  SqlSession 运行总结"></a>6.3.3  SqlSession 运行总结</h5><ul><li><h4 id="SqlSession-内部运行图"><a href="#SqlSession-内部运行图" class="headerlink" title="SqlSession 内部运行图"></a>SqlSession 内部运行图</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007220805424.png" alt="image-20221007220805424"></p><ol><li><h4 id="SqlSession-是通过Executor-创建statementHandler-来运行的，而StatementHandler-要经过下面三步："><a href="#SqlSession-是通过Executor-创建statementHandler-来运行的，而StatementHandler-要经过下面三步：" class="headerlink" title="SqlSession 是通过Executor 创建statementHandler 来运行的，而StatementHandler 要经过下面三步："></a>SqlSession 是通过Executor 创建statementHandler 来运行的，而StatementHandler 要经过下面三步：</h4><ol><li><h4 id="prepared-预编译SQL"><a href="#prepared-预编译SQL" class="headerlink" title="prepared 预编译SQL"></a>prepared 预编译SQL</h4></li><li><h4 id="parameterrize设置参数"><a href="#parameterrize设置参数" class="headerlink" title="parameterrize设置参数"></a>parameterrize设置参数</h4></li><li><h4 id="query-x2F-update执行sql。"><a href="#query-x2F-update执行sql。" class="headerlink" title="query&#x2F;update执行sql。"></a>query&#x2F;update执行sql。</h4></li></ol></li></ol><ul><li><h4 id="其中parameterrize-是调用parameterHandler-的方法去设置的，而参数是根据类型处理器typerHandler去处理的。query-x2F-update-方法是通过resulthandler-进行处理结果的封装，如果是update的语句，他就返回整数，否则他就额能通过typeHandler处理结果类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。这便是SqlSession-执行的过程。"><a href="#其中parameterrize-是调用parameterHandler-的方法去设置的，而参数是根据类型处理器typerHandler去处理的。query-x2F-update-方法是通过resulthandler-进行处理结果的封装，如果是update的语句，他就返回整数，否则他就额能通过typeHandler处理结果类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。这便是SqlSession-执行的过程。" class="headerlink" title="其中parameterrize 是调用parameterHandler 的方法去设置的，而参数是根据类型处理器typerHandler去处理的。query&#x2F;update 方法是通过resulthandler 进行处理结果的封装，如果是update的语句，他就返回整数，否则他就额能通过typeHandler处理结果类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。这便是SqlSession  执行的过程。"></a>其中parameterrize 是调用parameterHandler 的方法去设置的，而参数是根据类型处理器typerHandler去处理的。query&#x2F;update 方法是通过resulthandler 进行处理结果的封装，如果是update的语句，他就返回整数，否则他就额能通过typeHandler处理结果类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。这便是SqlSession  执行的过程。</h4></li></ul><h2 id="第7章-插件"><a href="#第7章-插件" class="headerlink" title="第7章   插件"></a>第7章   插件</h2><ul><li><h4 id="没能完全理解插件时谈论，使用插件是十分危险的。使用插件意味着修改Mybatis的底层封装，意味着可能会毁了Mybatis这个框架"><a href="#没能完全理解插件时谈论，使用插件是十分危险的。使用插件意味着修改Mybatis的底层封装，意味着可能会毁了Mybatis这个框架" class="headerlink" title="没能完全理解插件时谈论，使用插件是十分危险的。使用插件意味着修改Mybatis的底层封装，意味着可能会毁了Mybatis这个框架"></a>没能完全理解插件时谈论，使用插件是十分危险的。使用插件意味着修改Mybatis的底层封装，意味着可能会毁了Mybatis这个框架</h4></li><li><h4 id="使用插件很危险，非不要不使用。"><a href="#使用插件很危险，非不要不使用。" class="headerlink" title="使用插件很危险，非不要不使用。"></a>使用插件很危险，非不要不使用。</h4></li></ul><h3 id="7-1-插件接口"><a href="#7-1-插件接口" class="headerlink" title="7.1  插件接口"></a>7.1  插件接口</h3><ul><li><h4 id="在Mybatis中使用插件，必须是实现Interceptor。"><a href="#在Mybatis中使用插件，必须是实现Interceptor。" class="headerlink" title="在Mybatis中使用插件，必须是实现Interceptor。"></a>在Mybatis中使用插件，必须是实现Interceptor。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span>&#123;<br>    Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br>    Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="在接口中存在三个方法："><a href="#在接口中存在三个方法：" class="headerlink" title="在接口中存在三个方法："></a>在接口中存在三个方法：</h4><ul><li><h4 id="intercept方法：-它将直接覆盖你所拦截对象原有的方法，因此它是插件的核心方法。intercept里面有个参数Invocation-对象，通过它可以反射-调度原来对象的方法。"><a href="#intercept方法：-它将直接覆盖你所拦截对象原有的方法，因此它是插件的核心方法。intercept里面有个参数Invocation-对象，通过它可以反射-调度原来对象的方法。" class="headerlink" title="intercept方法： 它将直接覆盖你所拦截对象原有的方法，因此它是插件的核心方法。intercept里面有个参数Invocation 对象，通过它可以反射 调度原来对象的方法。"></a>intercept方法： 它将直接覆盖你所拦截对象原有的方法，因此它是插件的核心方法。intercept里面有个参数Invocation 对象，通过它可以反射 调度原来对象的方法。</h4></li><li><h4 id="plugin-方法：-target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，并返回它，为了方便Mybatis使用-Plugin中的wrap静态-static）方法提供生成代理对象，我们往往使用plugin方法便可以生成一个代理对象了，当然也可以在自己去定义"><a href="#plugin-方法：-target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，并返回它，为了方便Mybatis使用-Plugin中的wrap静态-static）方法提供生成代理对象，我们往往使用plugin方法便可以生成一个代理对象了，当然也可以在自己去定义" class="headerlink" title="plugin 方法： target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，并返回它，为了方便Mybatis使用 Plugin中的wrap静态(static）方法提供生成代理对象，我们往往使用plugin方法便可以生成一个代理对象了，当然也可以在自己去定义"></a>plugin 方法： target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象，并返回它，为了方便Mybatis使用 Plugin中的wrap静态(static）方法提供生成代理对象，我们往往使用plugin方法便可以生成一个代理对象了，当然也可以在自己去定义</h4></li><li><h4 id="setProperties方法：-允许Plugin元素中配置所需参数，方法在插件初始化的时候就被调用了一次，然后把插件对象存入到配置中，以便后面再取出。"><a href="#setProperties方法：-允许Plugin元素中配置所需参数，方法在插件初始化的时候就被调用了一次，然后把插件对象存入到配置中，以便后面再取出。" class="headerlink" title="setProperties方法： 允许Plugin元素中配置所需参数，方法在插件初始化的时候就被调用了一次，然后把插件对象存入到配置中，以便后面再取出。"></a>setProperties方法： 允许Plugin元素中配置所需参数，方法在插件初始化的时候就被调用了一次，然后把插件对象存入到配置中，以便后面再取出。</h4></li></ul></li></ul><p>这里我们看到了插件的骨架，这样的模式我们称为 &#x3D;&#x3D;模板模式&#x3D;&#x3D;，就是提供一个骨架，并且告知骨架中的方法是干什么用的，由开发者来完成它，在实际上，我们常常用到模板模式。</p><h3 id="7-2-插件的初始化"><a href="#7-2-插件的初始化" class="headerlink" title="7.2   插件的初始化"></a>7.2   插件的初始化</h3><ol><li><h4 id="插件的初始化是在Mybatis-初始化的额时候完成的，可以通过XMLConfigBuilder-得知。"><a href="#插件的初始化是在Mybatis-初始化的额时候完成的，可以通过XMLConfigBuilder-得知。" class="headerlink" title="插件的初始化是在Mybatis 初始化的额时候完成的，可以通过XMLConfigBuilder 得知。"></a>插件的初始化是在Mybatis 初始化的额时候完成的，可以通过XMLConfigBuilder 得知。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007231020643.png" alt="image-20221007231020643"></p><ol><li><h4 id="在解析配置文件时，在Mybatis的上下文初始化的过程中，就开始读入插件节点和我们配置的参数"><a href="#在解析配置文件时，在Mybatis的上下文初始化的过程中，就开始读入插件节点和我们配置的参数" class="headerlink" title="在解析配置文件时，在Mybatis的上下文初始化的过程中，就开始读入插件节点和我们配置的参数"></a>在解析配置文件时，在Mybatis的上下文初始化的过程中，就开始读入插件节点和我们配置的参数</h4></li><li><h4 id="同时使用反射技术生成对应的插件实例，然后调用插件方法中的setProperties，设置我们配置的参数，然后将插件实例保存到配置对象中，以便读取和使用它"><a href="#同时使用反射技术生成对应的插件实例，然后调用插件方法中的setProperties，设置我们配置的参数，然后将插件实例保存到配置对象中，以便读取和使用它" class="headerlink" title="同时使用反射技术生成对应的插件实例，然后调用插件方法中的setProperties，设置我们配置的参数，然后将插件实例保存到配置对象中，以便读取和使用它"></a>同时使用反射技术生成对应的插件实例，然后调用插件方法中的setProperties，设置我们配置的参数，然后将插件实例保存到配置对象中，以便读取和使用它</h4></li><li><h4 id="所以插件的实例对象是一开始就被初始化的，而不是用到的时候才初始化的，我们使用它的时候，直接拿出来就可以了，这样有助于性能的提高。"><a href="#所以插件的实例对象是一开始就被初始化的，而不是用到的时候才初始化的，我们使用它的时候，直接拿出来就可以了，这样有助于性能的提高。" class="headerlink" title="所以插件的实例对象是一开始就被初始化的，而不是用到的时候才初始化的，我们使用它的时候，直接拿出来就可以了，这样有助于性能的提高。"></a>所以插件的实例对象是一开始就被初始化的，而不是用到的时候才初始化的，我们使用它的时候，直接拿出来就可以了，这样有助于性能的提高。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007232041458.png" alt="image-20221007232041458"></p><h3 id="7-3-插件的代理和反射设计"><a href="#7-3-插件的代理和反射设计" class="headerlink" title="7.3  插件的代理和反射设计"></a>7.3  插件的代理和反射设计</h3><ul><li><h4 id="插件用的是-x3D-x3D-责任链模式-x3D-x3D-。-什么是责任链模式，就是一个对象，在Mybatis中可能是四大对象中的一个，在多个角色中传递，处在传递链上的任何角色都有处理他的机会。"><a href="#插件用的是-x3D-x3D-责任链模式-x3D-x3D-。-什么是责任链模式，就是一个对象，在Mybatis中可能是四大对象中的一个，在多个角色中传递，处在传递链上的任何角色都有处理他的机会。" class="headerlink" title="插件用的是 &#x3D;&#x3D;责任链模式&#x3D;&#x3D;。  什么是责任链模式，就是一个对象，在Mybatis中可能是四大对象中的一个，在多个角色中传递，处在传递链上的任何角色都有处理他的机会。"></a>插件用的是 &#x3D;&#x3D;责任链模式&#x3D;&#x3D;。  什么是责任链模式，就是一个对象，在Mybatis中可能是四大对象中的一个，在多个角色中传递，处在传递链上的任何角色都有处理他的机会。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007232622564.png" alt="image-20221007232622564"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007232629063.png" alt="image-20221007232629063"></p><ul><li><h4 id="责任链模式的作用就是让每一个责任链上的角色都有机会去拦截这个对象，在将来如果有新的角色也可以轻松拦截请求对象，进行处理"><a href="#责任链模式的作用就是让每一个责任链上的角色都有机会去拦截这个对象，在将来如果有新的角色也可以轻松拦截请求对象，进行处理" class="headerlink" title="责任链模式的作用就是让每一个责任链上的角色都有机会去拦截这个对象，在将来如果有新的角色也可以轻松拦截请求对象，进行处理"></a>责任链模式的作用就是让每一个责任链上的角色都有机会去拦截这个对象，在将来如果有新的角色也可以轻松拦截请求对象，进行处理</h4></li><li><h4 id="Mybatis-的责任链-是由-interceptorChain-去定义的，如Mybatis在创建执行器时：。"><a href="#Mybatis-的责任链-是由-interceptorChain-去定义的，如Mybatis在创建执行器时：。" class="headerlink" title="Mybatis 的责任链 是由 interceptorChain 去定义的，如Mybatis在创建执行器时：。"></a>Mybatis 的责任链 是由 interceptorChain 去定义的，如Mybatis在创建执行器时：。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007233302808.png" alt="image-20221007233302808"></p><ul><li><h4 id="pluginAll-方法的实现："><a href="#pluginAll-方法的实现：" class="headerlink" title="pluginAll() 方法的实现："></a>pluginAll() 方法的实现：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007233718454.png" alt="image-20221007233718454"></p><ul><li><h4 id="x3D-x3D-plugin方法是生成代理对象的-x3D-x3D-，当它-x3D-x3D-取出插件的时候是从Configuration对象中去取出的-x3D-x3D-，从第一个对象开始，将对象传递给plugin方法，然后返回一个代理；如果存在第二个插件，那么我们就拿到第一个代理对象，传递给plugin方法-x3D-x3D-再返回第一个代理对象的代理…-依次类推，有多少拦截器就生成多少个代理对象。-x3D-x3D"><a href="#x3D-x3D-plugin方法是生成代理对象的-x3D-x3D-，当它-x3D-x3D-取出插件的时候是从Configuration对象中去取出的-x3D-x3D-，从第一个对象开始，将对象传递给plugin方法，然后返回一个代理；如果存在第二个插件，那么我们就拿到第一个代理对象，传递给plugin方法-x3D-x3D-再返回第一个代理对象的代理…-依次类推，有多少拦截器就生成多少个代理对象。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;plugin方法是生成代理对象的&#x3D;&#x3D;，当它&#x3D;&#x3D;取出插件的时候是从Configuration对象中去取出的&#x3D;&#x3D;，从第一个对象开始，将对象传递给plugin方法，然后返回一个代理；如果存在第二个插件，那么我们就拿到第一个代理对象，传递给plugin方法&#x3D;&#x3D;再返回第一个代理对象的代理….依次类推，有多少拦截器就生成多少个代理对象。&#x3D;&#x3D;"></a>&#x3D;&#x3D;plugin方法是生成代理对象的&#x3D;&#x3D;，当它&#x3D;&#x3D;取出插件的时候是从Configuration对象中去取出的&#x3D;&#x3D;，从第一个对象开始，将对象传递给plugin方法，然后返回一个代理；如果存在第二个插件，那么我们就拿到第一个代理对象，传递给plugin方法&#x3D;&#x3D;再返回第一个代理对象的代理….依次类推，有多少拦截器就生成多少个代理对象。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007234039136.png" alt="image-20221007234039136"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221007234044108.png" alt="image-20221007234044108"></p><h3 id="7-4-常用的工具类——-MetaObject"><a href="#7-4-常用的工具类——-MetaObject" class="headerlink" title="7.4  常用的工具类—— MetaObject"></a>7.4  常用的工具类—— MetaObject</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171145048.png" alt="image-20221008171145048"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171156286.png" alt="image-20221008171156286"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171204826.png" alt="image-20221008171204826"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171213828.png" alt="image-20221008171213828"></p><h3 id="7-5-插件开发过程和实例"><a href="#7-5-插件开发过程和实例" class="headerlink" title="7.5   插件开发过程和实例"></a>7.5   插件开发过程和实例</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171254679.png" alt="image-20221008171254679"></p><h4 id="7-5-1-确定拦截的签名"><a href="#7-5-1-确定拦截的签名" class="headerlink" title="7.5.1     确定拦截的签名"></a>7.5.1     确定拦截的签名</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171342351.png" alt="image-20221008171342351"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171405987.png" alt="image-20221008171405987"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171629457.png" alt="image-20221008171629457"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171639846.png" alt="image-20221008171639846"></p><h4 id="7-5-2-实现拦截方法"><a href="#7-5-2-实现拦截方法" class="headerlink" title="7.5.2      实现拦截方法"></a>7.5.2      实现拦截方法</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171939941.png" alt="image-20221008171939941"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008171955631.png" alt="image-20221008171955631"></p><h4 id="7-5-3-配置和运行"><a href="#7-5-3-配置和运行" class="headerlink" title="7.5.3  配置和运行"></a>7.5.3  配置和运行</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008172932540.png" alt="image-20221008172932540"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210415814.png" alt="image-20221008210415814"></p><h4 id="7-5-4-插件实例"><a href="#7-5-4-插件实例" class="headerlink" title="7.5.4  插件实例"></a>7.5.4  插件实例</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210618861.png" alt="image-20221008210618861"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210625431.png" alt="image-20221008210625431"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210638096.png" alt="image-20221008210638096"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210646000.png" alt="image-20221008210646000"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210651834.png" alt="image-20221008210651834"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210701359.png" alt="image-20221008210701359"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210722141.png" alt="image-20221008210722141"></p><h3 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6  总结"></a>7.6  总结</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210748799.png" alt="image-20221008210748799"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221008210757883.png" alt="image-20221008210757883"></p><h2 id="第8章-Mybatis-Spring"><a href="#第8章-Mybatis-Spring" class="headerlink" title="第8章 Mybatis-Spring"></a>第8章 Mybatis-Spring</h2><ul><li><h4 id="使用Mybatis-Spring-使得业务层和模型层得到了更好的分离，与此同时在spring环境中使用Mybatis-也更加简单，节省了不少代码。我们甚至不需要显性地使用SqlSessionFactory，SqlSession-等对象，因为Mybatis-spring-封装了他们。"><a href="#使用Mybatis-Spring-使得业务层和模型层得到了更好的分离，与此同时在spring环境中使用Mybatis-也更加简单，节省了不少代码。我们甚至不需要显性地使用SqlSessionFactory，SqlSession-等对象，因为Mybatis-spring-封装了他们。" class="headerlink" title="使用Mybatis-Spring  使得业务层和模型层得到了更好的分离，与此同时在spring环境中使用Mybatis 也更加简单，节省了不少代码。我们甚至不需要显性地使用SqlSessionFactory，SqlSession 等对象，因为Mybatis -spring 封装了他们。"></a>使用Mybatis-Spring  使得业务层和模型层得到了更好的分离，与此同时在spring环境中使用Mybatis 也更加简单，节省了不少代码。我们甚至不需要显性地使用SqlSessionFactory，SqlSession 等对象，因为Mybatis -spring 封装了他们。</h4></li></ul><h3 id="8-1-1-Spriong-IOC-基础"><a href="#8-1-1-Spriong-IOC-基础" class="headerlink" title="8.1.1  Spriong IOC 基础"></a>8.1.1  Spriong IOC 基础</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005195953055.png" alt="image-20221005195953055"></p><ol><li><h4 id="这个时候IOC理念来了，首先它不是一种技术，而是一种理念。假设我们不采用new方法，而是使用一种描述的方式，每个U盘都有一段自己的描述，通过接口我们可以读入这些信息，根据这些信息注入对应的U盘，这样我们在维护源码的时候只需要去描述这些信息并且提供对应的服务即可，不需要去改动源码。"><a href="#这个时候IOC理念来了，首先它不是一种技术，而是一种理念。假设我们不采用new方法，而是使用一种描述的方式，每个U盘都有一段自己的描述，通过接口我们可以读入这些信息，根据这些信息注入对应的U盘，这样我们在维护源码的时候只需要去描述这些信息并且提供对应的服务即可，不需要去改动源码。" class="headerlink" title="这个时候IOC理念来了，首先它不是一种技术，而是一种理念。假设我们不采用new方法，而是使用一种描述的方式，每个U盘都有一段自己的描述，通过接口我们可以读入这些信息，根据这些信息注入对应的U盘，这样我们在维护源码的时候只需要去描述这些信息并且提供对应的服务即可，不需要去改动源码。"></a>这个时候IOC理念来了，首先它不是一种技术，而是一种理念。假设我们不采用new方法，而是使用一种描述的方式，每个U盘都有一段自己的描述，通过接口我们可以读入这些信息，根据这些信息注入对应的U盘，这样我们在维护源码的时候只需要去描述这些信息并且提供对应的服务即可，不需要去改动源码。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005200640702.png" alt="image-20221005200640702"></p><ul><li><h4 id="我们往Spring中-注入资源往往是通过描述来实现的，在Spring中往往是注解或者是XML-描述。Spring中的IOC-注入分为："><a href="#我们往Spring中-注入资源往往是通过描述来实现的，在Spring中往往是注解或者是XML-描述。Spring中的IOC-注入分为：" class="headerlink" title="我们往Spring中 注入资源往往是通过描述来实现的，在Spring中往往是注解或者是XML 描述。Spring中的IOC 注入分为："></a>我们往Spring中 注入资源往往是通过描述来实现的，在Spring中往往是注解或者是XML 描述。Spring中的IOC 注入分为：</h4><ul><li><h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h4></li><li><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4></li><li><h4 id="接口注入。"><a href="#接口注入。" class="headerlink" title="接口注入。"></a>接口注入。</h4></li></ul></li><li><h4 id="构造方法注入是依靠的构造去实现的，-x3D-x3D-对于一些参数较少的对象，可以使用这个方式注入-x3D-x3D-。比如角色类，Trole，它的构造方法中包含三种属性。"><a href="#构造方法注入是依靠的构造去实现的，-x3D-x3D-对于一些参数较少的对象，可以使用这个方式注入-x3D-x3D-。比如角色类，Trole，它的构造方法中包含三种属性。" class="headerlink" title="构造方法注入是依靠的构造去实现的，&#x3D;&#x3D;对于一些参数较少的对象，可以使用这个方式注入&#x3D;&#x3D;。比如角色类，Trole，它的构造方法中包含三种属性。"></a>构造方法注入是依靠的构造去实现的，&#x3D;&#x3D;对于一些参数较少的对象，可以使用这个方式注入&#x3D;&#x3D;。比如角色类，Trole，它的构造方法中包含三种属性。</h4></li><li><h4 id="用Spring-IOC-生成实例"><a href="#用Spring-IOC-生成实例" class="headerlink" title="用Spring IOC  生成实例"></a>用Spring IOC  生成实例</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005201153512.png" alt="image-20221005201153512"></p><ul><li><h4 id="当构造方法很多时，显然构造注入不是很好的一个选择，-x3D-x3D-而spring推荐使用setter注入-x3D-x3D-，假设上例角色类还有一个-没有参数的构造方法，它的三个属性，id，roleName-note-x3D-x3D-都有setter-方法，那么我们可以使用setter-注入。-x3D-x3D"><a href="#当构造方法很多时，显然构造注入不是很好的一个选择，-x3D-x3D-而spring推荐使用setter注入-x3D-x3D-，假设上例角色类还有一个-没有参数的构造方法，它的三个属性，id，roleName-note-x3D-x3D-都有setter-方法，那么我们可以使用setter-注入。-x3D-x3D" class="headerlink" title="当构造方法很多时，显然构造注入不是很好的一个选择，&#x3D;&#x3D;而spring推荐使用setter注入&#x3D;&#x3D;，假设上例角色类还有一个 没有参数的构造方法，它的三个属性，id，roleName,note  &#x3D;&#x3D;都有setter 方法，那么我们可以使用setter 注入。&#x3D;&#x3D;"></a>当构造方法很多时，显然构造注入不是很好的一个选择，&#x3D;&#x3D;而spring推荐使用setter注入&#x3D;&#x3D;，假设上例角色类还有一个 没有参数的构造方法，它的三个属性，id，roleName,note  &#x3D;&#x3D;都有setter 方法，那么我们可以使用setter 注入。&#x3D;&#x3D;</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005201541802.png" alt="image-20221005201541802"></p><ul><li><h4 id="x3D-x3D-使用setter注入-x3D-x3D-更加灵活，因为使用构造方法，会受到构造方法的参数个数，顺序这些因素干扰，-x3D-x3D-侵入更加少，所以这是Spring首选的注入方式-x3D-x3D"><a href="#x3D-x3D-使用setter注入-x3D-x3D-更加灵活，因为使用构造方法，会受到构造方法的参数个数，顺序这些因素干扰，-x3D-x3D-侵入更加少，所以这是Spring首选的注入方式-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;使用setter注入&#x3D;&#x3D;更加灵活，因为使用构造方法，会受到构造方法的参数个数，顺序这些因素干扰，&#x3D;&#x3D;侵入更加少，所以这是Spring首选的注入方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;使用setter注入&#x3D;&#x3D;更加灵活，因为使用构造方法，会受到构造方法的参数个数，顺序这些因素干扰，&#x3D;&#x3D;侵入更加少，所以这是Spring首选的注入方式&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-Spring的接口注入方式-x3D-x3D-，它是一种注入其他服务器的接口，不如JNDI数据源的注入，在Tomcat或者其他的服务器中往往配置JNDI数据源，那么就可以使用接口注入我们需要的资源。"><a href="#x3D-x3D-Spring的接口注入方式-x3D-x3D-，它是一种注入其他服务器的接口，不如JNDI数据源的注入，在Tomcat或者其他的服务器中往往配置JNDI数据源，那么就可以使用接口注入我们需要的资源。" class="headerlink" title="&#x3D;&#x3D;Spring的接口注入方式&#x3D;&#x3D;，它是一种注入其他服务器的接口，不如JNDI数据源的注入，在Tomcat或者其他的服务器中往往配置JNDI数据源，那么就可以使用接口注入我们需要的资源。"></a>&#x3D;&#x3D;Spring的接口注入方式&#x3D;&#x3D;，它是一种注入其他服务器的接口，不如JNDI数据源的注入，在Tomcat或者其他的服务器中往往配置JNDI数据源，那么就可以使用接口注入我们需要的资源。</h4></li><li><h4 id="。"><a href="#。" class="headerlink" title="。"></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005202200614.png" alt="image-20221005202200614">。</h4></li><li><h4 id="此外，-x3D-x3D-在大型系统中，我们还会使用注解注入的方式来描述系统服务之间的关系，这也是Spring所推荐的-x3D-x3D-。"><a href="#此外，-x3D-x3D-在大型系统中，我们还会使用注解注入的方式来描述系统服务之间的关系，这也是Spring所推荐的-x3D-x3D-。" class="headerlink" title="此外，&#x3D;&#x3D;在大型系统中，我们还会使用注解注入的方式来描述系统服务之间的关系，这也是Spring所推荐的&#x3D;&#x3D;。"></a>此外，&#x3D;&#x3D;在大型系统中，我们还会使用注解注入的方式来描述系统服务之间的关系，这也是Spring所推荐的&#x3D;&#x3D;。</h4></li></ul><h3 id="8-1-2-Spring-Aop-基础"><a href="#8-1-2-Spring-Aop-基础" class="headerlink" title="8.1.2    Spring Aop 基础"></a>8.1.2    Spring Aop 基础</h3><ul><li><h4 id="Spring-IOC-是用反射技术实现的，而Spring-AOP就不是了，在Mybatis-srping中，它最大的用处是事务的控制，这是一个最麻烦也最难理解的东西。"><a href="#Spring-IOC-是用反射技术实现的，而Spring-AOP就不是了，在Mybatis-srping中，它最大的用处是事务的控制，这是一个最麻烦也最难理解的东西。" class="headerlink" title="Spring IOC 是用反射技术实现的，而Spring AOP就不是了，在Mybatis-srping中，它最大的用处是事务的控制，这是一个最麻烦也最难理解的东西。"></a>Spring IOC 是用反射技术实现的，而Spring AOP就不是了，在Mybatis-srping中，它最大的用处是事务的控制，这是一个最麻烦也最难理解的东西。</h4></li><li><h4 id="x3D-x3D-Spring-AOP-是通过动态代理来实现的。-x3D-x3D-首先在传统的MVC框架中，业务层一般都夹带着数据库的事务管理，例如-x3D-x3D-插入一个角色，他是使用RoleService接口-的实现类RoleServiceImpl-去实现的。"><a href="#x3D-x3D-Spring-AOP-是通过动态代理来实现的。-x3D-x3D-首先在传统的MVC框架中，业务层一般都夹带着数据库的事务管理，例如-x3D-x3D-插入一个角色，他是使用RoleService接口-的实现类RoleServiceImpl-去实现的。" class="headerlink" title="&#x3D;&#x3D;Spring AOP  是通过动态代理来实现的。&#x3D;&#x3D;首先在传统的MVC框架中，业务层一般都夹带着数据库的事务管理，例如&#x3D;&#x3D;插入一个角色，他是使用RoleService接口 的实现类RoleServiceImpl 去实现的。"></a>&#x3D;&#x3D;Spring AOP  是通过动态代理来实现的。&#x3D;&#x3D;首先在传统的MVC框架中，业务层一般都夹带着数据库的事务管理，例如&#x3D;&#x3D;插入一个角色，他是使用RoleService接口 的实现类RoleServiceImpl 去实现的。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005202851734.png" alt="image-20221005202851734"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005202938180.png" alt="image-20221005202938180"></p><ul><li><h4 id="原理剖析："><a href="#原理剖析：" class="headerlink" title="原理剖析："></a>原理剖析：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005203149056.png" alt="image-20221005203149056"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005203202308.png" alt="image-20221005203202308"></p><ul><li><h4 id="Spring-AOP在动态代理下运行的流程："><a href="#Spring-AOP在动态代理下运行的流程：" class="headerlink" title="Spring AOP在动态代理下运行的流程："></a>Spring AOP在动态代理下运行的流程：</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221005203338644.png" alt="image-20221005203338644"></p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/10/18/Docker/"/>
      <url>/2022/10/18/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="1-2-Docker-组件"><a href="#1-2-Docker-组件" class="headerlink" title="1.2 Docker 组件"></a>1.2 Docker 组件</h2><p>docker的核心组件</p><ul><li>Docker 客户端</li><li>Docker镜像</li><li>Registry</li><li>Docker 容器。</li></ul><h3 id="1-2-1-Docker-客户端和服务器"><a href="#1-2-1-Docker-客户端和服务器" class="headerlink" title="1.2.1 Docker 客户端和服务器"></a>1.2.1 Docker 客户端和服务器</h3><p>Docker是一个客户端-服务器(C&#x2F;S) 架构的程序，Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具docker以及一整套RESTful API。 可以在一同一台宿主机上运行Docker守护进程和客户端。也可以从本地的Docker 客户端连接到 运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221017211508572.png" alt="image-20221017211508572"></p><h3 id="1-2-2-Docker-镜像"><a href="#1-2-2-Docker-镜像" class="headerlink" title="1.2.2 Docker 镜像"></a>1.2.2 Docker 镜像</h3><p>镜像是构建Docker世界的基石，用户基于镜像来运行自己的容器。镜像也是Docker生命周期中“构建”部分。镜像是基于联合Union  文件系统的一种层式结构。由一系列指令一步一步构建出来的：</p><ul><li>添加一个文件。</li><li>执行一个命令</li><li>打开一个端口</li></ul><p>也可以把镜像当作容器中的“源代码” 镜像体积很小，非常便携。易于分享和更新，</p><h3 id="1-2-3-Registry"><a href="#1-2-3-Registry" class="headerlink" title="1.2.3 Registry"></a>1.2.3 Registry</h3><p>Docker 用Registry 来保存用户 构建的镜像， 分为公共和私有。</p><h3 id="1-2-4-容器"><a href="#1-2-4-容器" class="headerlink" title="1.2.4  容器"></a>1.2.4  容器</h3><p>Docker 可以帮你构建和部署容器。只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程，我们可以认为，镜像是Docker生命周期中的构建或打包阶段，则容器则是启动或执行阶段。</p><p>总结起来，Docker容器就是：</p><ul><li>一个镜像格式</li><li>一系列标准的操作</li><li>一个执行环境。</li></ul><h2 id="2，运行容器"><a href="#2，运行容器" class="headerlink" title="2，运行容器"></a>2，运行容器</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">sudo docker <span class="hljs-keyword">run</span><span class="language-bash"> -i -t ubuntu /bin/bash</span><br></code></pre></td></tr></table></figure><p>Docker 会在文件系统内部用这个系统创建了一个新容器，改容器拥有自己爹网络，IP地址，以及一个用来和宿主机进行通信的桥接网络接口。最后我们告诉Docker在新容器运行什么命令，在本例中我们在容器中运行 &#x2F;bin&#x2F;bash 命令 启动了一个  bash shell。</p><h3 id="2-1-使用第一个容器"><a href="#2-1-使用第一个容器" class="headerlink" title="2.1 使用第一个容器"></a>2.1 使用第一个容器</h3><p>通过前面的操作，我们以root身份登陆到了新容器中，容器ID为 cfdc1577281c          这是一个完整的Ubuntu系统。你可以用它来做任何事情。</p><p>可以获取该容器的主机名：  hostname；即上面的容器id。</p><ul><li>再来看看  &#x2F;etc&#x2F;hosts   文件  cat &#x2F;etc&#x2F;hosts</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1localhost<br>::1localhost ip6-localhost ip6-loopback<br>fe00::0ip6-localnet<br>ff00::0ip6-mcastprefix<br>ff02::1ip6-allnodes<br>ff02::2ip6-allrouters<br>172.17.0.2cfdc1577281c<br><br></code></pre></td></tr></table></figure><p>可以看到最后一条就是docker在hosts文件中为该容器的Ip地址添加了一条主机配置项。</p><ul><li><p>再来看看容器的网络情况。 ip a? command not found  </p></li><li><p>看看容器中的进程   ps -aux</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root           1  0.0  0.0   4628  3732 pts/0    Ss   14:15   0:00 /bin/bash<br>root          19  0.0  0.0   7060  1560 pts/0    R+   14:22   0:00 ps -aux<br></code></pre></td></tr></table></figure><ul><li>在容器中安装软件包  apt-get  update &amp;&amp; apt-get install vim</li></ul><p>执行上述命令我们就在容器中安装了vim。然后就可以在容器中做自己想做的事情。</p><ul><li>最后 输入exit 就可以返回到Ubuntu宿主机的命令行提示符了。一旦推出，&#x2F;bin&#x2F;bash命令也就结束了。 这是容器也随之停止运行。但是容器依然是存在的，我们可以通过 docker ps -a 查看当前容器的列表。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">CONTAINER ID   IMAGE              COMMAND       CREATED          STATUS                        PORTS     NAMES<br>cfdc1577281c   ubuntu             <span class="hljs-string">&quot;/bin/bash&quot;</span>   13 minutes ago   Exited (0) 8 seconds ago                sad_solomon<br>e3512f80e97d   chenyy/la32r-<span class="hljs-built_in">env</span>   <span class="hljs-string">&quot;bash&quot;</span>        13 days ago      Exited (255) 24 minutes ago             la32r-docker<br><br></code></pre></td></tr></table></figure><ul><li>当执行 docker ps 命令时，只能看到正在运行的容器，指定 -a  标志 则docker会列出所有的容器。包括正在运行和停止的。</li></ul><h3 id="2-2-容器命名"><a href="#2-2-容器命名" class="headerlink" title="2.2  容器命名"></a>2.2  容器命名</h3><ul><li>Docker 会为我们创建的每一个容器自动生成一个随机的名称，例如，上面容器中的Ubuntu的 id。 如果想指定一个名称，而不是使用自动生成的名称，则可以用  –name 标志来实现。 </li><li>例如：<ul><li>sudo docker run –name bob_the_container -i -t ubuntu &#x2F;bin&#x2F;bash </li><li>该命令会创建一个你命名的容器。</li></ul></li><li>在很多docker命令中，我们都可以用容器名称来代替容器ID。容器的名称有助于分别容器，当构建容器间和应用程序之间的逻辑连接时，容器的名称也会有助于从逻辑上理解连接关系。 注意，容器的名称必须是唯一的。 当存在重复名时，可以用 docker rm 命令 删除已有的同名容器，再来创建。</li></ul><h3 id="2-3-重新启动已经停止的容器"><a href="#2-3-重新启动已经停止的容器" class="headerlink" title="2.3   重新启动已经停止的容器"></a>2.3   重新启动已经停止的容器</h3><ul><li><p>可以通过指定名称来 启动 docker start bob_the_container</p></li><li><p>也可以通过指定ID 来启动。docker  start a32b46b5e55d</p></li><li><p>通过 docker ps  查看 容器是否开始运行。</p></li></ul><p>Docker 容器重新启动时，会沿用docker run 命令时指定的参数来运行，因此我们重新启动后 会运行一个交互式会话shell，此外我们可以 用 docker attach 命令，重新附着到该容器的绘画上。</p><ul><li><p>sudo docker attach bob_the_container  or  sudo docker attach ID</p></li><li><p>exit 退出容器 的 同时，容器也会随之停止。</p></li></ul><h3 id="2-4-创建守护式容器"><a href="#2-4-创建守护式容器" class="headerlink" title="2.4   创建守护式容器"></a>2.4   创建守护式容器</h3><ul><li>守护式容器 没有交互式会话，非常适合运行应用程序和服务。</li><li>下面就来启动一个  sudo docker run –name daemon_dave -d ubuntu &#x2F;bin&#x2F;bash -c  “while true; do echo hello world; sleep 1; done”</li><li>我们在上面的 docker run  命令使用了  -d 参数，因此Docker会将容器放在后台运行。并且定义了一个死循环，让他运行时一直不停地打印指定字符串。</li><li>docker run 命令并没有像上一个容器一样将主机地控制台 附着到新的shell 会话上，仅仅返回一个ID。</li></ul><h3 id="2-5-容器内部都在干什么"><a href="#2-5-容器内部都在干什么" class="headerlink" title="2.5   容器内部都在干什么"></a>2.5   容器内部都在干什么</h3><ul><li>前面我们创建了一个后台的守护式容器，可以 通过  dcoker logs daemon_dave 来获取容器的日志。</li><li>我们也可以用 -f 参数来监控Docker 的 日志。ctrl+c  退出。为了让测试更简单，可以使用 -t 标志为每条日志加上时间戳。</li></ul><h3 id="2-6-查看容器的进程"><a href="#2-6-查看容器的进程" class="headerlink" title="2.6 查看容器的进程"></a>2.6 查看容器的进程</h3><ul><li>除了容器的日志，我们也可以查看容器内部的进程，这需要用到 docker top 命令。  sudo docker top  docker_name ;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">UID PID PPID C STIME TTY TIME CMD<br>root 5626 5601 0 07:49 ? 00:00:00 /bin/bash -c while true; do echo hello world; sleep 1; done<br>root 5952 5626 0 07:53 ? 00:00:00 sleep 1<br></code></pre></td></tr></table></figure><h3 id="2-7-在容器内部运行进程"><a href="#2-7-在容器内部运行进程" class="headerlink" title="2.7 在容器内部运行进程"></a>2.7 在容器内部运行进程</h3><ul><li>我们可以通过  docker exex  命令在容器内部额外启动新进程，可以在容器内运行的进程分为：后台任务和交互式任务。</li></ul><h3 id="2-8-停止守护式容器"><a href="#2-8-停止守护式容器" class="headerlink" title="2.8  停止守护式容器"></a>2.8  停止守护式容器</h3><p>要停止守护式容器，只需要执行命令 docker stop 命令。可以指定名称，也可以指定 ID。如果想快速停止某个容器，也可以使用 docker kill 来发容器进程发送sigkill信号。</p><ul><li>docker ps -n x  该命令会显示最后 x个容器。</li></ul><h3 id="2-9-自动重启容器"><a href="#2-9-自动重启容器" class="headerlink" title="2.9  自动重启容器"></a>2.9  自动重启容器</h3><ul><li>–restart 标志。 on- failure 命令。这样只有容器代码非0时，才会自动重启。</li></ul><h3 id="2-10-深入容器"><a href="#2-10-深入容器" class="headerlink" title="2.10  深入容器"></a>2.10  深入容器</h3><ul><li>除了通过docker ps 命令获取容器信息，还可以通过 docker inspect 来获取更多容器信息。</li><li>docker inspect 挥动容器进行详细的检查，然后返回配置信息，包括 名称，命令，网络配置以及很多有用的信息。 </li><li>也可以通过  -f 或者 -format 标志来选定查看结果。</li></ul><h3 id="2-11-删除容器"><a href="#2-11-删除容器" class="headerlink" title="2.11   删除容器"></a>2.11   删除容器</h3><ul><li><p>如果容器已经不再使用了，可以通过  docker rm 命令来删除它们。</p></li><li><p>值得注意的是，正在运行的容器是无法删除的。需要先停止它： docker stop or  docker kill 。</p></li><li><p>删除所用容器： 慎操：  docker rm ‘docker ps -a -q’ 。  实际就是 返回所有的docker id 然后传递给 docker rm 命令 达成删除。</p></li><li><p>docker rm -f  ： 强制删除容器。</p></li><li><p>docker  rmi   删除镜像。  </p></li><li><p>docker  rmi  -f   强制删除 镜像。</p></li></ul><h2 id="3-，使用Docker镜像和仓库"><a href="#3-，使用Docker镜像和仓库" class="headerlink" title="3 ，使用Docker镜像和仓库"></a>3 ，使用Docker镜像和仓库</h2><h3 id="3-1-什么是Docker-镜像"><a href="#3-1-什么是Docker-镜像" class="headerlink" title="3.1 什么是Docker 镜像"></a>3.1 什么是Docker 镜像</h3><p>Docker 镜像是由文件系统叠加而成的。最底端是一个引导文件系统即 bootfs</p><p><img src="https://img-blog.csdnimg.cn/1fefc973a18944a58b73b0dc6eaf8757.png#pic_center" alt="docker镜像原理"></p><h3 id="3-2-列出镜像"><a href="#3-2-列出镜像" class="headerlink" title="3.2  列出镜像"></a>3.2  列出镜像</h3><ul><li><p>可以使用docker images 命令 来查看所有的镜像列表。镜像从仓库下载而来，镜像保存在仓库里，而仓库存在于Registry中。即Docker HUb</p></li><li><p>可以通过  docker pull  来拉取 ubuntu中的所有内容，。我们可以在仓库名字后面加上一个冒号和标签名来指定仓库中的某一镜像。</p></li><li><p>例如：sudo docker run -t -i –name new_container ubuntu : 12.04 &#x2F;bin&#x2F;bash 。会从镜像ubuntu ：12.04 启动一个容器，而这个镜像的操作系统的 ubuntu 12.04.</p></li><li><p>在构建容器时指定标签 可以更准确地来指定容器来源。不同的标签镜像会有不同。</p></li></ul><h3 id="3-3-拉取镜像"><a href="#3-3-拉取镜像" class="headerlink" title="3.3    拉取镜像"></a>3.3    拉取镜像</h3><ul><li>用 docker run 命令 从镜像启动一个容器时，如果该镜像不在本地，Docker 会先从Docker Hub 下载该镜像。如果没有指定具体的镜像标签，那么Docker 会自动下载 最新地标签镜像。如果本地还没有 ubuntu :latest  那么将会下载下来。</li><li>也可以通过 docker pull  命令来自己先预先拉取镜像到本地。 使用 docker pull  可以节省从一个新镜像启动一个容器地时间。</li><li>如 sudo docker pull  fedora：latest</li></ul><h3 id="3-4-查找镜像"><a href="#3-4-查找镜像" class="headerlink" title="3.4  查找镜像"></a>3.4  查找镜像</h3><p>可以通过docker search 命令来查找所有 Docker Hub 上 公共可用地镜像。</p><p>如  docker search mysql 。  也可以在官网  在线查找。</p><ul><li>在上面拉取一个镜像： sudo docker pull jamtur01&#x2F;puppetmaster  </li><li>接着就可以用这个构建一个容器了： sudo docker run -i -t jamtur01&#x2F;puppetmaster &#x2F;bin&#x2F;bash </li><li>然后就以交互式的方式启动了该容器，并且在里面运行了 Bash Shell。在进入容器shell 之后，我们运行了Facter（Puppet的主机探测应用）。</li></ul><h3 id="3-5-构建镜像"><a href="#3-5-构建镜像" class="headerlink" title="3.5  构建镜像"></a>3.5  构建镜像</h3><ul><li>前面我们已经学会了如何拉取已经构建好的带有定制内容的Docker 镜像。那么人如何修改我们自己的镜像呢，并且更新和管理这些镜像呢，由两种方法：</li><li>docker commit 命令。</li><li>docker build命令和 Dockerfile 文件。</li></ul><p>现在不推荐使用docker commit 命令，而是应该使用 更加强大灵活的  Dockerfile 来构建Docker 镜像。我们可以先了解以下 docker commit  构建镜像。重点掌握Docker 推荐的镜像构建方法：  编写Dockerfile 之后 使用 docker build 命令。</p><h4 id="3-5-1-创建-Docker-Hub-账号"><a href="#3-5-1-创建-Docker-Hub-账号" class="headerlink" title="3.5.1   创建 Docker Hub  账号"></a>3.5.1   创建 Docker Hub  账号</h4><ul><li>为了成功构建镜像，需要先创建一个 Docker Hub 账号</li><li>有了帐号之后，要登录到Docker Hub 可以使用 docker login 命令。</li></ul><h4 id="3-5-2-用docker-的-commit-命令创建镜像"><a href="#3-5-2-用docker-的-commit-命令创建镜像" class="headerlink" title="3.5.2  用docker 的 commit 命令创建镜像"></a>3.5.2  用docker 的 commit 命令创建镜像</h4><ul><li>先从创建一个新容器开始。 sudo docker run -i -t ubuntu &#x2F;etc&#x2F;bash </li><li>然后在容器中安装 Apache 。  apt-get  -y  install apache: latest </li><li>我们想把当前状态保存下来，这样就不必每次都创建一个新容器并每次在里面安装apache了。</li><li>我们需要先从容器中退出。  exit ，然后再运行 docker commit 命令。</li><li>可以通过  docker ps -l -q 命令得到刚刚创建的容器的ID。 然后运行</li><li>sudo docker commit ID  用户&#x2F;镜像。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REPOSITORY         TAG       IMAGE ID       CREATED         SIZE<br>ovesh/apache2      latest    3986c6c3561e   4 seconds ago   115MB<br>&lt;none&gt;             &lt;none&gt;    e340e2bedb79   2 minutes ago   115MB<br>ubuntu             latest    216c552ea5ba   12 days ago     77.8MB<br>chenyy/la32r-env   latest    e09b3e81a0ab   6 weeks ago     1.04GB<br>hello-world        latest    feb5d9fea6a5   12 months ago   13.3kB<br><br></code></pre></td></tr></table></figure><ul><li>可以看到创建成功了。</li><li>然后可以从刚创建的镜像运行一个容器，可以使用docker run 命令。</li><li>如 sudo docker run -t -i ovesh&#x2F;apache :webserver &#x2F;bin&#x2F;bash   使用了完整标签来指定镜像。</li></ul><h4 id="3-5-3-用Dockerfile-构建镜像"><a href="#3-5-3-用Dockerfile-构建镜像" class="headerlink" title="3.5.3  用Dockerfile 构建镜像"></a>3.5.3  用Dockerfile 构建镜像</h4><p>并不推荐使用 docker commit 的方法来构建镜像，相反，推荐使用称为Dockerfile 的定义文件和 docker build 命令来构建镜像。Dockerfile 使用基本的基于DSL语法的指令来构建一个Docker 镜像。之后使用 docker build 命令基于该Dockerfile 中的指令构建一个新的镜像，</p><ul><li>我们的第一个Dockerfile</li></ul><p>创建一个目录并在里面创建初始的Dockerfile。我们将创建一的简单的Web 服务器的镜像。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir static_web<br>cd static_web<br>touch Dockerfile<br></code></pre></td></tr></table></figure><ol><li>我们创建了一个名为static_web 的目录来保存Dockerfile，这个目录就是我们的构建环境(build environment). Docker 称此环境为上下文或者构建上下文。Docker会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker守护进程。这样Docker守护进程就能直接访问你想在镜像中存储的任何代码，文件或者其他数据。</li><li>刚刚我们创建的是空的Dockerfile。下面通过例子看看如何通过Dockerfile构建一个Web服务器的Docker 镜像。</li></ol><ul><li>Dockerfile 由一系列指令和参数组成，每条指令如FROM，都必须为大写字母，且后面要跟随一个参数: FROM ubuntu:20.04 . Dockerfile 中的指令会按顺序从上到下执行，所有应该根据需要合理安排指令的顺序。</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交。Docker 大体上按照如下流程执行Dockerfile 中的指令：<ul><li>Docker 从基础镜像运行一个容器。</li><li>执行一条指令，对容器进行修改。</li><li>执行类似docker commit 的操作，提交一个新的镜像层。</li><li>Docker 再基于刚提交的镜像运行一个新容器。</li><li>执行Dockerfile 中的下一条指令，知道所有指令都执行完毕。</li></ul></li></ul><ol><li>每个Dockerfile 的第一条指令都应该是FROM。FROM指令指定一个已经存在的镜像。后续的指令都是基础该镜像进行，这个镜像称为基础镜像(base image)。</li><li>在运行一个容器时，必须指明是要基于哪个基础镜像在构建。</li><li>接着指定了 MAINTAINER 指令，这条指令会告诉Docker 该镜像的作者是谁。以及作者的电子邮件地址，这有助于标识镜像的所有者和联系方式。</li><li>在这些的指令之后，我们指定了三条Run指令。Run指令会在当前镜像中运行指定的命令。如 更新apt 仓库，然后安装 指定的包，创建某种文件等。每条RUN指令都会创建一个新的镜像层，如果该指令执行成功，就会将次镜像层提交。之后继续执行Dockerfile 中的 下一条指令。</li><li>默认情况下，RUN指令会在shell 里面使用 命令包装器 &#x2F;bin&#x2F;sh -c 来执行。在一个不支持shell 平台上或者不想使用shell 来运行，可以通过使用 exec 格式的RUN指令。如 RUN[“apt-get”,”install”,”-y”,”nginx”]。 这种方式，我们需要使用一个数组来指定运行的命令和传递给该参数的每个参数。</li></ol><h4 id="3-5-4-基于Dockerfile-构建新镜像"><a href="#3-5-4-基于Dockerfile-构建新镜像" class="headerlink" title="3.5.4  基于Dockerfile  构建新镜像"></a>3.5.4  基于Dockerfile  构建新镜像</h4><p>看看如何构建一个新镜像。</p><ol><li>我们使用了 docker build 命令来构建新镜像。通过指定 -t 选项为新镜像设置了仓库和名称。</li><li>sudo docker build -t&#x3D;”ovesh&#x2F;static_web:v1” . </li><li>上面的命令告诉Docker 去本地目录去找Dockerfile 文件 。 也可以指定一个git 仓库的源地址来指定Dockerfile的位置。sudo docker build -t&#x3D;”ovesh&#x2F;static_web:v1”  <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>:someone&#x2F;somedir.</li><li>如果指令写错了，就需要用 docker run 命令 来基础 失败的代码构建一个容器。</li><li>然后在容器中执行正确的操作。并指定包名。结束操作后退出，使用正确的包名修改Dockerfil而文件。之后再尝试进行构建。</li></ol><h4 id="3-5-5-Dockerfile-和构建缓存"><a href="#3-5-5-Dockerfile-和构建缓存" class="headerlink" title="3.5.5  Dockerfile  和构建缓存"></a>3.5.5  Dockerfile  和构建缓存</h4><p>Docker会将之前构建时创建的镜像当做缓存并作为新的开始点。</p><ul><li>忽略Dockerfile 的构建缓存。<ul><li>sudo docker build –no-cahe -t&#x3D;”ovesh&#x2F;static_web” .</li></ul></li></ul><h4 id="3-5-7-基于构建缓存的Dockerfile-模板"><a href="#3-5-7-基于构建缓存的Dockerfile-模板" class="headerlink" title="3.5.7   基于构建缓存的Dockerfile 模板"></a>3.5.7   基于构建缓存的Dockerfile 模板</h4><p>构建缓存带来的一个好处就是，我们可以实现简单的Dockerfile 模板(比如在Dockerfile 文件顶部增加包仓库或者更新包，从而尽可能确保缓存命中。)。</p><ul><li>使用 指令 ENV来在镜像中设置环境变量。可以用来表示该镜像模板最后的更新时间。</li><li>有了模板，如果想刷新一个构建，只需要修改ENV 指令中的日期。这使Docker 在命令中 ENV指令时开始重置这个缓存。并运行后续指令而无需依赖该缓存。也就是说，后面的指令会被再次执行。包缓存也将会被刷新为最新内容。</li><li>例如下面的 fedora Dockerfile 模板。</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">FROM</span>: fedora:<span class="hljs-number">20</span><br><span class="hljs-keyword">MAINTAINER</span> Ovesh <span class="hljs-string">&quot;Oveshh.github.io&quot;</span><br><span class="hljs-keyword">ENV</span> REFRESHED_AT_ <span class="hljs-number">2022</span>-<span class="hljs-number">10</span>-<span class="hljs-number">18</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yun -y -q upgrade</span><br></code></pre></td></tr></table></figure><h4 id="3-5-8-查看新镜像"><a href="#3-5-8-查看新镜像" class="headerlink" title="3.5.8  查看新镜像"></a>3.5.8  查看新镜像</h4><p>查看新镜像。</p><ul><li>sudo docker images ovesh&#x2F;static_web</li></ul><h4 id="3-5-9-从新镜像启动容器"><a href="#3-5-9-从新镜像启动容器" class="headerlink" title="3.5.9    从新镜像启动容器"></a>3.5.9    从新镜像启动容器</h4><p>我们也基于新构建的镜像 启动一个新容器。</p><ul><li><p>sudo docker run - d -p 80 –name static_web ovesh&#x2F;static_web nginx -g “daemon off ;”  </p></li><li><p>-d :  告诉Docker 以分离的方式在后台运行。  </p></li><li><p>nginx -g “daemon off ;” 将以前台运行的方式来启动Nginx 。作为我们的Web服务器。</p></li><li><p>-p : 该标志用来控制Docker 在运行时间时英高公开哪些网络端口给外部(宿主机)。运行一个容器时，Docker 可以通过两种方法来在宿主机上分配端口。</p><ul><li>Docker可以在宿主机上选择一个位于  49153 ~ 65535 的一个比较大的端口号来映射到容器的 80端口上。</li><li>可以在Docker 宿主机上指定一个具体的端口号来映射到容器中的80端口上。这将在Docker 宿主机上随即打开一个端口，这个端口会连接到然容器中的80端口。</li></ul></li><li><p>可以通过 sudo docker ps -l   来查看Docker 端口映射情况。 </p></li><li><p>可以使用 docker port  来查看容器的端口映射情况。</p></li><li><p>sudo docker port ID  80. 该命令返回的是宿主机中映射的端口。</p></li><li><p>通过 -p 选项 映射到特定端口。</p></li><li><p>sudo docker run -d -p 80:80 –name static_web ovesh&#x2F;static_web nginx -g “daemon off’;”  </p></li><li><p>上面的命令会将容器内的80端口绑定到本地宿主机的80端口上，我们需要谨慎使用这种绑定做法。：如果运行多个容器，之只有一个容器能成功绑定到 本地宿主机上，这将会限制 Docker 的灵活性。</p></li><li><p>绑定到特定的网络端口 ： </p></li><li><p>sudo docker run -d -p 127.0.0.1:80:80  –name ………;</p></li><li><p>绑定到特定的网络接口的随机端口：</p></li><li><p>sudo docker run -d -l 127.0.0.1: :80 – name 。。。。。。。。。。; </p></li><li><p>上面，我们并没有指明具体的宿主机上的端口号，知识指定了一个IP地址127.0.0.1 .。</p></li><li><p>这时候可以 通过 docker inspect 或者 docker port 命令来查看 80 端口 具体被绑定到了宿主机的哪个端口上。</p></li></ul><h3 id="3-6-将镜像推送到-Docker-Hub"><a href="#3-6-将镜像推送到-Docker-Hub" class="headerlink" title="3.6 将镜像推送到 Docker Hub"></a>3.6 将镜像推送到 Docker Hub</h3><h3 id="3-7-删除镜像"><a href="#3-7-删除镜像" class="headerlink" title="3.7  删除镜像"></a>3.7  删除镜像</h3><h3 id="3-8-运行自己的Docker-Registry"><a href="#3-8-运行自己的Docker-Registry" class="headerlink" title="3.8  运行自己的Docker Registry"></a>3.8  运行自己的Docker Registry</h3>]]></content>
      
      
      <categories>
          
          <category> Docker基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试</title>
      <link href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络面试"><a href="#计算机网络面试" class="headerlink" title="计算机网络面试"></a>计算机网络面试</h1><h2 id="1-HTTP-响应码有哪些？分别代表什么意义？"><a href="#1-HTTP-响应码有哪些？分别代表什么意义？" class="headerlink" title="1, HTTP 响应码有哪些？分别代表什么意义？"></a>1, HTTP 响应码有哪些？分别代表什么意义？</h2><ol><li>200:成功，web服务器成功处理客户端的请求。</li><li>301：永久重定向，当客户端请求一个网址时，Web服务器会将当前请求定向到另一个网址，搜索引擎会抓取重定向网页的内容并将旧的网址替换为重定向后的网址。</li><li>302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎默认为重定向后的地址是暂时的。</li><li>400：客户端请求错误，多为参数不合法导致Web服务器验证参数失败。</li><li>404：not found 未找到， Web服务器找不到资源。</li><li>500： Web服务器错误，服务器处理客户端请求时发生错误。</li><li>503：服务不可用，服务器停机</li><li>504：网关超时。</li></ol><h2 id="2，Forward-和-Redirect-的区别？"><a href="#2，Forward-和-Redirect-的区别？" class="headerlink" title="2，Forward 和 Redirect 的区别？"></a>2，Forward 和 Redirect 的区别？</h2><ol><li>浏览URL地址：Forward是服务器内部重定向的，服务器内部请求某个servlet，然后获取响应的内容，浏览器的URL地址是不会变化的，Redirect是客户端请求服务器，然后服务器给客户端返回了一个302状态码和新的location，客户端重新发起HTTP请求，服务器给客户端的location 对应的URL地址，浏览器的URL地址发生了变化。</li><li>数据的共享： Forward 是服务器内部的重定向，request 在整个重定向过程中是不变的，request 中的信息在servlet间是共享的，Redirect发起了两次HTTP请求，分别使用不同的request。</li><li>请求的次数：  forward 只有一次， request 有两次请求。</li></ol><h2 id="3，get-和-post-的-区别？"><a href="#3，get-和-post-的-区别？" class="headerlink" title="3，get 和 post 的 区别？"></a>3，get 和 post 的 区别？</h2><p>用途：</p><ul><li>get 请求用于从服务器获取资源</li><li>post 请求用于从服务器获取资源</li></ul><p>表单的提交方式：</p><ul><li>get请求直接将表单数据以 name1&#x3D;value1&amp;name2&#x3D;value2 的形式拼接到URL上(如 <a href="https://www.baidu.com/action?name1=value&amp;name2=value2)%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E5%92%8C%E5%8F%82%E6%95%B0%E5%80%BC%E9%9C%80%E8%A6%81%E7%94%A8&amp;%E8%BF%9E%E6%8E%A5%E5%B9%B6%E4%B8%94%E7%94%A8%EF%BC%9F%E6%8B%BC%E6%8E%A5%E5%88%B0">https://www.baidu.com/action?name1=value&amp;name2=value2)多个参数和参数值需要用&amp;连接并且用？拼接到</a> action后面。</li><li>post请求将表单数据放到请求头或者请求的消息体中。</li></ul><p>传输数据的大小限制：</p><ul><li>get请求传输的数据受到URL长度的限制，而URL长度是由浏览器决定的。</li><li>post请求传输数据大小理论上来说是没有限制的。</li></ul><p>参数的编码：</p><ul><li>get请求的参数回在地址栏明文显示，使用URL编码的文本格式传输参数。</li><li>post请求使用二进制数据多重编码传递参数。</li></ul><p>缓存：</p><ul><li>get请求可以被浏览器缓存并收藏为标签</li><li>post请求不会被缓存也不会被收藏为标签。</li></ul><h2 id="4，说说TCP与UDP的区别，以及各自的优缺点。"><a href="#4，说说TCP与UDP的区别，以及各自的优缺点。" class="headerlink" title="4，说说TCP与UDP的区别，以及各自的优缺点。"></a>4，说说TCP与UDP的区别，以及各自的优缺点。</h2><ol><li>TCP面向连接(如打电话需要先拨号简历连接)；UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供的是可靠的服务，也就是说，通过TCP连接传输的数据，无差错，不丢失，不重复，且按序到达；UDP则是尽最大努力交付，即不保证可靠交付；TCP通过校验和，重传控制，序号标识，滑动窗口，确认应答实现可靠传输。如丢失包的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或者广播通信。</li><li>每一条TCP连接只能是点到点；UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ol><h2 id="5，-说一下HTTP和HTTPS-的区别。"><a href="#5，-说一下HTTP和HTTPS-的区别。" class="headerlink" title="5， 说一下HTTP和HTTPS 的区别。"></a>5， 说一下HTTP和HTTPS 的区别。</h2><ol><li>端口不同： HTTP和HTTPS 的连接方式不用，用的端口也不一样，HTTP是80端口，HTTPS是443端口。</li><li>消耗资源：和HTTP相比，HTTPS 通信会因为加密的处理消耗更多的CPU和内存资源。</li><li>开销：HTTPS通信需要 证书，这类整数通常需要向机构申请或者付费购买。</li></ol><h2 id="6，说说HTTP-，TCP，Socket-的关系是什么？"><a href="#6，说说HTTP-，TCP，Socket-的关系是什么？" class="headerlink" title="6，说说HTTP ，TCP，Socket 的关系是什么？"></a>6，说说HTTP ，TCP，Socket 的关系是什么？</h2><ol><li>TCP&#x2F;IP代表 传输控制协议&#x2F;网际协议，指的是一系列协议簇。</li><li>HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传输协议。</li><li>Socket是TCP&#x2F;IP网络的API，其实就是一个门面模式，他把复杂的TCP&#x2F;IP协议簇隐藏在Socket 接口后面, 对用户来说，一组简单的接口就是全部，让Socket去组织数据。以符合指定的协议。</li></ol><p>综上所述：</p><ol><li>需要IP协议来连接网络。</li><li>TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的协议。</li><li>HTTP是基于TCP协议的，所以可以使用Socket去建立一个TCP连接。</li></ol><h2 id="7，说说HTTP的-长连接和短链接的区别"><a href="#7，说说HTTP的-长连接和短链接的区别" class="headerlink" title="7，说说HTTP的 长连接和短链接的区别"></a>7，说说HTTP的 长连接和短链接的区别</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短链接。</p><p>短链接：</p><p>在HTTP&#x2F;1.0 中默认使用短连接，也就是说，浏览器每和服务器进行一次操作就需要建立一次连接。每当任务结束就会中断连接，如果客户端访问的是某个HTML或者其他类型的Web资源，如JS文件，图像文件，CSS文件，当浏览器没遇到这样一个Web资源，就会建立一个HTTP会话。</p><p>长连接：</p><p>从HTTP&#x2F;1.1 起。默认使用长连接，用以保持连接特性，在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。如果客户端再次访问这个服务器上的网页，会使用这一条已经建立的连接，Keep-Alive不会永久保持连接，他有一个保持时间，可以在不同的服务器软件如(Apache)中设定这个时间。</p><h2 id="8，TCP-为什么要三次握手，两次不行吗，为什么？"><a href="#8，TCP-为什么要三次握手，两次不行吗，为什么？" class="headerlink" title="8，TCP 为什么要三次握手，两次不行吗，为什么？"></a>8，TCP 为什么要三次握手，两次不行吗，为什么？</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试</title>
      <link href="/2022/10/16/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/10/16/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-面试篇"><a href="#Redis-面试篇" class="headerlink" title="Redis  面试篇"></a>Redis  面试篇</h1><h2 id="1，为什么要用缓存？"><a href="#1，为什么要用缓存？" class="headerlink" title="1，为什么要用缓存？"></a>1，为什么要用缓存？</h2><p>使用缓存的目的就是提高读写性能，而实际业务场景下，更多的是为了提升性能，带来更好的性能，带来更高的并发量，Redis的读写性能比MySQL更好，我们就可以把MySQL中的热点数据缓存到Redis中，提升读取性能，同时也减轻了MySQL的压力。</p><h2 id="2，使用Redis有哪些好处？"><a href="#2，使用Redis有哪些好处？" class="headerlink" title="2，使用Redis有哪些好处？"></a>2，使用Redis有哪些好处？</h2><p>具有以下好处：</p><ol><li>读取速度快，因为数据在内存中。</li><li>支持多种数据结构，包括字符串，列表，集合，有序集合，哈希等。</li><li>支持事务，并且操作遵守原子性，即对数据的操作要么执行成功，要么都不支持。</li><li>还拥有其他丰富的功能：队列，集群，数据持久化等功能。</li></ol><h2 id="3，什么是Redis？"><a href="#3，什么是Redis？" class="headerlink" title="3，什么是Redis？"></a>3，什么是Redis？</h2><p>Redis是一个开源，基于内存，支持多种数据结构的存储系统，可以作为数据库，缓存和消息中间件。他支持的数据结构有：字符串，哈希，集合，有序集合，列表。除此之外还有支持 bitmaps，hyperloglogs  和 地理空间(geospatial) 索引半径插叙等功能。</p><h2 id="4，为什么使用Redis而不是Memcache呢？"><a href="#4，为什么使用Redis而不是Memcache呢？" class="headerlink" title="4，为什么使用Redis而不是Memcache呢？"></a>4，为什么使用Redis而不是Memcache呢？</h2><p>Redis 和 Memcache 的区别?</p><ol><li>Redis支持数据持久化，服务器挂了之后数据还保留在磁盘中。</li><li>Redis 的单个Vlue 更大。</li><li>Redis支持更复杂类型的数据结构</li><li>分布式集群：Redis可以一主多从，也可以一主一从。</li><li>Redis数据丢失了可以通过aof恢复。</li><li>Redis 使用单线程的IO服用模型，自己封装了一个AeEvent时间处理框架，主要实现epoll，kqueue，更接近于Apache早期的模式。</li></ol><h2 id="5，为什么Redis单线程模型效率也那么高？"><a href="#5，为什么Redis单线程模型效率也那么高？" class="headerlink" title="5，为什么Redis单线程模型效率也那么高？"></a>5，为什么Redis单线程模型效率也那么高？</h2><ol><li>C语言实现，效率高。</li><li>纯内存操作。</li><li>基于非阻塞的IO复用模型机制</li><li>单线程的话就能避免多线程的频繁上下文切换。</li><li>丰富的数据结构：（全程采用hah结构，读取速度非常快，对数据结构进行了一些优化，比如压缩列表，跳表）。</li></ol><h2 id="6，说说Redis的线程模型"><a href="#6，说说Redis的线程模型" class="headerlink" title="6，说说Redis的线程模型"></a>6，说说Redis的线程模型</h2><p>Redis内部使用文件时间处理器 file event handler，这个文件事件处理器是单线程的，所以Redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个 socket，根据socket上的事件选择对应的时间处理器进行处理。</p><ol><li>文件事件处理器的结构包含4个部分：<ol><li>多个socket</li><li>IO多路复用程序</li><li>文件事件分派器</li><li>事件处理器</li></ol></li></ol><h2 id="7，为什么Redis需要把所有数据放到内存中？"><a href="#7，为什么Redis需要把所有数据放到内存中？" class="headerlink" title="7，为什么Redis需要把所有数据放到内存中？"></a>7，为什么Redis需要把所有数据放到内存中？</h2><p>Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在磁盘中，磁盘I&#x2F;O 会严重影响Redis的性能，而且Redis还提供了数据持久化功能。不用担心服务器重启对内存中数据的影响，其次现在硬件越来越便宜的情况下，Redis使用也越来越多。使他有很大的优势。</p><h2 id="8，Redis的同步机制了解？"><a href="#8，Redis的同步机制了解？" class="headerlink" title="8，Redis的同步机制了解？"></a>8，Redis的同步机制了解？</h2><p>Redis支持主从同步，从从同步，如果是第一次进行主从同步，主节点需要使用bgsave命令，再将后续修改操作记录到内存的缓冲区，等RDB文件全部同步到复制节点，复制节点接受完成后RDB镜像记载到内存中，等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p><h2 id="9，pipeline有什么好处，为什么要使用pipeline？"><a href="#9，pipeline有什么好处，为什么要使用pipeline？" class="headerlink" title="9，pipeline有什么好处，为什么要使用pipeline？"></a>9，pipeline有什么好处，为什么要使用pipeline？</h2><p>使用pipeline 管道 的好处是在于多次I&#x2F;O往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。</p><p>用pipeline的原因在于可以实现 请求&#x2F;相应服务器的功能，当客户端尚未读取旧响应时，它也可以处理新的请求，如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需要最后一步从服务端读取回复即可。</p><h2 id="10，-说一下Redis有什么优点和缺点"><a href="#10，-说一下Redis有什么优点和缺点" class="headerlink" title="10， 说一下Redis有什么优点和缺点"></a>10， 说一下Redis有什么优点和缺点</h2><p>优点：</p><ol><li>速度快：因为数据都在内存中，类似于hashmap，hashmap的优势就是查找和操作的时间复杂度都是O（1）。</li><li>支持丰富的数据结构，支持String,List,Set,Sorted Set,Hash 五种基础的数据结构。</li><li>支持持久化存储：Redis 提供RDB和AOF两种数据的持久化存储方法，解决内存数据库最担心的问题。(Redis 挂了，数据可以恢复不会丢失)。</li><li>高可用：内置 Redis sentinel ，提供高可用方案，实现主从故障自动转移，内置Redis Cluster。提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模。</li><li>丰富的特性：key 过期，计数，分布式锁，消息队列，。</li></ol><p>缺点：</p><ol><li>由于Redis 是内存数据库，所以单台机器，存储的数据量，是跟机器本身内存大小有关。虽然Redis 本身有 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成RDB文件，并进行传输，会占用主机的CPU，并消耗现网的带宽。</li><li>修改配置文件，进行重启，将磁盘的数据加载进内存，时间比较久，在这个过程中，Redis不会提供服务。</li></ol><h2 id="11，Redis-缓存刷新策略有哪些？"><a href="#11，Redis-缓存刷新策略有哪些？" class="headerlink" title="11，Redis 缓存刷新策略有哪些？"></a>11，Redis 缓存刷新策略有哪些？</h2><p>Redis 刷新策略？</p><ol><li>LRU&#x2F;LFU&#x2F;FOFO 算法剔除。：当Redis memory达到最大值的时候，首先关注的是过期的数据，通过删除策略达到保护内存的效果，这种方式只需要关注缓存的策略配置。不需要关心具体的每一个key到底是怎么过期的，每一个key到底是怎么样被剔除的。</li><li>超时剔除：设置过期时间。set ttl  。</li><li>主动更新：开发控制生命周期。</li></ol><h2 id="12，Redis-持久化有哪些？以及有什么区别？"><a href="#12，Redis-持久化有哪些？以及有什么区别？" class="headerlink" title="12，Redis 持久化有哪些？以及有什么区别？"></a>12，Redis 持久化有哪些？以及有什么区别？</h2><p>Redis 提供两种持久化方式： RDB和AOF 机制。</p><p>RDB持久化方式</p><ul><li>是指用数据集快照的方式半持久化模式记录 redis 数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次的持久化的文件，达到恢复。</li></ul><p>优点：</p><ol><li>只有一个文件 dump.rdb  ，方便持久化。</li><li>容错率高，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以IO最大化，使用单个子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能行。</li><li>相对于数据集时，比AOF的启动效率高。</li></ol><p>缺点：</p><p>数据安全性低，RDB间隔一段时间进行持久化，如果持久化之间Redis 发生故障，会发生数据丢失，所以这种方式更适合数据要求不严谨的时候。</p><p>AOF&#x3D; append only file。  持久化方式 </p><p>是指所i有的命令记录以Redis命令请求协议的格式完全持久化存储，保存为AOF文件。</p><p>优点：</p><ol><li>数据安全，AOF持久化可以配置appendfsync 属性，有always，每进行一次命令操作就记录到AOF文件中一次。</li><li>通过append 模式写文件，即使中途宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>aof 机制iderewrite 模式，AOF文件没被rewrite之气那（文件过大时会对命令进行合并重写），可以删除其中的某些命令，比如误操作的 flushall。</li></ol><p>缺点：</p><ol><li>AOF文件比RDB文件大，且恢复速度慢。</li><li>数据集大的时候，比RDB启动效率低。</li></ol><h2 id="13，持久化有两种，那应该怎么选择呢？"><a href="#13，持久化有两种，那应该怎么选择呢？" class="headerlink" title="13，持久化有两种，那应该怎么选择呢？"></a>13，持久化有两种，那应该怎么选择呢？</h2><ol><li>不要仅仅使用RDB，因为那样会导致你丢失很多数据。</li><li>也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备没有RDB做冷备的恢复速度快；第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制 的 bug。</li><li>Redis 支持同时开启两种持久化方式，我们可以综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用时，还可以使用RDB来快速的数据恢复。</li><li>如果同时使用这两种持久化机制，那么Redis在重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完善。</li></ol><h2 id="14，怎么使用Redis-实现消息队列？"><a href="#14，怎么使用Redis-实现消息队列？" class="headerlink" title="14，怎么使用Redis 实现消息队列？"></a>14，怎么使用Redis 实现消息队列？</h2><p>一般使用list 结构作为队列，rpush 生产消息，lpop消费消息，挡lpop没有消息时，要适当的sleep一会再重试。</p><p>Redis 如何实现延时队列？</p><p>使用sortedset，拿时间戳作为score，详细内容作为key调用zadd来生产消息，消费者用zrangebyscore 指令  获取N秒之前的数据轮询调度进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> Redis面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/10/15/Redis/"/>
      <url>/2022/10/15/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><ul><li><h3 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h3></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718234113983.png" alt="image-20220718234113983"></p><h2 id="第一部分-数据结构与对象"><a href="#第一部分-数据结构与对象" class="headerlink" title="第一部分  数据结构与对象"></a>第一部分  数据结构与对象</h2><h2 id="Chapter-2-简单动态字符串"><a href="#Chapter-2-简单动态字符串" class="headerlink" title="Chapter 2    简单动态字符串"></a>Chapter 2    简单动态字符串</h2><h3 id="2-0-redis-的简单动态字符串"><a href="#2-0-redis-的简单动态字符串" class="headerlink" title="2.0 redis 的简单动态字符串"></a>2.0 redis 的简单动态字符串</h3><ul><li><h3 id="SDS（simple-dynamic-string）"><a href="#SDS（simple-dynamic-string）" class="headerlink" title="SDS（simple dynamic string）"></a>SDS（simple dynamic string）</h3><ul><li><h4 id="当Redis需要一个可以被修改的字符串值时，就会使用SDS来表示哦。"><a href="#当Redis需要一个可以被修改的字符串值时，就会使用SDS来表示哦。" class="headerlink" title="当Redis需要一个可以被修改的字符串值时，就会使用SDS来表示哦。"></a>当Redis需要一个可以被修改的字符串值时，就会使用SDS来表示哦。</h4></li><li><pre><code class="redis">set msg &quot;helloworld&quot; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- ### key是 msg ，SDS，value是 ”helloworld“ SDS。<br><br>- ~~~redis<br>  RPUSH  fruits &quot;aaple&quot; &quot; bannana&quot; &quot; cherry  &quot;<br></code></pre></td></tr></table></figure></code></pre></li><li><h4 id="key-是fruits-SDS-，-value-是列表对象，即上面的三种水果。"><a href="#key-是fruits-SDS-，-value-是列表对象，即上面的三种水果。" class="headerlink" title="key 是fruits  SDS  ， value 是列表对象，即上面的三种水果。"></a>key 是fruits  SDS  ， value 是列表对象，即上面的三种水果。</h4></li></ul></li><li><h4 id="SDS还被用作缓冲区（buffer）：AOF模块中的-x3D-x3D-AOF缓冲区-x3D-x3D-，以及客户端状态中的-x3D-x3D-输入缓冲区-x3D-x3D-，都是由SDS实现的。-AOF持久化，客户端状态再展开。"><a href="#SDS还被用作缓冲区（buffer）：AOF模块中的-x3D-x3D-AOF缓冲区-x3D-x3D-，以及客户端状态中的-x3D-x3D-输入缓冲区-x3D-x3D-，都是由SDS实现的。-AOF持久化，客户端状态再展开。" class="headerlink" title="SDS还被用作缓冲区（buffer）：AOF模块中的&#x3D;&#x3D;AOF缓冲区&#x3D;&#x3D;，以及客户端状态中的&#x3D;&#x3D;输入缓冲区&#x3D;&#x3D;，都是由SDS实现的。  AOF持久化，客户端状态再展开。"></a>SDS还被用作缓冲区（buffer）：AOF模块中的&#x3D;&#x3D;AOF缓冲区&#x3D;&#x3D;，以及客户端状态中的&#x3D;&#x3D;输入缓冲区&#x3D;&#x3D;，都是由SDS实现的。  AOF持久化，客户端状态再展开。</h4></li></ul><h3 id="2-1-SDS-的定义"><a href="#2-1-SDS-的定义" class="headerlink" title="2.1   SDS 的定义"></a>2.1   SDS 的定义</h3><ul><li><h4 id="每个sds-h-x2F-sdshadr-结构表示一个sds值。"><a href="#每个sds-h-x2F-sdshadr-结构表示一个sds值。" class="headerlink" title="每个sds.h&#x2F;sdshadr 结构表示一个sds值。"></a>每个sds.h&#x2F;sdshadr 结构表示一个sds值。</h4></li><li><p>~~~C<br>struct sdshdr{<br>int len ;<br>int free;<br><br>char buf[];<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>- <br><br><br><br>![image-20220719113053601](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719113053601.png)<br><br><br><br>- #### SDS 遵循了C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。==分配1字节和添加空字符到字符串末尾等操作都是由SDS函数自动完成。==<br><br><br><br>- #### 带有未使用空间的SDS示例<br><br><br><br>![image-20220719113448009](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719113448009.png)<br><br><br><br><br><br><br><br>### 2.2  SDS与C语言包字符串的区别<br><br><br><br>1. #### ==C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符串最后一个元素总是‘\0’。==<br><br>2. ![image-20220719113649144](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719113649144.png)<br><br>###  <br><br>#### 2.2.1  常数复杂度获取字符串长度。<br><br><br><br>1. #### 因为C语言并不记录自身的长度信息，所以为了获取C字符串的长度必须遍历整个字符串，==知道遇到空字符‘\0==’，时间复杂度==O(n);==<br><br>2. ![image-20220719114447797](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719114447797.png)<br><br><br><br>1. ### 和C字符串不同，SDS在len属性中记录了SDS本身的长度，==所以获取SDS长度的时间复杂度仅为O(1)==<br><br>2. #### ==设置和更新SDS长度的工作由SDS的API在执行时自动完成的==，使用SDS无须进行任何手动修改长度的工作。<br><br><br><br>- #### 通过使用SDS而不是C字符串，Redis 将获取字符串长度所需的复杂度降低到了O(1)，确保了获取字符串长度的工作不会称为Redis的性能瓶颈。<br><br><br><br><br><br>![image-20220719115903576](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719115903576.png)<br><br><br><br><br><br><br><br>#### 2.2.2  杜绝缓冲区溢出<br><br><br><br>1. #### 除了获取字符串长度复杂度高之外，C字符串不记录自身长度带来的另一个问题就是==容易造成缓冲区溢出==（buffer overflow） 。<br><br>   1. #### 在拼接字符串时就会产生缓冲区溢出。<br><br><br><br><br><br>![image-20220719120931050](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719120931050.png)<br><br><br><br><br><br><br><br>- #### 与C字符串不同，SDS的==空间分配策略==完全杜绝了发生缓冲溢出区的可能性：当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足所需的要求，==如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小。==然后才执行实际的修改操作，所以==使用SDS既不需要手动修改SDS空间的大小，也不会出现前面说的缓冲区溢出问题。==<br><br><br><br><br><br>- ### 例子：<br><br>![image-20220719130035150](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719130035150.png)<br><br><br><br>- #### 注意，SDS，sdscat不仅对这个SDS进行了拼接操作，他还为SDS分配了13字节未使用空间，并且拼接之后的字符串也正好是13字节长，这种现象既不是bug也不是巧合，他和SDS的空间分配策略有关。<br><br><br><br><br><br>#### 2.2.3   减少修改字符串时带来的内存重分配次数。<br><br><br><br>- ### C的重分配例子<br><br>  <br><br>![image-20220719132057121](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719132057121.png)<br><br><br><br><br><br>- #### SDS 重分配例子<br><br>  <br><br>![image-20220719132333976](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719132333976.png)<br><br><br><br>- #### SDS实现了空间预分配和惰性空间释放两种优化策略。<br><br><br><br><br><br>1. #### 空间预分配  <br><br>- #### 空间预分配用于优化SDS的字符串增长操作，当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展时，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间。<br><br><br><br><br><br>![image-20220719135235769](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719135235769.png)<br><br><br><br><br><br>![image-20220719135305537](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719135305537.png)<br><br>![image-20220719135313995](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719135313995.png)<br><br><br><br><br><br>2. ### 惰性空间释放<br><br><br><br>- #### 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。<br><br>- #### 举个例子<br><br><br><br>![image-20220719141523550](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719141523550.png)<br><br>![image-20220719141537220](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719141537220.png)<br><br><br><br>![image-20220719141609313](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719141609313.png)<br><br><br><br><br><br><br><br><br><br>#### 2.2.4   二进制安全 <br><br><br><br>C字符串中的字符串必须采用某种编码，并且除了末尾外，字符串里面不能包含空字符串，否则最先被程序读入的空字符串被误认为是字符串结尾，这些限制C字符串只能保存文本数据，而不能保存图片，音频，视频，压缩文件等。这样的二进制数据，<br><br><br><br>- #### 因此，为了确保Redis可以适用于各种不同的场景，==SDS的API都是二进制安全的（binary-safe），==<br><br>- #### 通过使用二进制安全的SDS，而不是C字符串，==使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据==。<br><br>  <br><br><br><br>![image-20220719143554737](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719143554737.png)<br><br><br><br><br><br>#### 2.2.5  兼容部分 C字符串函数 <br><br><br><br>- #### 虽然SDS的API是二进制安全的，但==它们一样遵循C字符串以空字符串结尾的惯例==，这些API总会将SDS保存的数据的末尾设置为空字符串，并且总会在buf数组分配空间时多分配一个字节来容纳这个空字符，<br><br><br><br>![image-20220719145737081](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719145737081.png)<br><br><br><br><br><br>![image-20220719145749094](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719145749094.png)<br><br><br><br><br><br><br><br>#### 2.2.6   总结 <br><br><br><br>![image-20220719145807252](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719145807252.png)<br><br><br><br><br><br><br><br><br><br>### 2.3   SDS API  <br><br><br><br>- ### SDS API  中的方法<br><br><br><br>![image-20220719172321593](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719172321593.png)<br><br>![image-20220719172332780](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719172332780.png)<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>## Chapter 3     链表<br><br><br><br><br><br>![image-20220719173825996](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719173825996.png)<br><br><br><br><br><br>![image-20220719173833679](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719173833679.png)<br><br><br><br>### 3.1   链表和链表节点的实现 <br><br><br><br><br><br><br><br>![image-20220719180734478](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180734478.png)<br><br><br><br><br><br>![image-20220719180744228](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180744228.png)<br><br><br><br><br><br>![image-20220719180757535](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180757535.png)<br><br><br><br><br><br><br><br>### 3.2     链表和链表节点的API<br><br><br><br><br><br>![image-20220719180853746](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180853746.png)<br><br><br><br><br><br>![image-20220719180909055](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180909055.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 3.3    重点回顾 <br><br><br><br><br><br>![image-20220719180938120](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719180938120.png)<br><br><br><br><br><br><br><br><br><br>## Chapter 4    字典  <br><br><br><br><br><br>![image-20220719181454795](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719181454795.png)<br><br><br><br>- #### 字典：  key， value  <br><br>  - #### 每个key都是独一无二的<br><br>  - #### 可以。通过key来查找value，也可以通过value来更新更新key。又或者根据key来删除整个键值对。<br><br>- #### C语言并没有字典，Redis 自己创建了字典实现。<br><br>- #### redis 的数据库就是使用字典来作为底层实现的，对数据库中的增删改查，操作也是建立在字典操作之上的。<br><br>- #### 除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希健包含的键值对比较多又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希建的底层实现。<br><br><br><br>- ### 例如：<br><br>![image-20220719182001370](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719182001370.png)<br><br>![image-20220719182118795](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719182118795.png)<br><br><br><br><br><br><br><br><br><br>### 4.1   字典的实现 <br><br><br><br>- ### Redis字典所使用的哈希表由dict.h/dictht  结构定义：<br><br>~~~c<br>typedef struct dictht&#123;<br>    //哈希表数组<br>    dictEntry **table ; <br>    //哈希表大小<br>    unsigned long size ;<br>    //哈希表大小掩码，用于计算索引值，总是等于size-1<br>    unsigned long sizemask;<br>    // 该哈希表已有的节点的数量<br>    unsigned long used;<br>    <br>&#125;dictht;<br><br><br></code></pre></td></tr></table></figure></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719183756075.png" alt="image-20220719183756075"></p><h3 id="4-1-2-哈希表节点"><a href="#4-1-2-哈希表节点" class="headerlink" title="4.1.2   哈希表节点"></a>4.1.2   哈希表节点</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719184835864.png" alt="image-20220719184835864"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719184849227.png" alt="image-20220719184849227"></p><h3 id="4-1-3-字典"><a href="#4-1-3-字典" class="headerlink" title="4.1.3 字典"></a>4.1.3 字典</h3><ul><li><h3 id="Redis-中的字典结构："><a href="#Redis-中的字典结构：" class="headerlink" title="Redis 中的字典结构："></a>Redis 中的字典结构：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span>&#123;</span><br>    dictType *type ;<br>    <br>    <span class="hljs-type">void</span>  *private ;<br>    <br>    dictht ht[<span class="hljs-number">2</span>]; <br>    <br>    <span class="hljs-type">int</span> trehashidx; <br>&#125;dict;<br><br></code></pre></td></tr></table></figure></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719194915084.png" alt="image-20220719194915084"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719195634297.png" alt="image-20220719195634297"></p><ul><li><h4 id="普通状态下的字典-（没有进行rehash）"><a href="#普通状态下的字典-（没有进行rehash）" class="headerlink" title="普通状态下的字典 （没有进行rehash）"></a>普通状态下的字典 （没有进行rehash）</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719194926747.png" alt="image-20220719194926747"></p><h3 id="4-2-哈希算法"><a href="#4-2-哈希算法" class="headerlink" title="4.2  哈希算法"></a>4.2  哈希算法</h3><ul><li><h4 id="当需要一个新的键值对添加到字典里面时，-x3D-x3D-程序需要先根据键值对的建计算出哈希值和索引值-x3D-x3D-，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组指定的索引上面。"><a href="#当需要一个新的键值对添加到字典里面时，-x3D-x3D-程序需要先根据键值对的建计算出哈希值和索引值-x3D-x3D-，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组指定的索引上面。" class="headerlink" title="当需要一个新的键值对添加到字典里面时，&#x3D;&#x3D;程序需要先根据键值对的建计算出哈希值和索引值&#x3D;&#x3D;，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组指定的索引上面。"></a>当需要一个新的键值对添加到字典里面时，&#x3D;&#x3D;程序需要先根据键值对的建计算出哈希值和索引值&#x3D;&#x3D;，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组指定的索引上面。</h4></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs redis">hash = dict -&gt; type -&gt;hashFunction(key);<br><br>index = hash &amp; dict -&gt;ht[x].sizemask;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719200721220.png" alt="image-20220719200721220"></p><ul><li><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719200807185.png" alt="image-20220719200807185"></p><ol><li><h4 id="当字典被用作数据库的底层实现，或者哈希键的底层实现时，-x3D-x3D-Redis使用MurmurHash2算法来计算键的哈希值-x3D-x3D-。"><a href="#当字典被用作数据库的底层实现，或者哈希键的底层实现时，-x3D-x3D-Redis使用MurmurHash2算法来计算键的哈希值-x3D-x3D-。" class="headerlink" title="当字典被用作数据库的底层实现，或者哈希键的底层实现时，&#x3D;&#x3D;Redis使用MurmurHash2算法来计算键的哈希值&#x3D;&#x3D;。"></a>当字典被用作数据库的底层实现，或者哈希键的底层实现时，&#x3D;&#x3D;Redis使用MurmurHash2算法来计算键的哈希值&#x3D;&#x3D;。</h4></li><li><h4 id="MurmurHash2算法详情百度或google。"><a href="#MurmurHash2算法详情百度或google。" class="headerlink" title="MurmurHash2算法详情百度或google。"></a>MurmurHash2算法详情百度或google。</h4></li></ol><h3 id="4-3-解决键冲突"><a href="#4-3-解决键冲突" class="headerlink" title="4.3   解决键冲突"></a>4.3   解决键冲突</h3><ol><li><h4 id="x3D-x3D-当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。-x3D-x3D"><a href="#x3D-x3D-当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。&#x3D;&#x3D;"></a>&#x3D;&#x3D;当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。&#x3D;&#x3D;</h4></li></ol><ul><li><h4 id="Redis的哈希表-x3D-x3D-使用链地址法-x3D-x3D-来解决键冲突，每个哈希表节点都没有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突问题。"><a href="#Redis的哈希表-x3D-x3D-使用链地址法-x3D-x3D-来解决键冲突，每个哈希表节点都没有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突问题。" class="headerlink" title="Redis的哈希表&#x3D;&#x3D;使用链地址法&#x3D;&#x3D;来解决键冲突，每个哈希表节点都没有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突问题。"></a>Redis的哈希表&#x3D;&#x3D;使用链地址法&#x3D;&#x3D;来解决键冲突，每个哈希表节点都没有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突问题。</h4></li><li><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719202651939.png" alt="image-20220719202651939"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719202700708.png" alt="image-20220719202700708"></p><h3 id="4-4-rehash"><a href="#4-4-rehash" class="headerlink" title="4.4    rehash"></a>4.4    rehash</h3><ol><li><h4 id="为了让哈希表的负载因子（load-factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展和收缩。"><a href="#为了让哈希表的负载因子（load-factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展和收缩。" class="headerlink" title="为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展和收缩。"></a>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或太少时，程序需要对哈希表的大小进行相应的扩展和收缩。</h4></li><li><h4 id="扩展和收缩哈希表的工作可以-x3D-x3D-通过rehash（重新散列）操作-x3D-x3D-来完成，Redis对字典的哈希表执行rehash的步骤如下："><a href="#扩展和收缩哈希表的工作可以-x3D-x3D-通过rehash（重新散列）操作-x3D-x3D-来完成，Redis对字典的哈希表执行rehash的步骤如下：" class="headerlink" title="扩展和收缩哈希表的工作可以&#x3D;&#x3D;通过rehash（重新散列）操作&#x3D;&#x3D;来完成，Redis对字典的哈希表执行rehash的步骤如下："></a>扩展和收缩哈希表的工作可以&#x3D;&#x3D;通过rehash（重新散列）操作&#x3D;&#x3D;来完成，Redis对字典的哈希表执行rehash的步骤如下：</h4><ol><li><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719204231115.png" alt="image-20220719204231115"></li></ol></li></ol><ul><li><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719205907156.png" alt="image-20220719205907156"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719205917489.png" alt="image-20220719205917489"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719205924774.png" alt="image-20220719205924774"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719205932410.png" alt="image-20220719205932410"></p><h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><ol><li><h4 id="当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作："><a href="#当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：" class="headerlink" title="当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作："></a>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</h4><ol><li><h4 id="服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。"><a href="#服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。" class="headerlink" title="服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。"></a>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</h4></li><li><h4 id="服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。"><a href="#服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。" class="headerlink" title="服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。"></a>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</h4></li><li><p>~~~redis<br>负载因子 &#x3D; 哈希表已保存的节点数量&#x2F;哈希表大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>   4. <br><br>![image-20220719211609337](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220719211609337.png)<br><br><br><br><br><br>1. #### 根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器进行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子效率，进而大多数操作系统都采用==写时复制技术==来优化子进程的使用效率。<br><br>2. #### 所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不要的内存写入操作，最大限度地节约内存。<br><br>3. #### 另一方面，==当哈希表地负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。==<br><br><br><br><br><br><br><br><br><br>### 4.5   渐进式 rehash <br><br><br><br><br><br>![image-20220720093618710](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093618710.png)<br><br>![image-20220720093625250](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093625250.png)<br><br>![image-20220720093636084](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093636084.png)<br><br>![image-20220720093642733](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093642733.png)<br><br>![image-20220720093650158](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093650158.png)<br><br>![image-20220720093657083](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093657083.png)<br><br>![image-20220720093704611](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093704611.png)<br><br><br><br>![image-20220720093711131](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720093711131.png)<br><br><br><br><br><br><br><br><br><br>### 渐进式rehash 执行期间的哈希表操作<br><br><br><br><br><br>1. #### 因为在进行渐进式hash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash期间，字典的删除，查找，更新，会在两个哈希表上进行。例如，要在字典里查找一个键的话，程序会现在ht[0]里面查找，如果没找到的话，就会继续道ht[1]里面进行查找，诸如此类。<br><br>2. #### 另外，在渐进式rehash执行期间，新添加到字典的键值对一律会保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减少不增加，并随着rehash操作的执行而最终变成空表。<br><br><br><br><br><br>### 4.6  字典API<br><br><br><br><br><br>![image-20220720094825588](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720094825588.png)<br><br>![image-20220720094833281](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720094833281.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 4.7  重点回顾<br><br><br><br><br><br><br><br>![image-20220720094846213](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720094846213.png)<br><br>1. #### 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键<br><br>2. #### Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用<br><br>3. #### 当字典被用作数据库的底层实现，或者哈希键的底层实现，Redis使用MurmurHash2算法来计算键的哈希值<br><br>4. #### 哈希表使用链地址法来解决冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表<br><br>5. #### 在对哈希表进行扩展或者收缩操作时，程序需要将现有的哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成。<br><br><br><br><br><br><br><br><br><br><br><br>## Chapter 5    跳跃表 <br><br><br><br>1. #### 跳跃表是一种有序数据结构，他通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。<br><br>2. #### 跳跃表支持平均O(logN),最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。<br><br>3. #### 在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树来得更为简单，所以不少程序都是用跳跃表来代替平衡树。<br><br>4. #### Redis==使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。<br><br><br><br>- ### 例子<br><br><br><br>![image-20220720134211562](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720134211562.png)<br><br>1. #### Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。<br><br><br><br><br><br>### 5.1  跳跃表的实现<br><br><br><br>![image-20220720134452961](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720134452961.png)<br><br><br><br>1. ### header：指向跳跃表的表头节点<br><br>2. ### tail：指向跳跃表的表为节点<br><br>3. ### level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计在内）<br><br>4. ### length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计在内）。<br><br>![image-20220720134710190](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720134710190.png)<br><br>![image-20220720134714469](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720134714469.png)<br><br><br><br><br><br><br><br>#### 5.1.1   跳跃表的节点<br><br><br><br><br><br>![image-20220720135557350](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135557350.png)<br><br>![image-20220720135605404](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135605404.png)<br><br>![image-20220720135617248](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135617248.png)<br><br><br><br>![image-20220720135626549](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135626549.png)<br><br>![image-20220720135642211](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135642211.png)<br><br><br><br>![image-20220720135650430](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135650430.png)<br><br>![image-20220720135705745](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135705745.png)<br><br><br><br>![image-20220720135714213](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135714213.png)<br><br><br><br>![image-20220720135725067](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135725067.png)<br><br>![image-20220720135736998](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135736998.png)<br><br><br><br><br><br>![image-20220720135744934](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135744934.png)<br><br><br><br><br><br>### 5.2  跳跃表API<br><br><br><br><br><br>![image-20220720135852895](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135852895.png)<br><br>![image-20220720135903029](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720135903029.png)<br><br><br><br><br><br><br><br><br><br>### 5.3    重点回顾 <br><br><br><br>1. #### 跳跃表是有序集合的底层实现之一<br><br>2. #### Redis的跳跃表实现由zskiplist和zskiplistNode 两个结构组成，其中zskiplist用于跳跃表信息，而zskiplistNode则用于表示跳跃表的节点<br><br>3. #### 每个跳跃表节点的层高都是1~32之间的随机数<br><br>4. #### 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的<br><br>5. #### 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。<br><br><br><br><br><br><br><br>## Chapter 6   整数集合<br><br><br><br><br><br>1. #### 整数集合(inset)是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br><br><br><br>- ### 例子<br><br>  <br><br>![image-20220720141925889](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720141925889.png)<br><br><br><br><br><br>### 6.1    整数集合的实现<br><br><br><br>1. ### 整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为 int 16_t, int32_t 或者 int 64_t 的整数值，并且保证集合中不会出现重复元素。<br><br>2. ~~~c<br>   typedef struct intset&#123;<br>       <br>   &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720143828417.png" alt="image-20220720143828417"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720143839627.png" alt="image-20220720143839627"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720143847027.png" alt="image-20220720143847027"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720143853556.png" alt="image-20220720143853556"></p><h3 id="6-2-升级"><a href="#6-2-升级" class="headerlink" title="6.2 升级"></a>6.2 升级</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144217056.png" alt="image-20220720144217056"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144248694.png" alt="image-20220720144248694"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144301391.png" alt="image-20220720144301391"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144320128.png" alt="image-20220720144320128"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144327430.png" alt="image-20220720144327430"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720144347076.png" alt="image-20220720144347076"></p><h3 id="6-3-升级的好处"><a href="#6-3-升级的好处" class="headerlink" title="6.3  升级的好处"></a>6.3  升级的好处</h3><ul><li><h3 id="整数集合的升级策略有两个策略，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。"><a href="#整数集合的升级策略有两个策略，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。" class="headerlink" title="整数集合的升级策略有两个策略，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。"></a>整数集合的升级策略有两个策略，一个是提升整数集合的灵活性，另一个是尽可能地节约内存。</h3></li></ul><h4 id="6-3-1-提升灵活性"><a href="#6-3-1-提升灵活性" class="headerlink" title="6.3.1   提升灵活性"></a>6.3.1   提升灵活性</h4><ol><li><h4 id="因为C语言是静态语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。"><a href="#因为C语言是静态语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。" class="headerlink" title="因为C语言是静态语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。"></a>因为C语言是静态语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。</h4><ol><li><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720180513062.png" alt="image-20220720180513062"></li></ol></li></ol><h4 id="6-3-2-节约内存"><a href="#6-3-2-节约内存" class="headerlink" title="6.3.2   节约内存"></a>6.3.2   节约内存</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720180653392.png" alt="image-20220720180653392"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720180701394.png" alt="image-20220720180701394"></p><h3 id="6-4-降级"><a href="#6-4-降级" class="headerlink" title="6.4  降级"></a>6.4  降级</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720180843745.png" alt="image-20220720180843745"></p><h3 id="6-5-整数集合API"><a href="#6-5-整数集合API" class="headerlink" title="6.5    整数集合API"></a>6.5    整数集合API</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720181335090.png" alt="image-20220720181335090"></p><h3 id="6-6-重点回顾"><a href="#6-6-重点回顾" class="headerlink" title="6.6    重点回顾"></a>6.6    重点回顾</h3><ol><li><h4 id="整数集合是集合键的底层实现之一"><a href="#整数集合是集合键的底层实现之一" class="headerlink" title="整数集合是集合键的底层实现之一"></a>整数集合是集合键的底层实现之一</h4></li><li><h4 id="整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素的类型，改变这个数组的类型"><a href="#整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素的类型，改变这个数组的类型" class="headerlink" title="整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素的类型，改变这个数组的类型"></a>整数集合的底层实现为数组，这个数组以有序，无重复的方式保存集合元素，在有需要时，程序会根据新添加的元素的类型，改变这个数组的类型</h4></li><li><h4 id="升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存"><a href="#升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存" class="headerlink" title="升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存"></a>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存</h4></li><li><h4 id="整数集合只支持升级操作，不支持降级操作。"><a href="#整数集合只支持升级操作，不支持降级操作。" class="headerlink" title="整数集合只支持升级操作，不支持降级操作。"></a>整数集合只支持升级操作，不支持降级操作。</h4></li></ol><h2 id="Chapter-7-压缩列表"><a href="#Chapter-7-压缩列表" class="headerlink" title="Chapter 7    压缩列表"></a>Chapter 7    压缩列表</h2><ol><li><h4 id="压缩列表是列表键和哈希键的底层实现之一。当一个列标键只包含少量列表项，并且每个列表项要么就是最小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来坐列标键的底层实现。"><a href="#压缩列表是列表键和哈希键的底层实现之一。当一个列标键只包含少量列表项，并且每个列表项要么就是最小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来坐列标键的底层实现。" class="headerlink" title="压缩列表是列表键和哈希键的底层实现之一。当一个列标键只包含少量列表项，并且每个列表项要么就是最小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来坐列标键的底层实现。"></a>压缩列表是列表键和哈希键的底层实现之一。当一个列标键只包含少量列表项，并且每个列表项要么就是最小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来坐列标键的底层实现。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720183339311.png" alt="image-20220720183339311"></p><ul><li><h4 id="另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列标来做哈希键的底层实现，"><a href="#另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列标来做哈希键的底层实现，" class="headerlink" title="另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列标来做哈希键的底层实现，"></a>另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列标来做哈希键的底层实现，</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720184605273.png" alt="image-20220720184605273"></p><h3 id="7-1-压缩列表的构成"><a href="#7-1-压缩列表的构成" class="headerlink" title="7.1   压缩列表的构成"></a>7.1   压缩列表的构成</h3><ol><li><h4 id="压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。"><a href="#压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。" class="headerlink" title="压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。"></a>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存组成的顺序型数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720185208190.png" alt="image-20220720185208190"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720185228226.png" alt="image-20220720185228226"></p><h3 id="7-2-压缩列表节点的构成"><a href="#7-2-压缩列表节点的构成" class="headerlink" title="7.2   压缩列表节点的构成"></a>7.2   压缩列表节点的构成</h3><ol><li><h4 id="每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度的其中一种："><a href="#每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度的其中一种：" class="headerlink" title="每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度的其中一种："></a>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度的其中一种：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720185623101.png" alt="image-20220720185623101"></p><h4 id="7-2-1-previous-entry-length"><a href="#7-2-1-previous-entry-length" class="headerlink" title="7.2.1    previous_entry_length"></a>7.2.1    previous_entry_length</h4><ol><li><h4 id="节点的previous-entry-length-属性以字节为单位，记录了压缩列表中前一个节点的长度。"><a href="#节点的previous-entry-length-属性以字节为单位，记录了压缩列表中前一个节点的长度。" class="headerlink" title="节点的previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。"></a>节点的previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220720190049645.png" alt="image-20220720190049645"></p><h4 id="7-2-2-encoding"><a href="#7-2-2-encoding" class="headerlink" title="7.2.2  encoding"></a>7.2.2  encoding</h4><h4 id="7-2-3-content"><a href="#7-2-3-content" class="headerlink" title="7.2.3  content"></a>7.2.3  content</h4><h3 id="7-3-连锁更新"><a href="#7-3-连锁更新" class="headerlink" title="7.3   连锁更新"></a>7.3   连锁更新</h3><h3 id="7-4-压缩列表API"><a href="#7-4-压缩列表API" class="headerlink" title="7.4  压缩列表API"></a>7.4  压缩列表API</h3><h3 id="7-5-重点回顾"><a href="#7-5-重点回顾" class="headerlink" title="7.5 重点回顾"></a>7.5 重点回顾</h3><ol><li><h4 id="压缩列表是一种为了节约内存而开发的顺序型数据结构"><a href="#压缩列表是一种为了节约内存而开发的顺序型数据结构" class="headerlink" title="压缩列表是一种为了节约内存而开发的顺序型数据结构"></a>压缩列表是一种为了节约内存而开发的顺序型数据结构</h4></li><li><h4 id="压缩列表被用作列表键和哈希键的底层实现之一"><a href="#压缩列表被用作列表键和哈希键的底层实现之一" class="headerlink" title="压缩列表被用作列表键和哈希键的底层实现之一"></a>压缩列表被用作列表键和哈希键的底层实现之一</h4></li><li><h4 id="压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值"><a href="#压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值" class="headerlink" title="压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值"></a>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</h4></li><li><h4 id="添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但这种操作出现的几率并不高。"><a href="#添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但这种操作出现的几率并不高。" class="headerlink" title="添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但这种操作出现的几率并不高。"></a>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引起连锁更新操作，但这种操作出现的几率并不高。</h4></li></ol><h2 id="Chapter-8-对象"><a href="#Chapter-8-对象" class="headerlink" title="Chapter  8     对象"></a>Chapter  8     对象</h2><ol><li><h4 id="前面了解了Redis用到的所有主要数据结构，比如简单字符串（SDS），双端链表，字典，压缩列表，整数集合等等"><a href="#前面了解了Redis用到的所有主要数据结构，比如简单字符串（SDS），双端链表，字典，压缩列表，整数集合等等" class="headerlink" title="前面了解了Redis用到的所有主要数据结构，比如简单字符串（SDS），双端链表，字典，压缩列表，整数集合等等"></a>前面了解了Redis用到的所有主要数据结构，比如简单字符串（SDS），双端链表，字典，压缩列表，整数集合等等</h4></li><li><h4 id="Redis对象系统：-字符串对象，列表对象，哈希对象，集合对象，和有序集合对象-五种不同类型的对象"><a href="#Redis对象系统：-字符串对象，列表对象，哈希对象，集合对象，和有序集合对象-五种不同类型的对象" class="headerlink" title="Redis对象系统： 字符串对象，列表对象，哈希对象，集合对象，和有序集合对象 五种不同类型的对象"></a>Redis对象系统： 字符串对象，列表对象，哈希对象，集合对象，和有序集合对象 五种不同类型的对象</h4></li><li><h4 id="Redis在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令，使用对象的另一个好处就是，我们可以针对不同的使用场景为对象设置不同的数据结构实现，从而优化对象在不同场景下的使用效率"><a href="#Redis在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令，使用对象的另一个好处就是，我们可以针对不同的使用场景为对象设置不同的数据结构实现，从而优化对象在不同场景下的使用效率" class="headerlink" title="Redis在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令，使用对象的另一个好处就是，我们可以针对不同的使用场景为对象设置不同的数据结构实现，从而优化对象在不同场景下的使用效率"></a>Redis在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令，使用对象的另一个好处就是，我们可以针对不同的使用场景为对象设置不同的数据结构实现，从而优化对象在不同场景下的使用效率</h4></li><li><h4 id="初次之外，Redis对象系统还实现了-x3D-x3D-基于引用计数技术的内存回收机制，当场景不在使用某个对象时，这个对象所占有的内存就会被自动释放。"><a href="#初次之外，Redis对象系统还实现了-x3D-x3D-基于引用计数技术的内存回收机制，当场景不在使用某个对象时，这个对象所占有的内存就会被自动释放。" class="headerlink" title="初次之外，Redis对象系统还实现了&#x3D;&#x3D;基于引用计数技术的内存回收机制，当场景不在使用某个对象时，这个对象所占有的内存就会被自动释放。"></a>初次之外，Redis对象系统还实现了&#x3D;&#x3D;基于引用计数技术的内存回收机制，当场景不在使用某个对象时，这个对象所占有的内存就会被自动释放。</h4></li><li><h4 id="另外Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。"><a href="#另外Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。" class="headerlink" title="另外Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。"></a>另外Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库共享同一个对象来节约内存。</h4></li><li><h4 id="最后Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。"><a href="#最后Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。" class="headerlink" title="最后Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。"></a>最后Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。</h4></li></ol><h3 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1  对象的类型与编码"></a>8.1  对象的类型与编码</h3><ol><li><h4 id="Redis-使用对象来表示数据库中的键值对，当在数据库中创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，key对象，另一个对象用作键值对的值，值对象。"><a href="#Redis-使用对象来表示数据库中的键值对，当在数据库中创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，key对象，另一个对象用作键值对的值，值对象。" class="headerlink" title="Redis 使用对象来表示数据库中的键值对，当在数据库中创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，key对象，另一个对象用作键值对的值，值对象。"></a>Redis 使用对象来表示数据库中的键值对，当在数据库中创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，key对象，另一个对象用作键值对的值，值对象。</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721102331098.png" alt="image-20220721102331098"></p></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721102339218.png" alt="image-20220721102339218"></p><h4 id="8-1-1-类型"><a href="#8-1-1-类型" class="headerlink" title="8.1.1   类型"></a>8.1.1   类型</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721102514528.png" alt="image-20220721102514528"></p><ul><li><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103229490.png" alt="image-20220721103229490"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103244361.png" alt="image-20220721103244361"></p><h4 id="8-1-2-编码和底层实现"><a href="#8-1-2-编码和底层实现" class="headerlink" title="8.1.2   编码和底层实现"></a>8.1.2   编码和底层实现</h4><ol><li><h4 id="对象的ptr-指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。"><a href="#对象的ptr-指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。" class="headerlink" title="对象的ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。"></a>对象的ptr 指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</h4></li><li><h4 id="。"><a href="#。" class="headerlink" title="。"></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103724846.png" alt="image-20220721103724846">。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103825377.png" alt="image-20220721103825377"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103839424.png" alt="image-20220721103839424"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721103847381.png" alt="image-20220721103847381"></p><h3 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2  字符串对象"></a>8.2  字符串对象</h3><ol><li><h4 id="字符串对象的编码可以是int，raw，或者embstr"><a href="#字符串对象的编码可以是int，raw，或者embstr" class="headerlink" title="字符串对象的编码可以是int，raw，或者embstr"></a>字符串对象的编码可以是int，raw，或者embstr</h4></li><li><h4 id="如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void-换成long），并将字符串对象的编码设置为int"><a href="#如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void-换成long），并将字符串对象的编码设置为int" class="headerlink" title="如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void * 换成long），并将字符串对象的编码设置为int"></a>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void * 换成long），并将字符串对象的编码设置为int</h4></li><li><h4 id="如果字符串值得长度大于32字节，编码将会是raw，如果小于等于32字节，那么将会使用embstr编码来保存这个字符串值。"><a href="#如果字符串值得长度大于32字节，编码将会是raw，如果小于等于32字节，那么将会使用embstr编码来保存这个字符串值。" class="headerlink" title="如果字符串值得长度大于32字节，编码将会是raw，如果小于等于32字节，那么将会使用embstr编码来保存这个字符串值。"></a>如果字符串值得长度大于32字节，编码将会是raw，如果小于等于32字节，那么将会使用embstr编码来保存这个字符串值。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104411292.png" alt="image-20220721104411292"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104422667.png" alt="image-20220721104422667"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104433994.png" alt="image-20220721104433994"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104441013.png" alt="image-20220721104441013"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104447492.png" alt="image-20220721104447492"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104459154.png" alt="image-20220721104459154"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721104506055.png" alt="image-20220721104506055"></p><h4 id="8-2-1-编码的转换"><a href="#8-2-1-编码的转换" class="headerlink" title="8.2.1      编码的转换"></a>8.2.1      编码的转换</h4><ol><li><h4 id="int-编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象"><a href="#int-编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象" class="headerlink" title="int 编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象"></a>int 编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象</h4></li><li><h4 id="。-1"><a href="#。-1" class="headerlink" title="。"></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721123726455.png" alt="image-20220721123726455">。</h4></li><li></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721123737192.png" alt="image-20220721123737192"></p><h4 id="8-2-2-字符串命令的实现"><a href="#8-2-2-字符串命令的实现" class="headerlink" title="8.2.2   字符串命令的实现"></a>8.2.2   字符串命令的实现</h4><ol><li><h4 id="因为字符串键的值为字符串对象，所以用于字符串键的所有命令"><a href="#因为字符串键的值为字符串对象，所以用于字符串键的所有命令" class="headerlink" title="因为字符串键的值为字符串对象，所以用于字符串键的所有命令"></a>因为字符串键的值为字符串对象，所以用于字符串键的所有命令</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721163233735.png" alt="image-20220721163233735"></p><h3 id="8-3-列表对象"><a href="#8-3-列表对象" class="headerlink" title="8.3    列表对象"></a>8.3    列表对象</h3><ol><li><h4 id="列表对象的编码可以是ziplist或者linkedlist"><a href="#列表对象的编码可以是ziplist或者linkedlist" class="headerlink" title="列表对象的编码可以是ziplist或者linkedlist"></a>列表对象的编码可以是ziplist或者linkedlist</h4></li><li><h4 id="ziplist编码的列表对象使用-x3D-x3D-压缩列表作为底层实现-x3D-x3D-，每个压缩列表节点保存了一个列表元素，。、"><a href="#ziplist编码的列表对象使用-x3D-x3D-压缩列表作为底层实现-x3D-x3D-，每个压缩列表节点保存了一个列表元素，。、" class="headerlink" title="ziplist编码的列表对象使用&#x3D;&#x3D;压缩列表作为底层实现&#x3D;&#x3D;，每个压缩列表节点保存了一个列表元素，。、"></a>ziplist编码的列表对象使用&#x3D;&#x3D;压缩列表作为底层实现&#x3D;&#x3D;，每个压缩列表节点保存了一个列表元素，。、</h4></li><li><p>~~~redis<br>RPUSH numbers 1 “three” 5  (integer) 3 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>4. #### 如果numbers键的对象使用的是ziplist编码，这个价值对象将会是图8-5所展示ide样子。<br><br>![image-20220721164721742](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721164721742.png)<br><br><br><br>1. #### linkedlist 编码的列表对象使用双端列表作为底层实现，每个双端链表节点node都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。<br><br>2. #### 例：<br><br>![image-20220721164850980](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721164850980.png)<br><br><br><br>- #### 注意，linkedlist编码的列表对象在底层的双端链表结构中包含了许多个字符串对象，这种嵌套字符串对象在哈希对象，集合对象，有序集合对象都会出现。==字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象==。<br><br><br><br>![image-20220721165205327](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721165205327.png)<br><br><br><br><br><br><br><br><br><br><br><br>#### 8.3.1   编码转换 <br><br><br><br>1. #### 当列表对象可以同时满足一下两个条件时，列表对象使用ziplist编码：<br><br>   1. #### 列表对象保存的所有字符串元素的长度都小于64字节<br><br>   2. #### 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。<br><br><br><br>![image-20220721170034264](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721170034264.png)<br><br><br><br>1. #### 对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从ziplist变为linkedlist。<br><br><br><br>![image-20220721170610104](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721170610104.png)<br><br><br><br>![image-20220721170823367](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721170823367.png)<br><br><br><br><br><br>#### 8.3.2   列表命令的实现 <br><br><br><br>1. #### 因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象来构建的。<br><br><br><br>![image-20220721172414371](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721172414371.png)<br><br><br><br>![image-20220721172423309](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721172423309.png)<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>### 8.4    哈希对象 <br><br><br><br>1. #### 哈希对象的编码可以是==ziplist或者hashtable== 。<br><br>2. #### ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。<br><br>   1. #### 保存了同一键值对的两个节点总是紧挨在一起保存键的节点在前，保存值的节点在后<br><br>   2. #### 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希表对象中的键值对会被放在压缩列表的表尾方向。<br><br><br><br><br><br>![image-20220721174813475](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721174813475.png)<br><br><br><br>![image-20220721174820931](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721174820931.png)<br><br><br><br>![image-20220721175352541](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721175352541.png)<br><br><br><br><br><br><br><br><br><br>#### 8.4.1    编码转换<br><br><br><br>1. #### 当哈希对象可以同时满足以下两个条件是，哈希对象使用ziplist编码：<br><br>   - #### 当哈希对象保存的所有键值对的键和值的字符串长度小于64字节；<br><br>   - #### 哈希对象保存的键值对数量小于512个；<br><br>   - #### 不能满足这两个条件的哈希对象需要使用hashtable编码。<br><br><br><br><br><br>![image-20220721181759018](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721181759018.png)<br><br><br><br><br><br>![image-20220721181818265](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721181818265.png)<br><br><br><br>![image-20220721181835794](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721181835794.png)<br><br><br><br><br><br>![image-20220721182037363](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721182037363.png)<br><br><br><br><br><br><br><br>#### 8.4.2  哈希命令的实现<br><br><br><br><br><br>![image-20220721202800495](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721202800495.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 8.5    集合对象  <br><br><br><br>1. #### 集合对象的编码可以是intset或者是hashtable<br><br>2. #### intset编码的集合对象使用整数集合作为底层实现，集合对象包含的苏所有元素都被保存在整数集合里面。<br><br><br><br>~~~redis<br>SADD numbers 1 3 5 (Integer)  3<br></code></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721211741201.png" alt="image-20220721211741201"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721211749030.png" alt="image-20220721211749030"></p><h4 id="8-5-1-编码的转换"><a href="#8-5-1-编码的转换" class="headerlink" title="8.5.1     编码的转换"></a>8.5.1     编码的转换</h4><ol><li><h4 id="当集合对象可以同时满足以下两个条件时，对象使用intset编码："><a href="#当集合对象可以同时满足以下两个条件时，对象使用intset编码：" class="headerlink" title="当集合对象可以同时满足以下两个条件时，对象使用intset编码："></a>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</h4><ol><li><h4 id="集合对象保存的所有元素都是整数值"><a href="#集合对象保存的所有元素都是整数值" class="headerlink" title="集合对象保存的所有元素都是整数值"></a>集合对象保存的所有元素都是整数值</h4></li><li><h4 id="集合对象保存的元素不超过512个。"><a href="#集合对象保存的元素不超过512个。" class="headerlink" title="集合对象保存的元素不超过512个。"></a>集合对象保存的元素不超过512个。</h4></li><li><h4 id="不能满足这两个条件的集合对象需要使用hashtable编码"><a href="#不能满足这两个条件的集合对象需要使用hashtable编码" class="headerlink" title="不能满足这两个条件的集合对象需要使用hashtable编码"></a>不能满足这两个条件的集合对象需要使用hashtable编码</h4></li></ol></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721212231896.png" alt="image-20220721212231896"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220721213024699.png" alt="image-20220721213024699"></p><h3 id="8-6-有序集合对象"><a href="#8-6-有序集合对象" class="headerlink" title="8.6    有序集合对象"></a>8.6    有序集合对象</h3><h3 id="8-7-类型检查与命令多态"><a href="#8-7-类型检查与命令多态" class="headerlink" title="8.7        类型检查与命令多态"></a>8.7        类型检查与命令多态</h3><ol><li><h4 id="Redis-中用于操作键的命令基本上可以分为两种类型"><a href="#Redis-中用于操作键的命令基本上可以分为两种类型" class="headerlink" title="Redis 中用于操作键的命令基本上可以分为两种类型:"></a>Redis 中用于操作键的命令基本上可以分为两种类型:</h4><ol><li><h4 id="其中一种命令可以对任何类型的键执行-x3D-x3D-比如说-DEL命令-EXPIRE命令-rename命令-type命令-object-命令。"><a href="#其中一种命令可以对任何类型的键执行-x3D-x3D-比如说-DEL命令-EXPIRE命令-rename命令-type命令-object-命令。" class="headerlink" title="其中一种命令可以对任何类型的键执行:  &#x3D;&#x3D;比如说 DEL命令,EXPIRE命令,rename命令,type命令,object 命令。"></a>其中一种命令可以对任何类型的键执行:  &#x3D;&#x3D;比如说 DEL命令,EXPIRE命令,rename命令,type命令,object 命令。</h4></li></ol></li><li><h4 id="FOR-example"><a href="#FOR-example" class="headerlink" title="FOR example"></a>FOR example</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs redis">set msg &quot;hello&quot; <br><br>rpush numbers 1 2 3 <br><br>sadd fruits apple banana cherry<br><br>del msg<br>del numbers<br>del fruits<br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725201932392.png" alt="image-20220725201932392"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725201946359.png" alt="image-20220725201946359"></p><h4 id="8-7-1-类型检查的实现"><a href="#8-7-1-类型检查的实现" class="headerlink" title="8.7.1   类型检查的实现"></a>8.7.1   类型检查的实现</h4><ol><li><h4 id="在执行一个类型特定命令之前，Redis-会先-检查插入键的类型是否正确，然后再决定是否执行给定的命令。"><a href="#在执行一个类型特定命令之前，Redis-会先-检查插入键的类型是否正确，然后再决定是否执行给定的命令。" class="headerlink" title="在执行一个类型特定命令之前，Redis 会先 检查插入键的类型是否正确，然后再决定是否执行给定的命令。"></a>在执行一个类型特定命令之前，Redis 会先 检查插入键的类型是否正确，然后再决定是否执行给定的命令。</h4><ul><li><h4 id="类型特定命令所进行的类型检查是通过redisObject-结构的type实行来实现的："><a href="#类型特定命令所进行的类型检查是通过redisObject-结构的type实行来实现的：" class="headerlink" title="类型特定命令所进行的类型检查是通过redisObject 结构的type实行来实现的："></a>类型特定命令所进行的类型检查是通过redisObject 结构的type实行来实现的：</h4><ul><li><h4 id=""><a href="#" class="headerlink" title="."></a>.</h4></li></ul></li></ul></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725202416976.png"></p><h4 id="8-7-2-多态命令的实现"><a href="#8-7-2-多态命令的实现" class="headerlink" title="8.7.2     多态命令的实现"></a>8.7.2     多态命令的实现</h4><ol><li><h4 id="Redis-除了会根据对像的类型来判断键是否能够执行指定命令之外，还会根据对象的编码方式，选择正确的命令实现代码来执行命令。"><a href="#Redis-除了会根据对像的类型来判断键是否能够执行指定命令之外，还会根据对象的编码方式，选择正确的命令实现代码来执行命令。" class="headerlink" title="Redis 除了会根据对像的类型来判断键是否能够执行指定命令之外，还会根据对象的编码方式，选择正确的命令实现代码来执行命令。"></a>Redis 除了会根据对像的类型来判断键是否能够执行指定命令之外，还会根据对象的编码方式，选择正确的命令实现代码来执行命令。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725202932886.png" alt="image-20220725202932886"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725202958378.png" alt="image-20220725202958378"></p><h3 id="8-8-内存回收"><a href="#8-8-内存回收" class="headerlink" title="8.8     内存回收"></a>8.8     内存回收</h3><ol><li><h4 id="因为C语言并不具备自动内存回收功能，所以-x3D-x3D-Redis-在自己的对象系统中构建了一个计数技术实现的内存回收机制-x3D-x3D-，通过这一机制，程序可以通过跟踪对象的引用技术信息，在适当的时候自动释放对象，并进行内存回收。"><a href="#因为C语言并不具备自动内存回收功能，所以-x3D-x3D-Redis-在自己的对象系统中构建了一个计数技术实现的内存回收机制-x3D-x3D-，通过这一机制，程序可以通过跟踪对象的引用技术信息，在适当的时候自动释放对象，并进行内存回收。" class="headerlink" title="因为C语言并不具备自动内存回收功能，所以&#x3D;&#x3D;Redis 在自己的对象系统中构建了一个计数技术实现的内存回收机制&#x3D;&#x3D;，通过这一机制，程序可以通过跟踪对象的引用技术信息，在适当的时候自动释放对象，并进行内存回收。"></a>因为C语言并不具备自动内存回收功能，所以&#x3D;&#x3D;Redis 在自己的对象系统中构建了一个计数技术实现的内存回收机制&#x3D;&#x3D;，通过这一机制，程序可以通过跟踪对象的引用技术信息，在适当的时候自动释放对象，并进行内存回收。</h4></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObjct</span>&#123;</span><br>    <span class="hljs-type">int</span> refcount ;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725203650345.png" alt="image-20220725203650345"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725203658927.png" alt="image-20220725203658927"></p><h3 id="8-9-对象共享"><a href="#8-9-对象共享" class="headerlink" title="8.9    对象共享"></a>8.9    对象共享</h3><ol><li><h4 id="除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。"><a href="#除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。" class="headerlink" title="除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。"></a>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725204242430.png" alt="image-20220725204242430"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725204252310.png" alt="image-20220725204252310"></p><ol><li><h5 id="例如，假设数据库中中保存了整数值100的键不只是键A和键B两个，而是100个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存数据"><a href="#例如，假设数据库中中保存了整数值100的键不只是键A和键B两个，而是100个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存数据" class="headerlink" title="例如，假设数据库中中保存了整数值100的键不只是键A和键B两个，而是100个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存数据"></a>例如，假设数据库中中保存了整数值100的键不只是键A和键B两个，而是100个，那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存数据</h5></li><li><h5 id="目前来说-Redis会在初始化服务器时-创建一万个字符串对象-这些对象包含了默认从0-9999-的所有整数值-当服务器需要用到值为-0-9999-的字符串对象时-服务器就会使用这些共享对象-而不是新创建对象"><a href="#目前来说-Redis会在初始化服务器时-创建一万个字符串对象-这些对象包含了默认从0-9999-的所有整数值-当服务器需要用到值为-0-9999-的字符串对象时-服务器就会使用这些共享对象-而不是新创建对象" class="headerlink" title="目前来说,Redis会在初始化服务器时,创建一万个字符串对象,这些对象包含了默认从0-9999 的所有整数值,当服务器需要用到值为 0 -9999 的字符串对象时,服务器就会使用这些共享对象, 而不是新创建对象."></a>目前来说,Redis会在初始化服务器时,创建一万个字符串对象,这些对象包含了默认从0-9999 的所有整数值,当服务器需要用到值为 0 -9999 的字符串对象时,服务器就会使用这些共享对象, 而不是新创建对象.</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs redis">set a  100  <br><br>object refcount a  <br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725205810285.png" alt="image-20220725205810285"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725210605389.png" alt="image-20220725210605389"></p><h3 id="8-10-对象的空转时长"><a href="#8-10-对象的空转时长" class="headerlink" title="8.10     对象的空转时长"></a>8.10     对象的空转时长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs redis">object idletime msg  <br><br>object idletime msg  <br><br>get msg  <br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725210936547.png" alt="image-20220725210936547"></p><h3 id="8-11-重点回顾"><a href="#8-11-重点回顾" class="headerlink" title="8.11  重点回顾"></a>8.11  重点回顾</h3><ul><li><h4 id="Redis数据库中的每个键值对的键和值都是一个对象"><a href="#Redis数据库中的每个键值对的键和值都是一个对象" class="headerlink" title="Redis数据库中的每个键值对的键和值都是一个对象"></a>Redis数据库中的每个键值对的键和值都是一个对象</h4></li><li><h4 id="Redis共有字符串-列表-哈希-集合-有序集合五种类型对象-每种类型的对象至少都有两种或以上的编码方式-不同的编码方式可以在不同的使用场景上优化对象的使用效率"><a href="#Redis共有字符串-列表-哈希-集合-有序集合五种类型对象-每种类型的对象至少都有两种或以上的编码方式-不同的编码方式可以在不同的使用场景上优化对象的使用效率" class="headerlink" title="Redis共有字符串,列表,哈希,集合,有序集合五种类型对象,每种类型的对象至少都有两种或以上的编码方式,不同的编码方式可以在不同的使用场景上优化对象的使用效率"></a>Redis共有字符串,列表,哈希,集合,有序集合五种类型对象,每种类型的对象至少都有两种或以上的编码方式,不同的编码方式可以在不同的使用场景上优化对象的使用效率</h4></li><li><h4 id="服务器在执行某些命令之前-会先检查给定键的类型能否执行指定的命令-而检查一个键的类型就是检查键的值对象类型"><a href="#服务器在执行某些命令之前-会先检查给定键的类型能否执行指定的命令-而检查一个键的类型就是检查键的值对象类型" class="headerlink" title="服务器在执行某些命令之前,会先检查给定键的类型能否执行指定的命令,而检查一个键的类型就是检查键的值对象类型."></a>服务器在执行某些命令之前,会先检查给定键的类型能否执行指定的命令,而检查一个键的类型就是检查键的值对象类型.</h4></li><li><h4 id="Redis的的对象带有引用计数实现的内存回收机制-当一个对象不再被使用时-该对象所占用的内存就会被自动释放"><a href="#Redis的的对象带有引用计数实现的内存回收机制-当一个对象不再被使用时-该对象所占用的内存就会被自动释放" class="headerlink" title="Redis的的对象带有引用计数实现的内存回收机制,当一个对象不再被使用时,该对象所占用的内存就会被自动释放."></a>Redis的的对象带有引用计数实现的内存回收机制,当一个对象不再被使用时,该对象所占用的内存就会被自动释放.</h4></li><li><h4 id="Redis-会共享值-为-0-9999-的字符串对象"><a href="#Redis-会共享值-为-0-9999-的字符串对象" class="headerlink" title="Redis 会共享值 为 0-9999 的字符串对象"></a>Redis 会共享值 为 0-9999 的字符串对象</h4></li><li><h4 id="对象会记录自己的最后一次被访问的时间-这个时间可以用于计算对象的空转时间"><a href="#对象会记录自己的最后一次被访问的时间-这个时间可以用于计算对象的空转时间" class="headerlink" title="对象会记录自己的最后一次被访问的时间,这个时间可以用于计算对象的空转时间."></a>对象会记录自己的最后一次被访问的时间,这个时间可以用于计算对象的空转时间.</h4></li></ul><h2 id="第二部分-单机数据库的实现"><a href="#第二部分-单机数据库的实现" class="headerlink" title="第二部分   单机数据库的实现"></a>第二部分   单机数据库的实现</h2><h2 id="Chapter-9-数据库"><a href="#Chapter-9-数据库" class="headerlink" title="Chapter  9    数据库"></a>Chapter  9    数据库</h2><h3 id="9-1-服务器中的数据库"><a href="#9-1-服务器中的数据库" class="headerlink" title="9.1 服务器中的数据库"></a>9.1 服务器中的数据库</h3><ol><li><h4 id="Redis-服务器将所有数据库都保存再服务器状态-redis-h-x2F-redisServer-结构的db数组中-db数组的每个项都是一个redis-h-x2F-redisDb结构"><a href="#Redis-服务器将所有数据库都保存再服务器状态-redis-h-x2F-redisServer-结构的db数组中-db数组的每个项都是一个redis-h-x2F-redisDb结构" class="headerlink" title="Redis 服务器将所有数据库都保存再服务器状态 redis.h&#x2F;redisServer 结构的db数组中,db数组的每个项都是一个redis.h&#x2F;redisDb结构"></a>Redis 服务器将所有数据库都保存再服务器状态 redis.h&#x2F;redisServer 结构的db数组中,db数组的每个项都是一个redis.h&#x2F;redisDb结构</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725212856145.png" alt="image-20220725212856145"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725212904303.png" alt="image-20220725212904303"></p><h3 id="9-2-切换数据库"><a href="#9-2-切换数据库" class="headerlink" title="9.2   切换数据库"></a>9.2   切换数据库</h3><ol><li><h4 id="每个Redis客户端-都有自己的目标数据库-每当客户端执行数据库写命令或者数据库读命令的时候-目标数据库就会成为这些命令的操作对象"><a href="#每个Redis客户端-都有自己的目标数据库-每当客户端执行数据库写命令或者数据库读命令的时候-目标数据库就会成为这些命令的操作对象" class="headerlink" title="每个Redis客户端 都有自己的目标数据库,每当客户端执行数据库写命令或者数据库读命令的时候,目标数据库就会成为这些命令的操作对象"></a>每个Redis客户端 都有自己的目标数据库,每当客户端执行数据库写命令或者数据库读命令的时候,目标数据库就会成为这些命令的操作对象</h4></li><li><h4 id="默认情况下-Redis客户端的目标数据库为0号数据库-但客户端可以通过select-命令来切换目标数据库"><a href="#默认情况下-Redis客户端的目标数据库为0号数据库-但客户端可以通过select-命令来切换目标数据库" class="headerlink" title="默认情况下,Redis客户端的目标数据库为0号数据库,但客户端可以通过select  命令来切换目标数据库."></a>默认情况下,Redis客户端的目标数据库为0号数据库,但客户端可以通过select  命令来切换目标数据库.</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs redis">set msg  &quot;hello world &quot;<br><br>get msg <br><br>select 2 <br><br>set msg &quot;another hello world &quot;<br>get msg <br><br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725214926588.png" alt="image-20220725214926588"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725214938286.png" alt="image-20220725214938286"></p><ol><li><h4 id="谨慎处理多数据库程序"><a href="#谨慎处理多数据库程序" class="headerlink" title="谨慎处理多数据库程序"></a>谨慎处理多数据库程序</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725215016320.png" alt="image-20220725215016320"></p></li></ol><h3 id="9-3-数据库键空间"><a href="#9-3-数据库键空间" class="headerlink" title="9.3  数据库键空间"></a>9.3  数据库键空间</h3><ol><li><h4 id="Redis-是一个键值对数据库服务器-服务器中的每个数据库都由一哥redis-h-x2F-redisDb-结构表示"><a href="#Redis-是一个键值对数据库服务器-服务器中的每个数据库都由一哥redis-h-x2F-redisDb-结构表示" class="headerlink" title="Redis 是一个键值对数据库服务器,服务器中的每个数据库都由一哥redis.h&#x2F;redisDb 结构表示,"></a>Redis 是一个键值对数据库服务器,服务器中的每个数据库都由一哥redis.h&#x2F;redisDb 结构表示,</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725222512461.png" alt="image-20220725222512461"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725222518420.png" alt="image-20220725222518420"></p><h4 id="9-3-1-添加新键"><a href="#9-3-1-添加新键" class="headerlink" title="9.3.1   添加新键"></a>9.3.1   添加新键</h4><ol><li><h4 id="添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为人以一种类型的Redis对象。"><a href="#添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为人以一种类型的Redis对象。" class="headerlink" title="添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为人以一种类型的Redis对象。"></a>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为人以一种类型的Redis对象。</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs redis">set date &quot;2013.12.1&quot;<br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725222804121.png" alt="image-20220725222804121"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725222815211.png" alt="image-20220725222815211"></p><h4 id="9-3-2-删除键"><a href="#9-3-2-删除键" class="headerlink" title="9.3.2  删除键"></a>9.3.2  删除键</h4><ol><li><h4 id="删除数据库中的一个键，实际上就是在键空间里面删除键对应的键值对对象、"><a href="#删除数据库中的一个键，实际上就是在键空间里面删除键对应的键值对对象、" class="headerlink" title="删除数据库中的一个键，实际上就是在键空间里面删除键对应的键值对对象、"></a>删除数据库中的一个键，实际上就是在键空间里面删除键对应的键值对对象、</h4></li><li><p>~~~redis<br>del book</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>3. ![image-20220725223213471](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725223213471.png)<br><br><br><br>#### 9.3.3   更新键<br><br><br><br>1. #### 对一个数据库进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同、。<br><br>~~~redis<br>set message &quot;blah blah&quot; <br><br></code></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725224406521.png" alt="image-20220725224406521"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">hset book page 320  <br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725224427574.png" alt="image-20220725224427574"></p><h4 id="9-3-4-对键取值"><a href="#9-3-4-对键取值" class="headerlink" title="9.3.4     对键取值"></a>9.3.4     对键取值</h4><ol><li><h4 id="对一个数据库进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。"><a href="#对一个数据库进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。" class="headerlink" title="对一个数据库进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。"></a>对一个数据库进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">get message <br>&quot;hello world&quot;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725225033817.png" alt="image-20220725225033817"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">lrange alphabet 0 -1 <br><br></code></pre></td></tr></table></figure><ol><li><h4 id="LRANGE-命令将首先在键空间中查找alphabet，找到键之后接着取得该键所对应的列表对象值，之后再返回列表对象中包含的三个字符串对象的值。"><a href="#LRANGE-命令将首先在键空间中查找alphabet，找到键之后接着取得该键所对应的列表对象值，之后再返回列表对象中包含的三个字符串对象的值。" class="headerlink" title="LRANGE 命令将首先在键空间中查找alphabet，找到键之后接着取得该键所对应的列表对象值，之后再返回列表对象中包含的三个字符串对象的值。"></a>LRANGE 命令将首先在键空间中查找alphabet，找到键之后接着取得该键所对应的列表对象值，之后再返回列表对象中包含的三个字符串对象的值。</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725225212202.png" alt="image-20220725225212202"></p></li></ol><h4 id="9-3-5-其他键空间操作"><a href="#9-3-5-其他键空间操作" class="headerlink" title="9.3.5    其他键空间操作"></a>9.3.5    其他键空间操作</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725225430675.png" alt="image-20220725225430675"></p><h4 id="9-3-6-读写键空间时的维护操作"><a href="#9-3-6-读写键空间时的维护操作" class="headerlink" title="9.3.6    读写键空间时的维护操作"></a>9.3.6    读写键空间时的维护操作</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725225716555.png" alt="image-20220725225716555"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725225729292.png" alt="image-20220725225729292"></p><h3 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4   设置键的生存时间或过期时间"></a>9.4   设置键的生存时间或过期时间</h3><ol><li><h4 id="通过expire命令或pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。"><a href="#通过expire命令或pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。" class="headerlink" title="通过expire命令或pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。"></a>通过expire命令或pexpire命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。</h4></li><li><p>~~~redis<br>set key value<br>expire key 5<br>get key</p><p>get key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>3. <br><br><br><br>![image-20220725233729046](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725233729046.png)<br><br>![image-20220725233741925](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220725233741925.png)<br><br><br><br><br><br><br><br><br><br>#### 9.4.1       设置过期时间<br><br><br><br>![image-20220726124550354](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124550354.png)<br><br>![image-20220726124605118](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124605118.png)<br><br>![image-20220726124612815](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124612815.png)<br><br><br><br><br><br>#### 9.4.2     保存过期时间<br><br><br><br>![image-20220726124730262](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124730262.png)<br><br>![image-20220726124741015](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124741015.png)<br><br><br><br><br><br><br><br>![image-20220726124758352](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726124758352.png)<br><br><br><br><br><br><br><br><br><br>#### 9.4.3       移除过期时间    <br><br><br><br>~~~redis<br>pexpireat message 13912344000000<br><br>TTL message <br><br>persist message  <br><br>ttl message  <br><br></code></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726130524834.png" alt="image-20220726130524834"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726130535724.png" alt="image-20220726130535724"></p><h4 id="9-4-4-计算并返回剩余生存时间"><a href="#9-4-4-计算并返回剩余生存时间" class="headerlink" title="9.4.4      计算并返回剩余生存时间"></a>9.4.4      计算并返回剩余生存时间</h4><ol><li><h4 id="TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。"><a href="#TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。" class="headerlink" title="TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。"></a>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。</h4></li><li><p>~~~redis<br>pexpireat w alphabet  13821309812038129031</p><p>TTL alphabet  </p><p>PTTL  alphabet </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>3. ![image-20220726131204136](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726131204136.png)<br><br><br><br>![image-20220726131210347](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726131210347.png)<br><br><br><br><br><br>#### 9.4.5     过期键的判定<br><br><br><br>1. #### 通过过期字典，程序可以用以下步骤检查一个给定键是否过期：<br><br>   1. #### 检查给定键是否在于过期字典：如果存在，那么取得键的过期时间<br><br>   2. #### 检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期，反之，键没有过期。<br><br><br><br>![image-20220726132505729](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726132505729.png)<br><br><br><br>![image-20220726132513445](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726132513445.png)<br><br>![image-20220726132518661](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726132518661.png)<br><br><br><br><br><br><br><br><br><br>### 9.5  过期键删除策略<br><br><br><br>1. #### 如果一个键过期了，那么它什么时候会被删除呢？<br><br>- #### 那个答案，代表了三种不同的策略：<br><br>  - #### 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作<br><br>  - #### 惰性删除：放任键过期不管，但是每次从键空间中获得键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，空就返回改键 <br><br>  - #### 定期删除： 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则有算法决定。<br><br>- #### 这三种策略中，第一种和第三种为主动删除策略，而第二种为被动删除策略。<br><br><br><br><br><br><br><br><br><br>#### 9.5.1    定时删除<br><br><br><br>1. #### 对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能地被删除，并释放过期键所占用地内存<br><br>2. #### 另一方面，定时删除策略地缺点是：他对CPU时间是最不友好的：在过期间键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张下但是CPU时间非常紧张的情况下，将CPU时间用在删除和当天任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。<br><br>3. #### ![image-20220726161444517](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726161444517.png)。<br><br><br><br><br><br><br><br><br><br>#### 9.5.2   惰性删除 <br><br><br><br>1. #### 惰性删除策略对CPU时间来说是最友好的，程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。<br><br>2. #### 惰性删除的缺点是：他对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放<br><br>3. #### 在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么他们也许永远也不会被删除（除非用户手动FLUSHDB），我们甚至可以将这种情况看成是一种内存泄漏----无用的垃圾数据占用了大量的内存，而服务器缺不会自己去释放他们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。<br><br><br><br>![image-20220726162241408](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726162241408.png)<br><br><br><br><br><br>#### 9.5.3    定期删除  <br><br><br><br><br><br>![image-20220726162414560](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726162414560.png)<br><br><br><br>1. #### 如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>### 9.6     Redis  的过期键删除策略<br><br><br><br>1. #### 对服务器中，惰性删除和定期删除的具体实现进行说明。<br><br><br><br><br><br><br><br>#### 9.6.1    惰性删除策略的实现<br><br><br><br><br><br>![image-20220726163509629](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163509629.png)<br><br><br><br><br><br>![image-20220726163520112](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163520112.png)<br><br><br><br><br><br><br><br><br><br><br><br>#### 9.6.2       定期删除策略的实现<br><br><br><br>![image-20220726163610498](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163610498.png)<br><br>![image-20220726163631865](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163631865.png)<br><br>![image-20220726163641353](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163641353.png)<br><br>![image-20220726163649908](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163649908.png)<br><br><br><br>![image-20220726163655310](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726163655310.png)<br><br><br><br><br><br><br><br><br><br>### 9.7  AOF ，  RDB 和 复制功能对过期键的处理<br><br><br><br>1. #### 探讨过期键对Redis 服务器其他模块的影响，看看RDB持久化功能，AOF持久化功能以及复制功能是如何处理数据库中的过期键的。<br><br><br><br><br><br><br><br>#### 9.7.1    生成 RDB文件<br><br><br><br>1. #### 在执行SAVE命令或者BGSAVE命令 创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。<br><br>2. #### 例如： 如果数据库中 包含三个键 k1, k2 , k3, 并且k2已经到期，那么当执行SAVE命令或者BGSAVE命令时，程序只会将k1和k3的数据保存到RDB文件中，而K2则会被忽略<br><br>3. #### 因此，数据库中包含过期键不会对生成的RDB文件造成影响。、<br><br><br><br><br><br><br><br><br><br>#### 9.7.2     载入RDB文件<br><br><br><br>1. #### 在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：<br><br>   1. #### 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件保存的键进行检查，未过期的键会被载入到数据库中，而过期的键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响<br><br>   2. #### 如果服务器以服务器模式运行，那么在载入RDB文件时，文件中所保存的所有键，不论是否过期，都会被载入到数据库中，不过，因为主从服务器在进行数据库同步的时候，从服务器的数据库就会被清空，所以一般来讲，==过期键对载入RDB文件的从服务器也不会造成影响==。<br><br>2. #### 举个例子 ， 如果数据库中包含三个键 k1, k2 ,k3,  并且k2已经过期，那么当服务器启动时：<br><br>   1. #### 如果服务器以主服务器模式运行，那么程序指挥将k1，和  k3，载入到数据库，k2会被忽略，<br><br>   2. #### 如果服务器以服务器模式运行，那么k1,k2,和 k3都会被载入到数据库中。<br><br><br><br><br><br><br><br><br><br>#### 9.7.3    AOF文件写入 <br><br><br><br>1. #### 当服务器以AOF持久化模式运行时，==如果数据库中的某个键已经过期，但它还没有惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。==<br><br>2. #### 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显示地记录该键已被删除<br><br>3. #### 举个例子，如果客户端使用GET message 命令，试图访问过期的message键，那么服务器将执行以下三个动作：<br><br>   1. #### 从数据库中删除message键<br><br>   2. #### 追加一条DEL messge 命令到AOF 文件<br><br>   3. #### 向执行get 命令地客户端返回空恢复。<br><br><br><br><br><br><br><br><br><br>#### 9.7.4    AOF 文件重写<br><br><br><br>1. #### 和生成的RDB文件时类似，==在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。==<br><br>2. #### 举个例子：如果数据库中包含 三个键  k1, k2 , k3 并且 k2 已经过期，那么在进行重写工作时，程序只会对k1,和k3 进行重写，而k2则会忽略。<br><br>3. #### ==因此，数据库中包含过期键，不会对AOF重写造成影响.==<br><br><br><br><br><br><br><br><br><br><br><br><br><br>#### 9.7.5    复制  <br><br><br><br>1. #### 当服务器运行在复制模式下时,==从服务器的过程键删除动作由主服务器控制==<br><br>   1. #### 当服务器在删除一个过期键之后,会显示地向所有从服务器发送一个DEL命令,告诉从服务器删除这个过期键<br><br>   2. #### 从服务器在执行客户端发来的命令时,即使碰到过期键越不会将过期键删除,而是继续将处理未过期的键一样来处理过期键<br><br>   3. #### 从服务器只有在街道主服务器发来的DEL命令之后,才会删除过期键.<br><br><br><br><br><br>- #### ==通过由主服务器来控制从服务器统一地删除过期键,可以保证主从服务器数据地一致性==,也正是因为这个原因,当一个过期键仍然存在于主服务器地数据库时,这个过期键在从服务器里的复制品也会继续存在,<br><br>- <br><br>![image-20220726205820145](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726205820145.png)<br><br><br><br>- ### 例子<br><br><br><br>![image-20220726205847275](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726205847275.png)<br><br>![image-20220726205857513](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726205857513.png)<br><br>![image-20220726210008251](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726210008251.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 9.8   数据库通知<br><br><br><br>1. #### 数据库通知是Redis新增加的功能,这个功能可以让客户端通过订阅给定的频道或者模式,来获知数据库中键的变化,以及数据库中命令的执行情况。<br><br><br><br>![image-20220726213300069](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726213300069.png)<br><br>![image-20220726213307594](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726213307594.png)<br><br><br><br><br><br>1. #### 根据发回的通知显示，先后共有SET，EXPIRE（Redis Expire 命令用于设置 key 的过期时间，key 过期后将不再可用。单位以秒计） ,DEL   三个命令对键message 进行了操作。<br><br><br><br>![image-20220726213614709](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726213614709.png)<br><br>![image-20220726213638528](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726213638528.png)<br><br><br><br><br><br><br><br><br><br><br><br><br><br>#### 9.8.1    发送通知<br><br><br><br><br><br>![image-20220726214258878](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726214258878.png)<br><br><br><br>![image-20220726214310075](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726214310075.png)<br><br><br><br><br><br>![image-20220726214545543](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726214545543.png)<br><br>![image-20220726214553639](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726214553639.png)<br><br><br><br><br><br><br><br><br><br><br><br>#### 9.8.2   发送通知实现<br><br><br><br>1. #### notifykeysapceEvent 函数的伪代码实现：<br><br><br><br>![image-20220726215443912](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726215443912.png)<br><br><br><br><br><br>![image-20220726215521045](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220726215521045.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 9.9  重点回顾 <br><br><br><br>1. #### Redis服务器的所有数据都保存在redisServer.db 数组中，而数据库的数量则由redisServer.dbnum 属性保存<br><br>2. #### 客户端通过修改目标数据库指针，让它指向redisServer.db 数组中不同元素来切换不同数据库<br><br>3. #### 数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间<br><br>4. #### 因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的<br><br>5. #### 数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象，哈希表对象，集合对象，列表对象，和有序集合对象，分别对应字符串键，哈希表键，集合键，列标键，和有序集合键<br><br>6. #### expires 字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的unix时间戳<br><br>7. #### Redis使用惰性删除和定期删除两种策略来删除过期键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间，主动查找并删除过期键<br><br>8. #### 执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键<br><br>9. #### 当一个过期被删除后，服务器会追加一条DEL命令到现有的AOF文件末尾，显示地删除过期键<br><br>10. #### 当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键<br><br>11. #### 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一，中性化的过期键删除策略可以保证主从服务器数据的一致性<br><br>12. #### 当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>## Chapter 10      RDB 持久化<br><br><br><br>- #### 数据库状态：==服务器中的非空数据库以及他们的键值对状态统称为数据库状态。==<br><br><br><br>1. #### 为了解决服务器进程退出，服务器中数据库进程状态也会消失不见得的问题，Redis提供了RDB持久化功能.这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失<br><br>2. #### RDB持久化即可以手动执行，也可以根据服务器配置选项定期执行，该功能能将某个时间点上的数据库状态保存到一个RDB文件中<br><br>3. #### ![image-20220802132025394](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802132025394.png)。<br><br><br><br><br><br><br><br>1. #### 因为RDB文件是保存在硬盘里面的，所以即使redis服务器进程退出，甚至运行redis服务器的计算机停机，但只要RDB文件存在，Redis服务器就能用它来还原数据库服务器状态。<br><br><br><br><br><br><br><br><br><br>### 10.1   RDB文件的创建和载入<br><br><br><br>1. #### 有两个命令可用于RDB文件的生成，SAVE 和  BGSAVE。<br><br>2. #### SAVE命令会==阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令。==<br><br>3. #### BGSAVE命令则是会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。<br><br><br><br>- #### 利用save和bgsave 命令创建RDB文件不同，RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，他就会自动载入RDB文件。<br><br><br><br>1. #### 因为AOF文件的更新频率通常比RDB文件的更新频率更高，所以：<br><br>   1. #### 如果服务器开启了AOF持久化，那么服务器会优先使用AOF文件来还原数据库状态<br><br>   2. #### 只有在AOF持久化功能处于关闭状态，服务器才会使用RDB文件来还原数据库状态，服务器判断该用哪个文件来还原数据库状态的流程如下<br><br>   3. #### ![image-20220802133805932](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802133805932.png)。<br><br><br><br><br><br>![image-20220802133857633](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802133857633.png)<br><br><br><br><br><br><br><br>![image-20220802133908139](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802133908139.png)<br><br><br><br>![image-20220802133918809](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802133918809.png)<br><br><br><br><br><br>1. #### save命令时所有命令都不能被接收<br><br>2. #### BGSAVE命令时，SAVE，BGSAVE，BGREWRITEAOF也会被拒绝、<br><br><br><br><br><br><br><br>#### 10.1.3  RDB文件载入时的服务器状态<br><br><br><br>1. #### 服务器在载入RDB文件期间，会一直处于阻塞状态，知道载入工作完成。<br><br><br><br><br><br><br><br><br><br>### 10.2   自动间隔性保存<br><br><br><br>1. #### 因为BGSAVE命令可以在不阻塞服务器进程情况下进行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。<br><br>2. #### 用户可以通过SAVE选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。<br><br><br><br><br><br>![image-20220802135536967](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802135536967.png)<br><br>![image-20220802135546347](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802135546347.png)<br><br><br><br>![image-20220802135849450](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802135849450.png)<br><br><br><br>![image-20220802135657716](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802135657716.png)<br><br><br><br><br><br><br><br><br><br>#### 10.2.2   dirty 计数器和lastsave属性<br><br><br><br>1. #### 除了saveparams 数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：<br><br>   1. #### dirty计数器记录距离上一次成功执行save命令或者bgsave命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括==写入，删除，更新等操作==）<br><br>   2. #### lastsave 属性是一个unix时间戳，记录了服务器上一次成功执行save命令或者bgsave命令的时间。<br><br>   3. #### 。<br><br><br><br>![image-20220802140625273](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802140625273.png)<br><br>![image-20220802140629844](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802140629844.png)<br><br><br><br><br><br><br><br><br><br>#### 10.2.3     检查保存条件是否满足<br><br><br><br><br><br>1. #### Redis的服务器周期性操作函数serverCron默认每隔100ms就会执行一次，该函数用于对正在运行的服务器进行维护，他的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足就会执行BGSAVE命令。<br><br><br><br>![image-20220802140959037](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802140959037.png)<br><br><br><br>![image-20220802141011618](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802141011618.png)<br><br><br><br><br><br>![image-20220802141027675](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802141027675.png)<br><br><br><br>![image-20220802141036886](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802141036886.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 10.3   RDB文件结构<br><br><br><br><br><br>![image-20220802141844009](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802141844009.png)<br><br><br><br><br><br>1. #### RDB文件最开头是==REDIS==部分，这个部分的长度是5字节，保存着REDIS五个字符，通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否含有RDB文件。<br><br>####  <br><br>![image-20220802142116194](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142116194.png)<br><br><br><br>![](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142239909.png)<br><br>![image-20220802142253003](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142253003.png)<br><br>![image-20220802142303778](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142303778.png)<br><br><br><br><br><br><br><br>#### 10.3.1   database 部分<br><br><br><br>1. #### 一个RDB文件的database部分可以保存任意多个非空数据库。<br><br>2. #### 如：<br><br>![image-20220802142449870](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142449870.png)<br><br><br><br>![image-20220802142547556](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142547556.png)<br><br>![image-20220802142710468](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802142710468.png)<br><br><br><br><br><br><br><br>#### 10.3.2   key_value_pairs 部分 <br><br><br><br><br><br>![image-20220802143030398](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802143030398.png)<br><br>![image-20220802143038327](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802143038327.png)<br><br>![image-20220802143049304](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802143049304.png)<br><br><br><br><br><br><br><br>#### 10.3.3     value的编码<br><br><br><br>1. #### 字符串对象<br><br>![image-20220802144218764](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144218764.png)<br><br>![image-20220802144233052](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144233052.png)<br><br>![image-20220802144244037](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144244037.png)<br><br>![image-20220802144251180](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144251180.png)<br><br><br><br><br><br><br><br><br><br>1. #### 列表对象<br><br><br><br><br><br>![image-20220802144505239](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144505239.png)<br><br><br><br><br><br>1. #### 集合对象<br><br>![image-20220802144529319](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144529319.png)<br><br>![image-20220802144640316](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802144640316.png)<br><br><br><br><br><br><br><br>1. #### 哈希表对象<br><br><br><br>![image-20220802145426848](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145426848.png)<br><br><br><br>![image-20220802145444015](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145444015.png)<br><br>1. #### 有序集合对象<br><br><br><br>![image-20220802145621514](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145621514.png)<br><br>![image-20220802145630308](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145630308.png)<br><br><br><br><br><br>1. #### intset编码的集合<br><br><br><br>![image-20220802145800735](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145800735.png)<br><br><br><br><br><br>1. #### ziplist  编码的列表，哈希集合或者有序集合<br><br><br><br>![image-20220802145933112](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145933112.png)<br><br>![image-20220802145941408](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802145941408.png)<br><br><br><br><br><br><br><br><br><br><br><br>### 10.4   分析RDB文件<br><br><br><br>![image-20220802154810873](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802154810873.png)<br><br><br><br>#### 10.4.1  不包含任何键值对的RDB文件<br><br><br><br><br><br>![image-20220802155054174](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802155054174.png)<br><br>![image-20220802155104151](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802155104151.png)<br><br><br><br><br><br><br><br>#### 10.4.2   包含字符串键的RDB文件<br><br><br><br><br><br>![image-20220802175508642](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802175508642.png)<br><br>![image-20220802175524226](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802175524226.png)<br><br><br><br><br><br><br><br>#### 10.4.3    包含带有过期时间的字符串键的RDB文件<br><br><br><br><br><br>![image-20220802180227942](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802180227942.png)<br><br><br><br>![image-20220802180511412](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802180511412.png)<br><br><br><br><br><br><br><br><br><br>#### 10.4.4     包含一个集合键的RDB文件<br><br><br><br>~~~redis<br>flushall <br><br>sadd lang &quot;C&quot; &quot;redis&quot; &quot;java&quot;<br><br><br></code></pre></td></tr></table></figure></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802180937716.png" alt="image-20220802180937716"></p><h4 id="10-4-5-关于分析-RDB文件的说明"><a href="#10-4-5-关于分析-RDB文件的说明" class="headerlink" title="10.4.5   关于分析  RDB文件的说明"></a>10.4.5   关于分析  RDB文件的说明</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802181304633.png" alt="image-20220802181304633"></p><h3 id="10-5-重点回顾"><a href="#10-5-重点回顾" class="headerlink" title="10.5  重点回顾"></a>10.5  重点回顾</h3><ol><li><h4 id="RDB文件用于保存和还原redis服务器所有的数据库中的所有键值对数据"><a href="#RDB文件用于保存和还原redis服务器所有的数据库中的所有键值对数据" class="headerlink" title="RDB文件用于保存和还原redis服务器所有的数据库中的所有键值对数据"></a>RDB文件用于保存和还原redis服务器所有的数据库中的所有键值对数据</h4></li><li><h4 id="save命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器"><a href="#save命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器" class="headerlink" title="save命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器"></a>save命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器</h4></li><li><h4 id="BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器"><a href="#BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器" class="headerlink" title="BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器"></a>BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器</h4></li><li><h4 id="服务器状态中会保存所有save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令"><a href="#服务器状态中会保存所有save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令" class="headerlink" title="服务器状态中会保存所有save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令"></a>服务器状态中会保存所有save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令</h4></li><li><h4 id="RDB文件是一个经过压缩的二进制文件，由多个部分组成"><a href="#RDB文件是一个经过压缩的二进制文件，由多个部分组成" class="headerlink" title="RDB文件是一个经过压缩的二进制文件，由多个部分组成"></a>RDB文件是一个经过压缩的二进制文件，由多个部分组成</h4></li><li><h4 id="对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。"><a href="#对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。" class="headerlink" title="对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。"></a>对于不同类型的键值对，RDB文件会使用不同的方式来保存他们。</h4></li></ol><h2 id="Chapter-11-AOF持久化"><a href="#Chapter-11-AOF持久化" class="headerlink" title="Chapter 11    AOF持久化"></a>Chapter 11    AOF持久化</h2><ol><li><h4 id="除了RDB持久化功能之外，Redis还提供了AOF（append-only-file）持久化功能，-x3D-x3D-与RDB持久化功能通过保存数据库中的键值对来记录数据库状态不同，AOF持久化通过保存redis服务器所执行的写命令来记录数据库状态-x3D-x3D-。"><a href="#除了RDB持久化功能之外，Redis还提供了AOF（append-only-file）持久化功能，-x3D-x3D-与RDB持久化功能通过保存数据库中的键值对来记录数据库状态不同，AOF持久化通过保存redis服务器所执行的写命令来记录数据库状态-x3D-x3D-。" class="headerlink" title="除了RDB持久化功能之外，Redis还提供了AOF（append only file）持久化功能，&#x3D;&#x3D;与RDB持久化功能通过保存数据库中的键值对来记录数据库状态不同，AOF持久化通过保存redis服务器所执行的写命令来记录数据库状态&#x3D;&#x3D;。"></a>除了RDB持久化功能之外，Redis还提供了AOF（append only file）持久化功能，&#x3D;&#x3D;与RDB持久化功能通过保存数据库中的键值对来记录数据库状态不同，AOF持久化通过保存redis服务器所执行的写命令来记录数据库状态&#x3D;&#x3D;。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802182334304.png" alt="image-20220802182334304"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs redis">set msg &quot;hello<br>sadd fruits &quot;apple&quot; &quot;bannana&quot; &quot;chrry&quot;<br>rpush numbers 128 256 512  <br><br></code></pre></td></tr></table></figure><ol><li><h4 id="AOF持久化保存数据库状态的方法是将服务器执行的-set-，sadd，rpush-三个命令保存到AOF文件中。"><a href="#AOF持久化保存数据库状态的方法是将服务器执行的-set-，sadd，rpush-三个命令保存到AOF文件中。" class="headerlink" title="AOF持久化保存数据库状态的方法是将服务器执行的 set ，sadd，rpush 三个命令保存到AOF文件中。"></a>AOF持久化保存数据库状态的方法是将服务器执行的 set ，sadd，rpush 三个命令保存到AOF文件中。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802182905328.png" alt="image-20220802182905328"></p><ol><li><h4 id="服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。以下是服务器载入AOF文件并还原数据库状态时打印的日志。"><a href="#服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。以下是服务器载入AOF文件并还原数据库状态时打印的日志。" class="headerlink" title="服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。以下是服务器载入AOF文件并还原数据库状态时打印的日志。"></a>服务器在启动时，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。以下是服务器载入AOF文件并还原数据库状态时打印的日志。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802183129835.png" alt="image-20220802183129835"></p><h3 id="11-1-AOF-持久化的实现"><a href="#11-1-AOF-持久化的实现" class="headerlink" title="11.1    AOF 持久化的实现"></a>11.1    AOF 持久化的实现</h3><ol><li><h4 id="AOF持久化功能的实现-x3D-x3D-可以追加-append-，文件写入，文件同步，-x3D-x3D-三个步骤。"><a href="#AOF持久化功能的实现-x3D-x3D-可以追加-append-，文件写入，文件同步，-x3D-x3D-三个步骤。" class="headerlink" title="AOF持久化功能的实现&#x3D;&#x3D;可以追加 append  ，文件写入，文件同步，&#x3D;&#x3D;三个步骤。"></a>AOF持久化功能的实现&#x3D;&#x3D;可以追加 append  ，文件写入，文件同步，&#x3D;&#x3D;三个步骤。</h4></li></ol><h4 id="11-1-1-命令追加"><a href="#11-1-1-命令追加" class="headerlink" title="11.1.1  命令追加"></a>11.1.1  命令追加</h4><ol><li><h4 id="当AOF-持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的-aof-buf-缓冲区的末尾。"><a href="#当AOF-持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的-aof-buf-缓冲区的末尾。" class="headerlink" title="当AOF 持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。"></a>当AOF 持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802183739238.png" alt="image-20220802183739238"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802183745288.png" alt="image-20220802183745288"></p><h4 id="11-1-2-AOF文件的写入与同步"><a href="#11-1-2-AOF文件的写入与同步" class="headerlink" title="11.1.2   AOF文件的写入与同步"></a>11.1.2   AOF文件的写入与同步</h4><ul><li><h4 id="Redis的-服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行像serverCron函数这样需要定时运行的函数。"><a href="#Redis的-服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行像serverCron函数这样需要定时运行的函数。" class="headerlink" title="Redis的 服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行像serverCron函数这样需要定时运行的函数。"></a>Redis的 服务器进程就是一个事件循环，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复。而时间事件则负责执行像serverCron函数这样需要定时运行的函数。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184237561.png" alt="image-20220802184237561"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184300711.png" alt="image-20220802184300711"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184318368.png" alt="image-20220802184318368"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184328303.png" alt="image-20220802184328303"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184335161.png" alt="image-20220802184335161"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802184343972.png" alt="image-20220802184343972"></p><h3 id="11-2-AOF文件的载入与数据还原"><a href="#11-2-AOF文件的载入与数据还原" class="headerlink" title="11.2    AOF文件的载入与数据还原"></a>11.2    AOF文件的载入与数据还原</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802185905930.png" alt="image-20220802185905930"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220802185913803.png" alt="image-20220802185913803"></p><h3 id="11-3-AOF重写"><a href="#11-3-AOF重写" class="headerlink" title="11.3  AOF重写"></a>11.3  AOF重写</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803104218536.png" alt="image-20220803104218536"></p><ol><li><h4 id="为了解决AOF文件体积膨胀的问题，Redis-提供了AOF文件重写-rewrite-功能，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，-x3D-x3D-但新文件AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小得多。-x3D-x3D"><a href="#为了解决AOF文件体积膨胀的问题，Redis-提供了AOF文件重写-rewrite-功能，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，-x3D-x3D-但新文件AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小得多。-x3D-x3D" class="headerlink" title="为了解决AOF文件体积膨胀的问题，Redis 提供了AOF文件重写(rewrite)功能，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，&#x3D;&#x3D;但新文件AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小得多。&#x3D;&#x3D;"></a>为了解决AOF文件体积膨胀的问题，Redis 提供了AOF文件重写(rewrite)功能，通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，&#x3D;&#x3D;但新文件AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积小得多。&#x3D;&#x3D;</h4></li></ol><h4 id="11-3-1-AOF文件重写的实现"><a href="#11-3-1-AOF文件重写的实现" class="headerlink" title="11.3.1  AOF文件重写的实现"></a>11.3.1  AOF文件重写的实现</h4><ol><li><h4 id="Redis将生成新的AOF文件替换旧的AOF文件的功能命名为”AOF文件重写”，但实际上，-x3D-x3D-AOF文件重写并不需要对现有的AOF文件进行任何读取，分析，或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。"><a href="#Redis将生成新的AOF文件替换旧的AOF文件的功能命名为”AOF文件重写”，但实际上，-x3D-x3D-AOF文件重写并不需要对现有的AOF文件进行任何读取，分析，或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。" class="headerlink" title="Redis将生成新的AOF文件替换旧的AOF文件的功能命名为”AOF文件重写”，但实际上，&#x3D;&#x3D;AOF文件重写并不需要对现有的AOF文件进行任何读取，分析，或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。"></a>Redis将生成新的AOF文件替换旧的AOF文件的功能命名为”AOF文件重写”，但实际上，&#x3D;&#x3D;AOF文件重写并不需要对现有的AOF文件进行任何读取，分析，或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</h4></li><li><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105025581.png" alt="image-20220803105025581"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105035069.png" alt="image-20220803105035069"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105104651.png" alt="image-20220803105104651"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105304731.png" alt="image-20220803105304731"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105321785.png" alt="image-20220803105321785"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803105458652.png" alt="image-20220803105458652"></p><h4 id="11-3-2-AOF-后台重写"><a href="#11-3-2-AOF-后台重写" class="headerlink" title="11.3.2  AOF  后台重写"></a>11.3.2  AOF  后台重写</h4><ol><li><h4 id="Redis-服务器使用单个线程来处理命令，如果由服务器直接调用aof-rewrite-函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求："><a href="#Redis-服务器使用单个线程来处理命令，如果由服务器直接调用aof-rewrite-函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求：" class="headerlink" title="Redis 服务器使用单个线程来处理命令，如果由服务器直接调用aof_rewrite 函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求："></a>Redis 服务器使用单个线程来处理命令，如果由服务器直接调用aof_rewrite 函数的话，那么在重写AOF文件期间，服务器将无法处理客户端发来的命令请求：</h4><ol><li><h4 id="Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放入到子程序中进行，以达成目的："><a href="#Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放入到子程序中进行，以达成目的：" class="headerlink" title="Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放入到子程序中进行，以达成目的："></a>Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放入到子程序中进行，以达成目的：</h4><ol><li><h4 id="子进程进行AOF重写期间，服务器进程-父进程-可以继续处理命令"><a href="#子进程进行AOF重写期间，服务器进程-父进程-可以继续处理命令" class="headerlink" title="子进程进行AOF重写期间，服务器进程(父进程)可以继续处理命令"></a>子进程进行AOF重写期间，服务器进程(父进程)可以继续处理命令</h4></li><li><h4 id="子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。"><a href="#子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。" class="headerlink" title="子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。"></a>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</h4></li></ol></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803110603588.png" alt="image-20220803110603588"></p></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803110622119.png" alt="image-20220803110622119"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803110635060.png" alt="image-20220803110635060"></p><ul><li><h4 id="为了解决数据不一致问题，Redis-服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用"><a href="#为了解决数据不一致问题，Redis-服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用" class="headerlink" title="为了解决数据不一致问题，Redis 服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用"></a>为了解决数据不一致问题，Redis 服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用</h4></li><li><h4 id="当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区"><a href="#当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区" class="headerlink" title="当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区"></a>当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区</h4></li><li><h4 id="在子进程执行AOF重写期间，服务器进程需要执行以下三个工作："><a href="#在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：" class="headerlink" title="在子进程执行AOF重写期间，服务器进程需要执行以下三个工作："></a>在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</h4><ul><li><h4 id="执行客户端发来的命令"><a href="#执行客户端发来的命令" class="headerlink" title="执行客户端发来的命令"></a>执行客户端发来的命令</h4></li><li><h4 id="将执行后的写命令追加到AOF缓冲区"><a href="#将执行后的写命令追加到AOF缓冲区" class="headerlink" title="将执行后的写命令追加到AOF缓冲区"></a>将执行后的写命令追加到AOF缓冲区</h4></li><li><h4 id="将执行后的写命令追加到AOF重写缓冲区。"><a href="#将执行后的写命令追加到AOF重写缓冲区。" class="headerlink" title="将执行后的写命令追加到AOF重写缓冲区。"></a>将执行后的写命令追加到AOF重写缓冲区。</h4></li></ul></li></ul><ol><li><h4 id="这样一来可以保证："><a href="#这样一来可以保证：" class="headerlink" title="这样一来可以保证："></a>这样一来可以保证：</h4><ol><li><h4 id="AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行"><a href="#AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行" class="headerlink" title="AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行"></a>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行</h4></li><li><h4 id="从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面"><a href="#从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面" class="headerlink" title="从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面"></a>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面</h4></li><li><h4 id="当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作："><a href="#当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：" class="headerlink" title="当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作："></a>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</h4><ol><li><h4 id="将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致"><a href="#将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致" class="headerlink" title="将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致"></a>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致</h4></li><li><h4 id="对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换"><a href="#对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换" class="headerlink" title="对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换"></a>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换</h4></li></ol></li></ol></li><li><h4 id="这个信号处理函数执行完毕之后，父进程就可以像往常一样接受命令请求了"><a href="#这个信号处理函数执行完毕之后，父进程就可以像往常一样接受命令请求了" class="headerlink" title="这个信号处理函数执行完毕之后，父进程就可以像往常一样接受命令请求了"></a>这个信号处理函数执行完毕之后，父进程就可以像往常一样接受命令请求了</h4></li><li><h4 id="在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。"><a href="#在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。" class="headerlink" title="在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。"></a>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</h4></li><li><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803114613406.png" alt="image-20220803114613406"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803114654704.png" alt="image-20220803114654704"></p><h3 id="11-4-重点回顾"><a href="#11-4-重点回顾" class="headerlink" title="11.4    重点回顾"></a>11.4    重点回顾</h3><ul><li><h4 id="AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态"><a href="#AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态" class="headerlink" title="AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态"></a>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态</h4></li><li><h4 id="AOF文件中的所有命令都以Redis命令请求协议的格式保存"><a href="#AOF文件中的所有命令都以Redis命令请求协议的格式保存" class="headerlink" title="AOF文件中的所有命令都以Redis命令请求协议的格式保存"></a>AOF文件中的所有命令都以Redis命令请求协议的格式保存</h4></li><li><h4 id="命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件"><a href="#命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件" class="headerlink" title="命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件"></a>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件</h4></li><li><h4 id="appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器性能有很大的影响。"><a href="#appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器性能有很大的影响。" class="headerlink" title="appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器性能有很大的影响。"></a>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器性能有很大的影响。</h4></li><li><h4 id="服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态"><a href="#服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态" class="headerlink" title="服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态"></a>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态</h4></li><li><h4 id="AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态是一致的，但体积更小"><a href="#AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态是一致的，但体积更小" class="headerlink" title="AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态是一致的，但体积更小"></a>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原来的AOF文件所保存的数据库状态是一致的，但体积更小</h4></li><li><h4 id="AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无需对现有的AOF文件进行任何读入，分析，或者写入操作"><a href="#AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无需对现有的AOF文件进行任何读入，分析，或者写入操作" class="headerlink" title="AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无需对现有的AOF文件进行任何读入，分析，或者写入操作"></a>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无需对现有的AOF文件进行任何读入，分析，或者写入操作</h4></li><li><h4 id="在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令，当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中所有的内容追加到新AOF文件的末尾，这使得新旧两个AOF文件所保存的数据库状态一致，最后服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。"><a href="#在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令，当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中所有的内容追加到新AOF文件的末尾，这使得新旧两个AOF文件所保存的数据库状态一致，最后服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。" class="headerlink" title="在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令，当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中所有的内容追加到新AOF文件的末尾，这使得新旧两个AOF文件所保存的数据库状态一致，最后服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。"></a>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令，当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中所有的内容追加到新AOF文件的末尾，这使得新旧两个AOF文件所保存的数据库状态一致，最后服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</h4></li></ul><h2 id="Chapter-12-事件"><a href="#Chapter-12-事件" class="headerlink" title="Chapter  12   事件"></a>Chapter  12   事件</h2><ol><li><h4 id="Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件："><a href="#Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：" class="headerlink" title="Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件："></a>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：</h4><ol><li><h4 id="文件事件：Redis-服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作"><a href="#文件事件：Redis-服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作" class="headerlink" title="文件事件：Redis  服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作"></a>文件事件：Redis  服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作</h4></li><li><h4 id="时间事件，Redis服务器中的一些操作，（比如serverCron函数）需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。"><a href="#时间事件，Redis服务器中的一些操作，（比如serverCron函数）需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。" class="headerlink" title="时间事件，Redis服务器中的一些操作，（比如serverCron函数）需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。"></a>时间事件，Redis服务器中的一些操作，（比如serverCron函数）需要在给定的事件点执行，而时间事件就是服务器对这类定时操作的抽象。</h4></li></ol></li></ol><h3 id="12-1-文件事件"><a href="#12-1-文件事件" class="headerlink" title="12.1   文件事件"></a>12.1   文件事件</h3><ul><li><h4 id="Redis-基础Reactor-模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file-event-handler）-："><a href="#Redis-基础Reactor-模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file-event-handler）-：" class="headerlink" title="Redis  基础Reactor  模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）  ："></a>Redis  基础Reactor  模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）  ：</h4><ul><li><h4 id="文件事件处理器使用-I-x2F-O-多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器"><a href="#文件事件处理器使用-I-x2F-O-多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器" class="headerlink" title="文件事件处理器使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器"></a>文件事件处理器使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器</h4></li><li><h4 id="当监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。"><a href="#当监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。" class="headerlink" title="当监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。"></a>当监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</h4></li></ul></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803173544953.png" alt="image-20220803173544953"></p><h4 id="12-1-1-文件事件处理器的构成"><a href="#12-1-1-文件事件处理器的构成" class="headerlink" title="12.1.1   文件事件处理器的构成"></a>12.1.1   文件事件处理器的构成</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803173641136.png" alt="image-20220803173641136"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803173656883.png" alt="image-20220803173656883"></p><h4 id="12-1-2-I-x2F-O-多路复用程序的实现"><a href="#12-1-2-I-x2F-O-多路复用程序的实现" class="headerlink" title="12.1.2    I&#x2F;O  多路复用程序的实现"></a>12.1.2    I&#x2F;O  多路复用程序的实现</h4><ol><li><h4 id="Redis-的I-x2F-O-多路复用程序的所有功能-都是通过包装常见的-select-，epoll，evport，和kqueue-这些I-x2F-O-多路复用函数库来实现的。"><a href="#Redis-的I-x2F-O-多路复用程序的所有功能-都是通过包装常见的-select-，epoll，evport，和kqueue-这些I-x2F-O-多路复用函数库来实现的。" class="headerlink" title="Redis 的I&#x2F;O 多路复用程序的所有功能 都是通过包装常见的 select ，epoll，evport，和kqueue 这些I&#x2F;O 多路复用函数库来实现的。"></a>Redis 的I&#x2F;O 多路复用程序的所有功能 都是通过包装常见的 select ，epoll，evport，和kqueue 这些I&#x2F;O 多路复用函数库来实现的。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803174044136.png" alt="image-20220803174044136"></p><h4 id="12-1-13-事件的类型"><a href="#12-1-13-事件的类型" class="headerlink" title="12.1.13  事件的类型"></a>12.1.13  事件的类型</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803174501128.png" alt="image-20220803174501128"></p><h4 id="12-1-4-API"><a href="#12-1-4-API" class="headerlink" title="12.1.4   API"></a>12.1.4   API</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803174803360.png" alt="image-20220803174803360"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803174811470.png" alt="image-20220803174811470"></p><h4 id="12-1-5-文件事件的处理器"><a href="#12-1-5-文件事件的处理器" class="headerlink" title="12.1.5      文件事件的处理器"></a>12.1.5      文件事件的处理器</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191417715.png" alt="image-20220803191417715"></p><ol><li><h4 id="连接应答处理器"><a href="#连接应答处理器" class="headerlink" title="连接应答处理器"></a>连接应答处理器</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191531120.png" alt="image-20220803191531120"></p><ul><li><h4 id="命令请求处理器"><a href="#命令请求处理器" class="headerlink" title="命令请求处理器"></a>命令请求处理器</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191607630.png" alt="image-20220803191607630"></p><ul><li><h4 id="命令回复处理器"><a href="#命令回复处理器" class="headerlink" title="命令回复处理器"></a>命令回复处理器</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191631132.png" alt="image-20220803191631132"></p><ul><li><h4 id="一次完整的客户端与服务器连接事件示例"><a href="#一次完整的客户端与服务器连接事件示例" class="headerlink" title="一次完整的客户端与服务器连接事件示例"></a>一次完整的客户端与服务器连接事件示例</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191708213.png" alt="image-20220803191708213"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803191717781.png" alt="image-20220803191717781"></p><h3 id="12-2-时间事件"><a href="#12-2-时间事件" class="headerlink" title="12.2   时间事件"></a>12.2   时间事件</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192155324.png" alt="image-20220803192155324"></p><h4 id="12-2-1-实现"><a href="#12-2-1-实现" class="headerlink" title="12.2.1  实现"></a>12.2.1  实现</h4><ol><li><h4 id="服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有-已到达的时间事件，并调用相应的事件处理器。"><a href="#服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有-已到达的时间事件，并调用相应的事件处理器。" class="headerlink" title="服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有 已到达的时间事件，并调用相应的事件处理器。"></a>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有 已到达的时间事件，并调用相应的事件处理器。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192349600.png" alt="image-20220803192349600"></p><ol><li><h4 id="我们说保存的时间事件的链表是无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序，正因为链表没有按when属性进行排序，所以当时间事件执行器运行时，它必须遍历链表中的所有时间事件，这样才能保证服务器中所有已到达的事件事件都会被处理。"><a href="#我们说保存的时间事件的链表是无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序，正因为链表没有按when属性进行排序，所以当时间事件执行器运行时，它必须遍历链表中的所有时间事件，这样才能保证服务器中所有已到达的事件事件都会被处理。" class="headerlink" title="我们说保存的时间事件的链表是无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序，正因为链表没有按when属性进行排序，所以当时间事件执行器运行时，它必须遍历链表中的所有时间事件，这样才能保证服务器中所有已到达的事件事件都会被处理。"></a>我们说保存的时间事件的链表是无序链表，指的不是链表不按ID排序，而是说，该链表不按when属性的大小排序，正因为链表没有按when属性进行排序，所以当时间事件执行器运行时，它必须遍历链表中的所有时间事件，这样才能保证服务器中所有已到达的事件事件都会被处理。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192759866.png" alt="image-20220803192759866"></p><h4 id="12-2-2-API"><a href="#12-2-2-API" class="headerlink" title="12.2.2   API"></a>12.2.2   API</h4><h4 id="12-2-3-时间事件应用案例：-serverCron-函数"><a href="#12-2-3-时间事件应用案例：-serverCron-函数" class="headerlink" title="12.2.3  时间事件应用案例： serverCron 函数"></a>12.2.3  时间事件应用案例： serverCron 函数</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192909480.png" alt="image-20220803192909480"></p><h3 id="12-3-事件的调度与执行"><a href="#12-3-事件的调度与执行" class="headerlink" title="12.3    事件的调度与执行"></a>12.3    事件的调度与执行</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192945350.png" alt="image-20220803192945350"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803192954947.png" alt="image-20220803192954947"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803193014312.png" alt="image-20220803193014312"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220803193023328.png" alt="image-20220803193023328"></p><h3 id="12-4-重点回顾"><a href="#12-4-重点回顾" class="headerlink" title="12.4     重点回顾"></a>12.4     重点回顾</h3><ul><li><h4 id="Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件"><a href="#Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件" class="headerlink" title="Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件"></a>Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件</h4></li><li><h4 id="文件事件处理器是基于Reactor模式实现的网络通信程序"><a href="#文件事件处理器是基于Reactor模式实现的网络通信程序" class="headerlink" title="文件事件处理器是基于Reactor模式实现的网络通信程序"></a>文件事件处理器是基于Reactor模式实现的网络通信程序</h4></li><li><h4 id="文件事件是对套接字操作的抽象：每次套接字变为可应答，可读写，或者可读时，相应的文件事件就会产生"><a href="#文件事件是对套接字操作的抽象：每次套接字变为可应答，可读写，或者可读时，相应的文件事件就会产生" class="headerlink" title="文件事件是对套接字操作的抽象：每次套接字变为可应答，可读写，或者可读时，相应的文件事件就会产生"></a>文件事件是对套接字操作的抽象：每次套接字变为可应答，可读写，或者可读时，相应的文件事件就会产生</h4></li><li><h4 id="文件事件分为AE-READABLE-事件（读事件），和AE-WRITABLE（写事件）"><a href="#文件事件分为AE-READABLE-事件（读事件），和AE-WRITABLE（写事件）" class="headerlink" title="文件事件分为AE_READABLE  事件（读事件），和AE_WRITABLE（写事件）"></a>文件事件分为AE_READABLE  事件（读事件），和AE_WRITABLE（写事件）</h4></li><li><h4 id="时间事件分为定时事件和周期性事件：定时事件只在指定的事件到达一次，而-周期性事件则隔每一段时间到达一次。"><a href="#时间事件分为定时事件和周期性事件：定时事件只在指定的事件到达一次，而-周期性事件则隔每一段时间到达一次。" class="headerlink" title="时间事件分为定时事件和周期性事件：定时事件只在指定的事件到达一次，而 周期性事件则隔每一段时间到达一次。"></a>时间事件分为定时事件和周期性事件：定时事件只在指定的事件到达一次，而 周期性事件则隔每一段时间到达一次。</h4></li><li><h4 id="服务器在一般情况下只执行serverCron函数一个事件，并且这个事件是周期性事件。"><a href="#服务器在一般情况下只执行serverCron函数一个事件，并且这个事件是周期性事件。" class="headerlink" title="服务器在一般情况下只执行serverCron函数一个事件，并且这个事件是周期性事件。"></a>服务器在一般情况下只执行serverCron函数一个事件，并且这个事件是周期性事件。</h4></li><li><h4 id="文件事件和时间时间之间是合作关系，服务器会轮流处理这两种事件，并且处理这两种事件的过程中也不会进行抢占"><a href="#文件事件和时间时间之间是合作关系，服务器会轮流处理这两种事件，并且处理这两种事件的过程中也不会进行抢占" class="headerlink" title="文件事件和时间时间之间是合作关系，服务器会轮流处理这两种事件，并且处理这两种事件的过程中也不会进行抢占"></a>文件事件和时间时间之间是合作关系，服务器会轮流处理这两种事件，并且处理这两种事件的过程中也不会进行抢占</h4></li><li><h4 id="时间事件的实际处理事件通常会比设定的达到时间晚一些。"><a href="#时间事件的实际处理事件通常会比设定的达到时间晚一些。" class="headerlink" title="时间事件的实际处理事件通常会比设定的达到时间晚一些。"></a>时间事件的实际处理事件通常会比设定的达到时间晚一些。</h4></li></ul><h2 id="Chapter-13-客户端"><a href="#Chapter-13-客户端" class="headerlink" title="Chapter 13  客户端"></a>Chapter 13  客户端</h2><ul><li><h4 id="Redis-服务器是典型的一对多服务器程序：-x3D-x3D-一个服务器可以和多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的请求命令，并向客户端返回命令回复。-x3D-x3D"><a href="#Redis-服务器是典型的一对多服务器程序：-x3D-x3D-一个服务器可以和多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的请求命令，并向客户端返回命令回复。-x3D-x3D" class="headerlink" title="Redis 服务器是典型的一对多服务器程序：&#x3D;&#x3D;一个服务器可以和多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的请求命令，并向客户端返回命令回复。&#x3D;&#x3D;"></a>Redis 服务器是典型的一对多服务器程序：&#x3D;&#x3D;一个服务器可以和多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的请求命令，并向客户端返回命令回复。&#x3D;&#x3D;</h4></li></ul><ol><li><h4 id="通过使用由I-x2F-O多路复用技术实现的文件事件处理器，-x3D-x3D-Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。-x3D-x3D"><a href="#通过使用由I-x2F-O多路复用技术实现的文件事件处理器，-x3D-x3D-Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。-x3D-x3D" class="headerlink" title="通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，&#x3D;&#x3D;Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。&#x3D;&#x3D;"></a>通过使用由I&#x2F;O多路复用技术实现的文件事件处理器，&#x3D;&#x3D;Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。&#x3D;&#x3D;</h4></li></ol><ul><li><h4 id="对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis-h-x2F-redisClient结构——客户端状态，这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构"><a href="#对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis-h-x2F-redisClient结构——客户端状态，这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构" class="headerlink" title="对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h&#x2F;redisClient结构——客户端状态，这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构"></a>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的redis.h&#x2F;redisClient结构——客户端状态，这个结构保存了客户端当前的状态信息，以及执行相关功能时需要用到的数据结构</h4><ul><li><h4 id="。-2"><a href="#。-2" class="headerlink" title="。"></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804105213625.png" alt="image-20220804105213625">。</h4></li></ul></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804105436306.png" alt="image-20220804105436306"></p><h3 id="13-1-客户端属性"><a href="#13-1-客户端属性" class="headerlink" title="13.1   客户端属性"></a>13.1   客户端属性</h3><ul><li><h4 id="客户端状态包含的属性可以分为以下两类："><a href="#客户端状态包含的属性可以分为以下两类：" class="headerlink" title="客户端状态包含的属性可以分为以下两类："></a>客户端状态包含的属性可以分为以下两类：</h4></li></ul><ol><li><h4 id="一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都需要用到这些属性"><a href="#一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都需要用到这些属性" class="headerlink" title="一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都需要用到这些属性"></a>一类是比较通用的属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都需要用到这些属性</h4></li><li><h4 id="另外一类是和特定功能线相关的属性，比如操作数据库需要用到的db属性和dictid属性，执行事务时需要用到的matate属性，以及执行watch命令时需要用到的watched-keys属性等。"><a href="#另外一类是和特定功能线相关的属性，比如操作数据库需要用到的db属性和dictid属性，执行事务时需要用到的matate属性，以及执行watch命令时需要用到的watched-keys属性等。" class="headerlink" title="另外一类是和特定功能线相关的属性，比如操作数据库需要用到的db属性和dictid属性，执行事务时需要用到的matate属性，以及执行watch命令时需要用到的watched_keys属性等。"></a>另外一类是和特定功能线相关的属性，比如操作数据库需要用到的db属性和dictid属性，执行事务时需要用到的matate属性，以及执行watch命令时需要用到的watched_keys属性等。</h4></li></ol><h4 id="13-1-1-套接字描述符"><a href="#13-1-1-套接字描述符" class="headerlink" title="13.1.1   套接字描述符"></a>13.1.1   套接字描述符</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804111840461.png" alt="image-20220804111840461"></p><h4 id="13-1-2-名字"><a href="#13-1-2-名字" class="headerlink" title="13.1.2 名字"></a>13.1.2 名字</h4><ol><li><h4 id="在默认情况下，一个连接到服务器的客户端是没有名字的。"><a href="#在默认情况下，一个连接到服务器的客户端是没有名字的。" class="headerlink" title="在默认情况下，一个连接到服务器的客户端是没有名字的。"></a>在默认情况下，一个连接到服务器的客户端是没有名字的。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804111955102.png" alt="image-20220804111955102"></p><ol><li><h4 id="使用client-setname-命令可以为客户端设置一个名字，让客户端身份变得更清晰，"><a href="#使用client-setname-命令可以为客户端设置一个名字，让客户端身份变得更清晰，" class="headerlink" title="使用client  setname 命令可以为客户端设置一个名字，让客户端身份变得更清晰，"></a>使用client  setname 命令可以为客户端设置一个名字，让客户端身份变得更清晰，</h4></li><li><h4 id="如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针，反之则指向一个字符串对象，该对象保存着客户端的名字。"><a href="#如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针，反之则指向一个字符串对象，该对象保存着客户端的名字。" class="headerlink" title="如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针，反之则指向一个字符串对象，该对象保存着客户端的名字。"></a>如果客户端没有为自己设置名字，那么相应客户端状态的name属性指向NULL指针，反之则指向一个字符串对象，该对象保存着客户端的名字。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804112104721.png" alt="image-20220804112104721"></p><h4 id="13-1-3-标志"><a href="#13-1-3-标志" class="headerlink" title="13.1.3   标志"></a>13.1.3   标志</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804112301616.png" alt="image-20220804112301616"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804112309789.png" alt="image-20220804112309789"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804112323416.png" alt="image-20220804112323416"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804112346571.png" alt="image-20220804112346571"></p><h4 id="13-1-4-输入缓冲区"><a href="#13-1-4-输入缓冲区" class="headerlink" title="13.1.4   输入缓冲区"></a>13.1.4   输入缓冲区</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804211856740.png" alt="image-20220804211856740"></p><ol><li><h4 id="输入缓冲区的大小会根据输入内容动态的缩小或扩大，但它的最大大小不能超过1GB-否则服务器将关闭这个客户端"><a href="#输入缓冲区的大小会根据输入内容动态的缩小或扩大，但它的最大大小不能超过1GB-否则服务器将关闭这个客户端" class="headerlink" title="输入缓冲区的大小会根据输入内容动态的缩小或扩大，但它的最大大小不能超过1GB,否则服务器将关闭这个客户端"></a>输入缓冲区的大小会根据输入内容动态的缩小或扩大，但它的最大大小不能超过1GB,否则服务器将关闭这个客户端</h4></li><li><h4 id="。-3"><a href="#。-3" class="headerlink" title="。"></a>。</h4></li></ol><h4 id="13-1-5-命令与命令参数"><a href="#13-1-5-命令与命令参数" class="headerlink" title="13.1.5   命令与命令参数"></a>13.1.5   命令与命令参数</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804212541854.png" alt="image-20220804212541854"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804212553533.png" alt="image-20220804212553533"></p><h4 id="13-1-6-命令的实现函数"><a href="#13-1-6-命令的实现函数" class="headerlink" title="13.1.6      命令的实现函数"></a>13.1.6      命令的实现函数</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804213150514.png" alt="image-20220804213150514"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804213320147.png" alt="image-20220804213320147"></p><h4 id="13-1-7-输出缓冲区"><a href="#13-1-7-输出缓冲区" class="headerlink" title="13.1.7 输出缓冲区"></a>13.1.7 输出缓冲区</h4><ol><li><h4 id="执行命令所得到的命令回复会被保存在客户端状态的输出缓存区里，每个客户端都有两个输出缓冲区，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的"><a href="#执行命令所得到的命令回复会被保存在客户端状态的输出缓存区里，每个客户端都有两个输出缓冲区，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的" class="headerlink" title="执行命令所得到的命令回复会被保存在客户端状态的输出缓存区里，每个客户端都有两个输出缓冲区，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的"></a>执行命令所得到的命令回复会被保存在客户端状态的输出缓存区里，每个客户端都有两个输出缓冲区，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的</h4><ul><li><h4 id="x3D-x3D-固定大小的缓冲区用于保存那些长度比较小的回复-x3D-x3D-，比如OK，简短的字符串值，整数值，错误的回复等"><a href="#x3D-x3D-固定大小的缓冲区用于保存那些长度比较小的回复-x3D-x3D-，比如OK，简短的字符串值，整数值，错误的回复等" class="headerlink" title="&#x3D;&#x3D;固定大小的缓冲区用于保存那些长度比较小的回复&#x3D;&#x3D;，比如OK，简短的字符串值，整数值，错误的回复等"></a>&#x3D;&#x3D;固定大小的缓冲区用于保存那些长度比较小的回复&#x3D;&#x3D;，比如OK，简短的字符串值，整数值，错误的回复等</h4></li><li><h4 id="可变大小的缓冲区用于保存那些长度较长的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合。"><a href="#可变大小的缓冲区用于保存那些长度较长的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合。" class="headerlink" title="可变大小的缓冲区用于保存那些长度较长的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合。"></a>可变大小的缓冲区用于保存那些长度较长的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合。</h4></li></ul></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804214429579.png" alt="image-20220804214429579"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804214509948.png" alt="image-20220804214509948"></p><h4 id="13-1-8-身份验证"><a href="#13-1-8-身份验证" class="headerlink" title="13.1.8   身份验证"></a>13.1.8   身份验证</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span>&#123;</span><br>    <span class="hljs-type">int</span> authenticated ;<br>&#125;redisClient;<br></code></pre></td></tr></table></figure><ol><li><h4 id="如果authenticated-的值为0则验证未通过，如果为1则验证通过"><a href="#如果authenticated-的值为0则验证未通过，如果为1则验证通过" class="headerlink" title="如果authenticated 的值为0则验证未通过，如果为1则验证通过"></a>如果authenticated 的值为0则验证未通过，如果为1则验证通过</h4></li><li><h4 id="。-4"><a href="#。-4" class="headerlink" title="。"></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804214913586.png" alt="image-20220804214913586">。</h4></li><li><h4 id="通过auth-命令进行身份验证"><a href="#通过auth-命令进行身份验证" class="headerlink" title="通过auth 命令进行身份验证"></a>通过auth 命令进行身份验证</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804214938146.png" alt="image-20220804214938146"></p><ul><li><h4 id="仅在服务器启用了身份验证功能时使用，-x3D-x3D-如果服务器没有启用身份验证功能，那么即使authenticated为0，服务器也不会拒绝执行客户端发生的命令请求。-x3D-x3D"><a href="#仅在服务器启用了身份验证功能时使用，-x3D-x3D-如果服务器没有启用身份验证功能，那么即使authenticated为0，服务器也不会拒绝执行客户端发生的命令请求。-x3D-x3D" class="headerlink" title="仅在服务器启用了身份验证功能时使用，&#x3D;&#x3D;如果服务器没有启用身份验证功能，那么即使authenticated为0，服务器也不会拒绝执行客户端发生的命令请求。&#x3D;&#x3D;"></a>仅在服务器启用了身份验证功能时使用，&#x3D;&#x3D;如果服务器没有启用身份验证功能，那么即使authenticated为0，服务器也不会拒绝执行客户端发生的命令请求。&#x3D;&#x3D;</h4></li></ul><h4 id="13-1-9-时间"><a href="#13-1-9-时间" class="headerlink" title="13.1.9      时间"></a>13.1.9      时间</h4><ul><li><h4 id="客户端与时间相关的属性。"><a href="#客户端与时间相关的属性。" class="headerlink" title="客户端与时间相关的属性。"></a>客户端与时间相关的属性。</h4></li></ul><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804215203911.png" alt="image-20220804215203911"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804215457926.png" alt="image-20220804215457926"></p><ol><li><h4 id="ctime"><a href="#ctime" class="headerlink" title="ctime"></a>ctime</h4></li><li><h4 id="lastinteraction。"><a href="#lastinteraction。" class="headerlink" title="lastinteraction。"></a>lastinteraction。</h4></li></ol><h3 id="13-2-客户端的创建与关闭"><a href="#13-2-客户端的创建与关闭" class="headerlink" title="13.2   客户端的创建与关闭"></a>13.2   客户端的创建与关闭</h3><ul><li><h4 id="服务器使用不同的方式来创建和关闭不同类型的客户端。"><a href="#服务器使用不同的方式来创建和关闭不同类型的客户端。" class="headerlink" title="服务器使用不同的方式来创建和关闭不同类型的客户端。"></a>服务器使用不同的方式来创建和关闭不同类型的客户端。</h4></li></ul><h4 id="13-2-1-创建普通客户端"><a href="#13-2-1-创建普通客户端" class="headerlink" title="13.2.1   创建普通客户端"></a>13.2.1   创建普通客户端</h4><ol><li><h4 id="通过connect函数连接服务器"><a href="#通过connect函数连接服务器" class="headerlink" title="通过connect函数连接服务器"></a>通过connect函数连接服务器</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804220020419.png" alt="image-20220804220020419"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804220028578.png" alt="image-20220804220028578"></p><h4 id="13-2-2-关闭普通客户端"><a href="#13-2-2-关闭普通客户端" class="headerlink" title="13.2.2  关闭普通客户端"></a>13.2.2  关闭普通客户端</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804222219110.png" alt="image-20220804222219110"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220804222733125.png" alt="image-20220804222733125"></p><p>13.2.3  Lua脚本的伪客户端</p><ol><li><h4 id="服务器会在初始化时创建负责执行lua脚本中包含的Redis命令的为客户端，并将这个伪客户端关联在服务器状态结构的lua-client属性中。"><a href="#服务器会在初始化时创建负责执行lua脚本中包含的Redis命令的为客户端，并将这个伪客户端关联在服务器状态结构的lua-client属性中。" class="headerlink" title="服务器会在初始化时创建负责执行lua脚本中包含的Redis命令的为客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。"></a>服务器会在初始化时创建负责执行lua脚本中包含的Redis命令的为客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。</h4></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisServer</span>&#123;</span><br>    redisClient  * lua_client ;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><h4 id="lua-client-伪客户端在服务器运行的整个生命周期中会一直存在，只有服务器关闭时，这个客户端才会被关闭。"><a href="#lua-client-伪客户端在服务器运行的整个生命周期中会一直存在，只有服务器关闭时，这个客户端才会被关闭。" class="headerlink" title="lua_client 伪客户端在服务器运行的整个生命周期中会一直存在，只有服务器关闭时，这个客户端才会被关闭。"></a>lua_client 伪客户端在服务器运行的整个生命周期中会一直存在，只有服务器关闭时，这个客户端才会被关闭。</h4></li></ol><h4 id="13-2-4-AOF文件的为客户端"><a href="#13-2-4-AOF文件的为客户端" class="headerlink" title="13.2.4  AOF文件的为客户端"></a>13.2.4  AOF文件的为客户端</h4><ul><li><h4 id="服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的为客户端，并在载入完成之后，关闭这个为客户端。"><a href="#服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的为客户端，并在载入完成之后，关闭这个为客户端。" class="headerlink" title="服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的为客户端，并在载入完成之后，关闭这个为客户端。"></a>服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的为客户端，并在载入完成之后，关闭这个为客户端。</h4></li></ul><h3 id="13-3-重点回顾"><a href="#13-3-重点回顾" class="headerlink" title="13.3   重点回顾"></a>13.3   重点回顾</h3><ul><li><h4 id="服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾"><a href="#服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾" class="headerlink" title="服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾"></a>服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾</h4></li><li><h4 id="客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态"><a href="#客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态" class="headerlink" title="客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态"></a>客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态</h4></li><li><h4 id="输入缓冲回区记录了客户端发送的请求命令，这个缓冲区的大小不能超过1GB"><a href="#输入缓冲回区记录了客户端发送的请求命令，这个缓冲区的大小不能超过1GB" class="headerlink" title="输入缓冲回区记录了客户端发送的请求命令，这个缓冲区的大小不能超过1GB"></a>输入缓冲回区记录了客户端发送的请求命令，这个缓冲区的大小不能超过1GB</h4></li><li><h4 id="命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数"><a href="#命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数" class="headerlink" title="命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数"></a>命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数</h4></li><li><h4 id="客户端由固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大量大小不能超过服务器设置的硬性限制值"><a href="#客户端由固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大量大小不能超过服务器设置的硬性限制值" class="headerlink" title="客户端由固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大量大小不能超过服务器设置的硬性限制值"></a>客户端由固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大量大小不能超过服务器设置的硬性限制值</h4></li><li><h4 id="输出缓冲区限制有两种，如果输出缓冲区的大小超过了服务区设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务区设置的软性限制，那么客户端也会被关闭"><a href="#输出缓冲区限制有两种，如果输出缓冲区的大小超过了服务区设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务区设置的软性限制，那么客户端也会被关闭" class="headerlink" title="输出缓冲区限制有两种，如果输出缓冲区的大小超过了服务区设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务区设置的软性限制，那么客户端也会被关闭"></a>输出缓冲区限制有两种，如果输出缓冲区的大小超过了服务区设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务区设置的软性限制，那么客户端也会被关闭</h4></li><li><h4 id="当一个客户端通过网络连接连上了服务器，服务器就会为这个客户端创建相应的客户端状态，网络连接关闭，发送了不合协议格式的命令请求，称为CLient-kill-命令的目标，空间时间超时，输出缓冲区的大小超出限制，以上原因都会造成客户端被关闭"><a href="#当一个客户端通过网络连接连上了服务器，服务器就会为这个客户端创建相应的客户端状态，网络连接关闭，发送了不合协议格式的命令请求，称为CLient-kill-命令的目标，空间时间超时，输出缓冲区的大小超出限制，以上原因都会造成客户端被关闭" class="headerlink" title="当一个客户端通过网络连接连上了服务器，服务器就会为这个客户端创建相应的客户端状态，网络连接关闭，发送了不合协议格式的命令请求，称为CLient kill 命令的目标，空间时间超时，输出缓冲区的大小超出限制，以上原因都会造成客户端被关闭"></a>当一个客户端通过网络连接连上了服务器，服务器就会为这个客户端创建相应的客户端状态，网络连接关闭，发送了不合协议格式的命令请求，称为CLient kill 命令的目标，空间时间超时，输出缓冲区的大小超出限制，以上原因都会造成客户端被关闭</h4></li><li><h4 id="处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，知道服务器关闭"><a href="#处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，知道服务器关闭" class="headerlink" title="处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，知道服务器关闭"></a>处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，知道服务器关闭</h4></li><li><h4 id="载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。"><a href="#载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。" class="headerlink" title="载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。"></a>载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。</h4></li></ul><h2 id="Chapter-14-服务器"><a href="#Chapter-14-服务器" class="headerlink" title="Chapter 14   服务器"></a>Chapter 14   服务器</h2><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805122613197.png" alt="image-20220805122613197"></p><h3 id="14-1-命令请求的执行过程"><a href="#14-1-命令请求的执行过程" class="headerlink" title="14.1   命令请求的执行过程"></a>14.1   命令请求的执行过程</h3><ol><li><h4 id="以set操作为例"><a href="#以set操作为例" class="headerlink" title="以set操作为例"></a>以set操作为例</h4></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs redis">set key value <br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805122806620.png" alt="image-20220805122806620"></p><h4 id="14-1-1-发送命令请求"><a href="#14-1-1-发送命令请求" class="headerlink" title="14.1.1  发送命令请求"></a>14.1.1  发送命令请求</h4><ol><li><h4 id="Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令时，-x3D-x3D-客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器-x3D-x3D-。"><a href="#Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令时，-x3D-x3D-客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器-x3D-x3D-。" class="headerlink" title="Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令时，&#x3D;&#x3D;客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器&#x3D;&#x3D;。"></a>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令时，&#x3D;&#x3D;客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器&#x3D;&#x3D;。</h4></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805123837853.png" alt="image-20220805123837853"></p><h4 id="14-1-2-读取命令请求"><a href="#14-1-2-读取命令请求" class="headerlink" title="14.1.2  读取命令请求"></a>14.1.2  读取命令请求</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124050254.png" alt="image-20220805124050254"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124225177.png" alt="image-20220805124225177"></p><h4 id="14-1-3-命令执行器（1）：-查找命令实现"><a href="#14-1-3-命令执行器（1）：-查找命令实现" class="headerlink" title="14.1.3     命令执行器（1）： 查找命令实现"></a>14.1.3     命令执行器（1）： 查找命令实现</h4><ol><li><h4 id="命令执行器要做的第一件事激素根据客户端状态的argv-0-参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里。"><a href="#命令执行器要做的第一件事激素根据客户端状态的argv-0-参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里。" class="headerlink" title="命令执行器要做的第一件事激素根据客户端状态的argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里。"></a>命令执行器要做的第一件事激素根据客户端状态的argv[0]参数，在命令表中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里。</h4></li><li><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124730106.png" alt="image-20220805124730106"></p></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124739252.png" alt="image-20220805124739252"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124805222.png" alt="image-20220805124805222"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124819284.png" alt="image-20220805124819284"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124829221.png" alt="image-20220805124829221"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124848094.png" alt="image-20220805124848094"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124901514.png" alt="image-20220805124901514"></p><h4 id="14-1-4-命令执行器（2）-：-执行预备操作"><a href="#14-1-4-命令执行器（2）-：-执行预备操作" class="headerlink" title="14.1.4   命令执行器（2） ： 执行预备操作"></a>14.1.4   命令执行器（2） ： 执行预备操作</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124939500.png" alt="image-20220805124939500"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805124951206.png" alt="image-20220805124951206"></p><ol><li><h4 id="以上只列出了服务器在单机模式下执行命令时的价差操作，当服务器在复制或者集群模式下执行命令时，预备操作还会更多一点"><a href="#以上只列出了服务器在单机模式下执行命令时的价差操作，当服务器在复制或者集群模式下执行命令时，预备操作还会更多一点" class="headerlink" title="以上只列出了服务器在单机模式下执行命令时的价差操作，当服务器在复制或者集群模式下执行命令时，预备操作还会更多一点.."></a>以上只列出了服务器在单机模式下执行命令时的价差操作，当服务器在复制或者集群模式下执行命令时，预备操作还会更多一点..</h4></li></ol><h4 id="14-1-5-命令执行器-3-调用命令的实现函数"><a href="#14-1-5-命令执行器-3-调用命令的实现函数" class="headerlink" title="14.1.5    命令执行器(3): 调用命令的实现函数"></a>14.1.5    命令执行器(3): 调用命令的实现函数</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805130159750.png" alt="image-20220805130159750"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805130301102.png" alt="image-20220805130301102"></p><h4 id="14-1-6-执行后续工作"><a href="#14-1-6-执行后续工作" class="headerlink" title="14.1.6    执行后续工作"></a>14.1.6    执行后续工作</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805130627044.png" alt="image-20220805130627044"></p><h4 id="14-1-7-将命令回复发送给客户端"><a href="#14-1-7-将命令回复发送给客户端" class="headerlink" title="14.1.7  将命令回复发送给客户端"></a>14.1.7  将命令回复发送给客户端</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805130658111.png" alt="image-20220805130658111"></p><h4 id="14-1-8-客户端接收并打印命令回复"><a href="#14-1-8-客户端接收并打印命令回复" class="headerlink" title="14.1.8  客户端接收并打印命令回复"></a>14.1.8  客户端接收并打印命令回复</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805130940734.png" alt="image-20220805130940734"></p><h3 id="14-2-serverCron-函数"><a href="#14-2-serverCron-函数" class="headerlink" title="14.2  serverCron  函数"></a>14.2  serverCron  函数</h3><ol><li><h4 id="Redis服务器中的serverCron函数默认每隔100ms执行一次-这个函数负责管理服务器的资源-并保持服务器自身的良好运转"><a href="#Redis服务器中的serverCron函数默认每隔100ms执行一次-这个函数负责管理服务器的资源-并保持服务器自身的良好运转" class="headerlink" title="Redis服务器中的serverCron函数默认每隔100ms执行一次,这个函数负责管理服务器的资源,并保持服务器自身的良好运转."></a>Redis服务器中的serverCron函数默认每隔100ms执行一次,这个函数负责管理服务器的资源,并保持服务器自身的良好运转.</h4></li></ol><h4 id="14-2-1-更新服务器时间缓存"><a href="#14-2-1-更新服务器时间缓存" class="headerlink" title="14.2.1     更新服务器时间缓存"></a>14.2.1     更新服务器时间缓存</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805132335117.png" alt="image-20220805132335117"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805132348564.png" alt="image-20220805132348564"></p><h4 id="14-2-2-更新LRU-时钟"><a href="#14-2-2-更新LRU-时钟" class="headerlink" title="14.2.2  更新LRU 时钟"></a>14.2.2  更新LRU 时钟</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805132623723.png" alt="image-20220805132623723"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805132659536.png" alt="image-20220805132659536"></p><h4 id="14-2-3-更新服务器每秒执行次数"><a href="#14-2-3-更新服务器每秒执行次数" class="headerlink" title="14.2.3  更新服务器每秒执行次数"></a>14.2.3  更新服务器每秒执行次数</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805132835186.png" alt="image-20220805132835186"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805133012355.png" alt="image-20220805133012355"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805133025283.png" alt="image-20220805133025283"></p><h4 id="14-2-4-更新服务器内存峰值记录"><a href="#14-2-4-更新服务器内存峰值记录" class="headerlink" title="14.2.4   更新服务器内存峰值记录"></a>14.2.4   更新服务器内存峰值记录</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805133141176.png" alt="image-20220805133141176"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805133148159.png" alt="image-20220805133148159"></p><h4 id="14-2-5-处理sigterm-信号"><a href="#14-2-5-处理sigterm-信号" class="headerlink" title="14.2.5  处理sigterm 信号"></a>14.2.5  处理sigterm 信号</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805135042951.png" alt="image-20220805135042951"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805135055790.png" alt="image-20220805135055790"></p><h4 id="14-2-6-管理客户端资源"><a href="#14-2-6-管理客户端资源" class="headerlink" title="14.2.6  管理客户端资源"></a>14.2.6  管理客户端资源</h4><ol><li><h4 id="serverCron函数每次执行都会调用clientsCron函数-clientsCron函数会对一定数量的客户端进行以下两个检查"><a href="#serverCron函数每次执行都会调用clientsCron函数-clientsCron函数会对一定数量的客户端进行以下两个检查" class="headerlink" title="serverCron函数每次执行都会调用clientsCron函数,clientsCron函数会对一定数量的客户端进行以下两个检查:"></a>serverCron函数每次执行都会调用clientsCron函数,clientsCron函数会对一定数量的客户端进行以下两个检查:</h4><ol><li><h4 id="如果客户端与服务器之间的连接已经超时-很长一段时间里客户端和服务器都没有互动-那么程序释放这个客户端"><a href="#如果客户端与服务器之间的连接已经超时-很长一段时间里客户端和服务器都没有互动-那么程序释放这个客户端" class="headerlink" title="如果客户端与服务器之间的连接已经超时,很长一段时间里客户端和服务器都没有互动,那么程序释放这个客户端"></a>如果客户端与服务器之间的连接已经超时,很长一段时间里客户端和服务器都没有互动,那么程序释放这个客户端</h4></li><li><h4 id="如果客户端在上一次执行命令请求之后-输入缓冲区的大小超过了一定的长度-那么程序会释放客户端当前的输入缓冲区-并重新创建一个默认大小的输入缓冲区-从而防止客户端的输入缓冲区耗费了过多的内存"><a href="#如果客户端在上一次执行命令请求之后-输入缓冲区的大小超过了一定的长度-那么程序会释放客户端当前的输入缓冲区-并重新创建一个默认大小的输入缓冲区-从而防止客户端的输入缓冲区耗费了过多的内存" class="headerlink" title="如果客户端在上一次执行命令请求之后,输入缓冲区的大小超过了一定的长度,那么程序会释放客户端当前的输入缓冲区,并重新创建一个默认大小的输入缓冲区,从而防止客户端的输入缓冲区耗费了过多的内存."></a>如果客户端在上一次执行命令请求之后,输入缓冲区的大小超过了一定的长度,那么程序会释放客户端当前的输入缓冲区,并重新创建一个默认大小的输入缓冲区,从而防止客户端的输入缓冲区耗费了过多的内存.</h4></li></ol></li></ol><h4 id="14-2-7-管理数据库资源"><a href="#14-2-7-管理数据库资源" class="headerlink" title="14.2.7   管理数据库资源"></a>14.2.7   管理数据库资源</h4><ol><li><h4 id="serverCron函数每次执行都会调用databasesCron函数-这个函数会对服务器中的一部分数据库进行检查-删除其中的过期键-并在有需要的时候-对字典进行伸缩"><a href="#serverCron函数每次执行都会调用databasesCron函数-这个函数会对服务器中的一部分数据库进行检查-删除其中的过期键-并在有需要的时候-对字典进行伸缩" class="headerlink" title="serverCron函数每次执行都会调用databasesCron函数,这个函数会对服务器中的一部分数据库进行检查,删除其中的过期键,并在有需要的时候,对字典进行伸缩."></a>serverCron函数每次执行都会调用databasesCron函数,这个函数会对服务器中的一部分数据库进行检查,删除其中的过期键,并在有需要的时候,对字典进行伸缩.</h4></li></ol><h4 id="14-2-8-执行被延迟的BGREWRITEAOF"><a href="#14-2-8-执行被延迟的BGREWRITEAOF" class="headerlink" title="14.2.8   执行被延迟的BGREWRITEAOF"></a>14.2.8   执行被延迟的BGREWRITEAOF</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805143838370.png" alt="image-20220805143838370"></h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805143846180.png" alt="image-20220805143846180"></p><h4 id="14-2-9-检查持久化操作的运行状态"><a href="#14-2-9-检查持久化操作的运行状态" class="headerlink" title="14.2.9      检查持久化操作的运行状态"></a>14.2.9      检查持久化操作的运行状态</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805205724248.png" alt="image-20220805205724248"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805205738675.png" alt="image-20220805205738675"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805211230573.png" alt="image-20220805211230573"></p><h4 id="14-2-10-将AOF缓冲区的内容写入AOF文件"><a href="#14-2-10-将AOF缓冲区的内容写入AOF文件" class="headerlink" title="14.2.10    将AOF缓冲区的内容写入AOF文件"></a>14.2.10    将AOF缓冲区的内容写入AOF文件</h4><ol><li><h4 id="如果服务器开启了AOF持久化功能-并且AOF缓冲区里面还有待写入数据-那么serverCron函数会调用相应的程序-将AOF缓冲区的内容写入到AOF文件里面"><a href="#如果服务器开启了AOF持久化功能-并且AOF缓冲区里面还有待写入数据-那么serverCron函数会调用相应的程序-将AOF缓冲区的内容写入到AOF文件里面" class="headerlink" title="如果服务器开启了AOF持久化功能,并且AOF缓冲区里面还有待写入数据,那么serverCron函数会调用相应的程序,将AOF缓冲区的内容写入到AOF文件里面,"></a>如果服务器开启了AOF持久化功能,并且AOF缓冲区里面还有待写入数据,那么serverCron函数会调用相应的程序,将AOF缓冲区的内容写入到AOF文件里面,</h4></li></ol><h4 id="14-2-11-关闭异步客户端"><a href="#14-2-11-关闭异步客户端" class="headerlink" title="14.2.11   关闭异步客户端."></a>14.2.11   关闭异步客户端.</h4><ol><li><h4 id="在这一步-服务器会关闭那些输出缓冲区大小超出限制的客户端"><a href="#在这一步-服务器会关闭那些输出缓冲区大小超出限制的客户端" class="headerlink" title="在这一步,服务器会关闭那些输出缓冲区大小超出限制的客户端,"></a>在这一步,服务器会关闭那些输出缓冲区大小超出限制的客户端,</h4></li></ol><h4 id="14-2-12-增加cronloops-计数器的值"><a href="#14-2-12-增加cronloops-计数器的值" class="headerlink" title="14.2.12    增加cronloops 计数器的值."></a>14.2.12    增加cronloops 计数器的值.</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805221007083.png"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220805221016935.png" alt="image-20220805221016935"></p><h3 id="14-3-初始化服务器"><a href="#14-3-初始化服务器" class="headerlink" title="14.3     初始化服务器"></a>14.3     初始化服务器</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144006702.png" alt="image-20220806144006702"></p><h4 id="14-3-1-初始化服务器的状态结构"><a href="#14-3-1-初始化服务器的状态结构" class="headerlink" title="14.3.1  初始化服务器的状态结构"></a>14.3.1  初始化服务器的状态结构</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144031896.png" alt="image-20220806144031896"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144036894.png" alt="image-20220806144036894"></p><h4 id="14-3-2-载入配置选项"><a href="#14-3-2-载入配置选项" class="headerlink" title="14.3.2  载入配置选项"></a>14.3.2  载入配置选项</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144055348.png" alt="image-20220806144055348"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144150592.png" alt="image-20220806144150592"></p><h4 id="14-3-3-初始化服务器数据结构"><a href="#14-3-3-初始化服务器数据结构" class="headerlink" title="14.3.3  初始化服务器数据结构"></a>14.3.3  初始化服务器数据结构</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144247068.png"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144425958.png" alt="image-20220806144425958"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144433835.png" alt="image-20220806144433835"></p><h4 id="14-3-4-还原数据库状态"><a href="#14-3-4-还原数据库状态" class="headerlink" title="14.3.4  还原数据库状态"></a>14.3.4  还原数据库状态</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144503473.png" alt="image-20220806144503473"></p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144512270.png" alt="image-20220806144512270"></p><h4 id="14-3-5-执行事件循环"><a href="#14-3-5-执行事件循环" class="headerlink" title="14.3.5     执行事件循环"></a>14.3.5     执行事件循环</h4><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220806144701518.png" alt="image-20220806144701518"></p><h3 id="14-4-重点回顾"><a href="#14-4-重点回顾" class="headerlink" title="14.4     重点回顾"></a>14.4     重点回顾</h3><ol><li><h4 id="一个命令请求从发送到完成主要包括以下步骤：1-客户端将执行的命令请求发送给服务器。2。服务器读取命令请求，并分析出命令参数，3、命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复。4-服务器将命令回复返回给客户端"><a href="#一个命令请求从发送到完成主要包括以下步骤：1-客户端将执行的命令请求发送给服务器。2。服务器读取命令请求，并分析出命令参数，3、命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复。4-服务器将命令回复返回给客户端" class="headerlink" title="一个命令请求从发送到完成主要包括以下步骤：1.客户端将执行的命令请求发送给服务器。2。服务器读取命令请求，并分析出命令参数，3、命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复。4.服务器将命令回复返回给客户端"></a>一个命令请求从发送到完成主要包括以下步骤：1.客户端将执行的命令请求发送给服务器。2。服务器读取命令请求，并分析出命令参数，3、命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复。4.服务器将命令回复返回给客户端</h4></li><li><h4 id="serverCron函数默认每隔100ms执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的sigtrem信号，管理客户端资源和数据库状态，执行并检查持久化操作等。"><a href="#serverCron函数默认每隔100ms执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的sigtrem信号，管理客户端资源和数据库状态，执行并检查持久化操作等。" class="headerlink" title="serverCron函数默认每隔100ms执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的sigtrem信号，管理客户端资源和数据库状态，执行并检查持久化操作等。"></a>serverCron函数默认每隔100ms执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的sigtrem信号，管理客户端资源和数据库状态，执行并检查持久化操作等。</h4></li><li><h4 id="服务器从启动到能够处理客户端的命令请求需要执行以下步骤，1-初始化服务器状态，2-载入服务器配置，3-初始化服务器数据结构，4-还原数据库状态。5-执行事件循环。。"><a href="#服务器从启动到能够处理客户端的命令请求需要执行以下步骤，1-初始化服务器状态，2-载入服务器配置，3-初始化服务器数据结构，4-还原数据库状态。5-执行事件循环。。" class="headerlink" title="服务器从启动到能够处理客户端的命令请求需要执行以下步骤，1.初始化服务器状态，2.载入服务器配置，3.初始化服务器数据结构，4.还原数据库状态。5.执行事件循环。。"></a>服务器从启动到能够处理客户端的命令请求需要执行以下步骤，1.初始化服务器状态，2.载入服务器配置，3.初始化服务器数据结构，4.还原数据库状态。5.执行事件循环。。</h4></li></ol><h2 id="第三部分-多数据库的实现"><a href="#第三部分-多数据库的实现" class="headerlink" title="第三部分   多数据库的实现"></a>第三部分   多数据库的实现</h2>]]></content>
      
      
      <categories>
          
          <category> Redis学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/10/15/MySQL/"/>
      <url>/2022/10/15/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL的体系架构"><a href="#1-MySQL的体系架构" class="headerlink" title="1.MySQL的体系架构"></a>1.MySQL的体系架构</h2><p>MySQL 由以下几部分组成</p><ol><li><h4 id="连接池组件"><a href="#连接池组件" class="headerlink" title="连接池组件"></a>连接池组件</h4></li><li><h4 id="管理服务工具"><a href="#管理服务工具" class="headerlink" title="管理服务工具"></a>管理服务工具</h4></li><li><h4 id="SQL接口组件"><a href="#SQL接口组件" class="headerlink" title="SQL接口组件"></a>SQL接口组件</h4></li><li><h4 id="查询分析器组件"><a href="#查询分析器组件" class="headerlink" title="查询分析器组件"></a>查询分析器组件</h4></li><li><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4></li><li><h4 id="缓存-cache-组件"><a href="#缓存-cache-组件" class="headerlink" title="缓存(cache)组件"></a>缓存(cache)组件</h4></li><li><h4 id="插件式存储引擎"><a href="#插件式存储引擎" class="headerlink" title="插件式存储引擎"></a>插件式存储引擎</h4></li><li><h4 id="物理文件。"><a href="#物理文件。" class="headerlink" title="物理文件。"></a>物理文件。</h4></li></ol><ul><li><h4 id="值得注意的是：存储引擎是基于表的，而不是整个数据库。"><a href="#值得注意的是：存储引擎是基于表的，而不是整个数据库。" class="headerlink" title="值得注意的是：存储引擎是基于表的，而不是整个数据库。"></a>值得注意的是：存储引擎是基于表的，而不是整个数据库。</h4></li></ul><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show engines<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Engine             | Support | Comment | Transactions| XA   | Savepoints |<br>+--------------------+---------+---------+--------------+------+------------+<br>| FEDERATED          | NO      |        | NULL         | NULL | NULL       |<br>| MEMORY             | YES     |        | NO           | NO   | NO        |<br>| InnoDB             | DEFAULT |         | YES          | YES | YES        |<br>|PERFORMANCE_SCHEMA | YES     |         | NO           | NO   | NO        |<br>| MyISAM             | YES     |  ...   | NO           | NO   | NO        |<br>| MRG_MYISAM         | YES     |        | NO           | NO   | NO        |<br>| BLACKHOLE          | YES     |        | NO           | NO   | NO        |<br>| CSV                | YES     |        | NO           | NO   | NO        |<br>| ARCHIVE            | YES     |        | NO           | NO   | NO        |<br></code></pre></td></tr></table></figure><h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><ul><li><h4 id="TCP-x2F-IP等网络和通信的知识。"><a href="#TCP-x2F-IP等网络和通信的知识。" class="headerlink" title="TCP&#x2F;IP等网络和通信的知识。"></a>TCP&#x2F;IP等网络和通信的知识。</h4></li></ul><h2 id="2-InnoDB-存储引擎"><a href="#2-InnoDB-存储引擎" class="headerlink" title="2. InnoDB 存储引擎"></a>2. InnoDB 存储引擎</h2><p>从MySQL 5.5 版本之后 就InnoDB就成为了默认引擎。</p><ul><li><h4 id="该存储引擎完整支持ACID事务。其特点是：-行锁设计，支持MVCC-支持外键，提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。"><a href="#该存储引擎完整支持ACID事务。其特点是：-行锁设计，支持MVCC-支持外键，提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。" class="headerlink" title="该存储引擎完整支持ACID事务。其特点是： 行锁设计，支持MVCC,支持外键，提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。"></a>该存储引擎完整支持ACID事务。其特点是： 行锁设计，支持MVCC,支持外键，提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和CPU。</h4></li></ul><h3 id="InnoDB-体系架构"><a href="#InnoDB-体系架构" class="headerlink" title="InnoDB 体系架构"></a>InnoDB 体系架构</h3><ul><li><h4 id="InnoDB存储引擎中有多个内存块。负责如下工作："><a href="#InnoDB存储引擎中有多个内存块。负责如下工作：" class="headerlink" title="InnoDB存储引擎中有多个内存块。负责如下工作："></a>InnoDB存储引擎中有多个内存块。负责如下工作：</h4><ul><li><h4 id="维护所有进程-x2F-线程-需要访问的多个内部数据结构"><a href="#维护所有进程-x2F-线程-需要访问的多个内部数据结构" class="headerlink" title="维护所有进程&#x2F;线程 需要访问的多个内部数据结构"></a>维护所有进程&#x2F;线程 需要访问的多个内部数据结构</h4></li><li><h4 id="缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存"><a href="#缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存" class="headerlink" title="缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存"></a>缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存</h4></li><li><h4 id="重做日志-redo-log-缓冲-redo-log-buffer"><a href="#重做日志-redo-log-缓冲-redo-log-buffer" class="headerlink" title="重做日志(redo log)缓冲(redo log_buffer)"></a>重做日志(redo log)缓冲(redo log_buffer)</h4></li><li><h4 id="……-。"><a href="#……-。" class="headerlink" title="…….. 。"></a>…….. 。</h4></li></ul></li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>​</p><h4 id="1-缓冲池"><a href="#1-缓冲池" class="headerlink" title="1.缓冲池"></a>1.缓冲池</h4><ul><li><h4 id="InnoDB是基于磁盘存储的，并将其中的记录方式按照页的方式进行管理，因此可将它看作是基于-磁盘的数据库系统。-DISK-BASE-DATABASE-。基于磁盘的数据库系统通常使用缓冲此来提高数据库的整体特性。"><a href="#InnoDB是基于磁盘存储的，并将其中的记录方式按照页的方式进行管理，因此可将它看作是基于-磁盘的数据库系统。-DISK-BASE-DATABASE-。基于磁盘的数据库系统通常使用缓冲此来提高数据库的整体特性。" class="headerlink" title="InnoDB是基于磁盘存储的，并将其中的记录方式按照页的方式进行管理，因此可将它看作是基于 磁盘的数据库系统。(DISK-BASE-DATABASE)。基于磁盘的数据库系统通常使用缓冲此来提高数据库的整体特性。"></a>InnoDB是基于磁盘存储的，并将其中的记录方式按照页的方式进行管理，因此可将它看作是基于 磁盘的数据库系统。(DISK-BASE-DATABASE)。基于磁盘的数据库系统通常使用缓冲此来提高数据库的整体特性。</h4></li></ul><h4 id="2-LRU-LIST-Free-LIst-和-Flush-List"><a href="#2-LRU-LIST-Free-LIst-和-Flush-List" class="headerlink" title="2.LRU LIST, Free LIst 和 Flush List"></a>2.LRU LIST, Free LIst 和 Flush List</h4><ul><li><h4 id="LRU-近期最少使用算法，数据库中的缓冲池使用它来管理。"><a href="#LRU-近期最少使用算法，数据库中的缓冲池使用它来管理。" class="headerlink" title="LRU,近期最少使用算法，数据库中的缓冲池使用它来管理。"></a>LRU,近期最少使用算法，数据库中的缓冲池使用它来管理。</h4></li></ul><h4 id="3-重做日志缓冲"><a href="#3-重做日志缓冲" class="headerlink" title="3. 重做日志缓冲"></a>3. 重做日志缓冲</h4><h3 id="InnoDB的关键特性"><a href="#InnoDB的关键特性" class="headerlink" title="InnoDB的关键特性"></a>InnoDB的关键特性</h3><ol><li><h4 id="插入缓冲-Insert-buffer"><a href="#插入缓冲-Insert-buffer" class="headerlink" title="插入缓冲(Insert buffer)"></a>插入缓冲(Insert buffer)</h4></li><li><h4 id="两次写-double-wirte"><a href="#两次写-double-wirte" class="headerlink" title="两次写(double wirte)"></a>两次写(double wirte)</h4></li><li><h4 id="自适应哈希索引-Adaptive-Hash-Index"><a href="#自适应哈希索引-Adaptive-Hash-Index" class="headerlink" title="自适应哈希索引(Adaptive Hash Index)"></a>自适应哈希索引(Adaptive Hash Index)</h4></li><li><h4 id="异步IO-Async-IO"><a href="#异步IO-Async-IO" class="headerlink" title="异步IO(Async IO)"></a>异步IO(Async IO)</h4></li><li><h4 id="刷新邻接页-Flush-Neighbor-Page-。"><a href="#刷新邻接页-Flush-Neighbor-Page-。" class="headerlink" title="刷新邻接页(Flush Neighbor Page)。"></a>刷新邻接页(Flush Neighbor Page)。</h4></li></ol><h4 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h4><h5 id="Insert-Buffer"><a href="#Insert-Buffer" class="headerlink" title="Insert Buffer"></a>Insert Buffer</h5><ul><li><h4 id="Insert-Buffer-的使用需要同时满足两个条件："><a href="#Insert-Buffer-的使用需要同时满足两个条件：" class="headerlink" title="Insert Buffer 的使用需要同时满足两个条件："></a>Insert Buffer 的使用需要同时满足两个条件：</h4><ul><li><h4 id="索引是辅助索引-Secondary-index"><a href="#索引是辅助索引-Secondary-index" class="headerlink" title="索引是辅助索引(Secondary index)"></a>索引是辅助索引(Secondary index)</h4></li><li><h4 id="索引不是唯一的-unique-。"><a href="#索引不是唯一的-unique-。" class="headerlink" title="索引不是唯一的(unique)。"></a>索引不是唯一的(unique)。</h4></li></ul></li></ul><h5 id="Chage-Buffer"><a href="#Chage-Buffer" class="headerlink" title="Chage Buffer"></a>Chage Buffer</h5><ul><li><h4 id="可以视为insert-buffer-的升级。InnoDB可以对DML操作——insert，delete，update都进行缓冲，他们分别是：Insert-Buffer-Delete-Buffer-Purge-buffer"><a href="#可以视为insert-buffer-的升级。InnoDB可以对DML操作——insert，delete，update都进行缓冲，他们分别是：Insert-Buffer-Delete-Buffer-Purge-buffer" class="headerlink" title="可以视为insert  buffer 的升级。InnoDB可以对DML操作——insert，delete，update都进行缓冲，他们分别是：Insert Buffer, Delete Buffer, Purge buffer."></a>可以视为insert  buffer 的升级。InnoDB可以对DML操作——insert，delete，update都进行缓冲，他们分别是：Insert Buffer, Delete Buffer, Purge buffer.</h4></li><li><h4 id="和之前的-insert-buffer-一样，使用对象依然是-非唯一的辅助索引。"><a href="#和之前的-insert-buffer-一样，使用对象依然是-非唯一的辅助索引。" class="headerlink" title="和之前的 insert buffer 一样，使用对象依然是 非唯一的辅助索引。"></a>和之前的 insert buffer 一样，使用对象依然是 非唯一的辅助索引。</h4></li></ul><p>对一条记录进行 update 可能分为两步</p><ol><li><h4 id="将记录标记为已经删除"><a href="#将记录标记为已经删除" class="headerlink" title="将记录标记为已经删除"></a>将记录标记为已经删除</h4></li><li><h4 id="真正地将记录删除。"><a href="#真正地将记录删除。" class="headerlink" title="真正地将记录删除。"></a>真正地将记录删除。</h4></li></ol><ul><li><h4 id="delete-buffer-对应update操作的第一个过程，Purge-Buffer-对应update操作的第二个过程，即将记录真正的删除。"><a href="#delete-buffer-对应update操作的第一个过程，Purge-Buffer-对应update操作的第二个过程，即将记录真正的删除。" class="headerlink" title="delete buffer 对应update操作的第一个过程，Purge Buffer 对应update操作的第二个过程，即将记录真正的删除。"></a>delete buffer 对应update操作的第一个过程，Purge Buffer 对应update操作的第二个过程，即将记录真正的删除。</h4></li></ul><h5 id="insert-buffer-的内部实现"><a href="#insert-buffer-的内部实现" class="headerlink" title="insert buffer 的内部实现"></a>insert buffer 的内部实现</h5><ul><li><h4 id="insert-buffer-的数据结构是一颗B-树。现在版本的MySQL-全局只有一颗Insert-Buffer-B-树。负责对有所的表的辅助索引进行insert-buffer，B-树放在共享表空间中。"><a href="#insert-buffer-的数据结构是一颗B-树。现在版本的MySQL-全局只有一颗Insert-Buffer-B-树。负责对有所的表的辅助索引进行insert-buffer，B-树放在共享表空间中。" class="headerlink" title="insert buffer 的数据结构是一颗B+树。现在版本的MySQL,全局只有一颗Insert Buffer B+树。负责对有所的表的辅助索引进行insert buffer，B+树放在共享表空间中。"></a>insert buffer 的数据结构是一颗B+树。现在版本的MySQL,全局只有一颗Insert Buffer B+树。负责对有所的表的辅助索引进行insert buffer，B+树放在共享表空间中。</h4></li><li><h4 id="非叶子节点存储的是查询的-search-key-键值。"><a href="#非叶子节点存储的是查询的-search-key-键值。" class="headerlink" title="非叶子节点存储的是查询的 search key 键值。"></a>非叶子节点存储的是查询的 search key 键值。</h4></li></ul><h5 id="Merge-Insert-Buffer"><a href="#Merge-Insert-Buffer" class="headerlink" title="Merge Insert Buffer"></a>Merge Insert Buffer</h5><h2 id="学习MySQL敲的SQL-demo"><a href="#学习MySQL敲的SQL-demo" class="headerlink" title="学习MySQL敲的SQL demo"></a>学习MySQL敲的SQL demo</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br></pre></td><td class="code"><pre><code class="hljs MYSQl">SHOW VARIABLES like &quot;slow&quot;;<br><br>set GLOBAL slow_query_Log = on;<br><br><br><br>create table employee(<br>id int not null auto_increment primary key,<br>name varchar(30) comment &#x27;姓名&#x27;,<br>sex varchar(1) comment &#x27;性别&#x27;,<br>salary int comment &#x27;薪资（元）&#x27;,<br>dept varchar(30) comment &#x27;部门&#x27;<br>);<br><br>insert into employee(name, sex, salary, dept) values(&#x27;张三&#x27;, &#x27;男&#x27;, 5500, &#x27;部门A&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;李洁&#x27;, &#x27;女&#x27;, 4500, &#x27;部门C&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;李小梅&#x27;, &#x27;女&#x27;, 4200, &#x27;部门A&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;欧阳辉&#x27;, &#x27;男&#x27;, 7500, &#x27;部门C&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;李芳&#x27;, &#x27;女&#x27;, 8500, &#x27;部门A&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;张江&#x27;, &#x27;男&#x27;, 6800, &#x27;部门A&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;李四&#x27;, &#x27;男&#x27;, 12000, &#x27;部门B&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;王五&#x27;, &#x27;男&#x27;, 3500, &#x27;部门B&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;马小龙&#x27;, &#x27;男&#x27;, 6000, &#x27;部门A&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;龙五&#x27;, &#x27;男&#x27;, 8000, &#x27;部门B&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;冯小芳&#x27;, &#x27;女&#x27;, 10000, &#x27;部门C&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;马小花&#x27;, &#x27;女&#x27;, 4000, &#x27;部门B&#x27;);<br>insert into employee(name, sex, salary, dept) values(&#x27;柳峰&#x27;, &#x27;男&#x27;, 8800, &#x27;部门A&#x27;);<br><br><br><br><br><br><br><br><br>EXPLAIN SELECT * from employee  where name = &quot;柳峰&quot;;<br><br>EXPLAIN SELECT * FROM employee WHERE id = 13;<br><br><br>show INDEX from  employee;<br><br>EXPLAIN SELECT * FROM employee WHERE   NAME = &quot;柳峰&quot; ;<br><br>CREATE INDEX  idx_name  on employee(name);<br><br>show index FROM employee ;<br><br>drop INDEX  idx_name  on employee;<br><br>CREATE INDEX idx_name_salary_dept  on employee(name,salary,dept); <br><br>EXPLAIN SELECT * FROM employee where   name = &quot;柳峰&quot; and salary = 8800 ;<br><br>explain select * from employee where  salary=8800;<br><br>explain select * from employee where  dept=&#x27;部门A&#x27;;<br><br>EXPLAIN SELECT * FROM employee where name like &quot;五&quot; ;<br><br><br>SELECT * FROM employee   ;<br><br>SELECT * from  employee WHERE id = 11; <br><br>EXPLAIN SELECT  id FROM employee where id =11; <br><br>EXPLAIN select  id from employee ; <br><br>EXPLAIN select name,salary from employee ;<br><br><br>--  查询数据存放的位置。<br>show  VARIABLES like &quot;datadir&quot; ;<br><br><br>show DATABASEs; <br><br>SHOW INDEX from  employee; <br><br><br>-- 所以重点来了，之所以在二级索引列都是等值匹配的情况下才可能使用 Intersection 索<br>-- 引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。<br><br><br>CREATE TABLE test (<br>    id INT NOT NULL AUTO_INCREMENT,<br>    key1 VARCHAR(100),<br>    key2 INT,<br>    key3 VARCHAR(100),<br>    key_part1 VARCHAR(100),<br>    key_part2 VARCHAR(100),<br>    key_part3 VARCHAR(100),<br>    col1 VARCHAR(100),<br>    PRIMARY KEY (id),<br>    KEY idx_key1 (key1),<br>    UNIQUE KEY idx_key2 (key2),<br>    KEY idx_key_part(key_part1, key_part2, key_part3)<br>) Engine=InnoDB CHARSET=utf8;<br><br><br><br><br>1, 如果从各个二级索引中查询到的结果本身就是按照主键提前排好序的，那么求解二个有序列表交集的时间复杂度就很低O(n) （这不就是归并排序算法的核心么）<br><br>2, 如果从各个二级索引中查询到的结果集并不是按照主键排序的话，就需要将多个返回的主键列表进行排完序后，再回表进行数据操作。<br><br>为什么在回表前需要先按主键列表进行排序？还不明白？ 因为需要尽可能利用顺序IO，避免随机IO，提升IO读取效率<br><br><br><br><br>CREATE TABLE t1 (m1 int, n1 char(1));<br><br>CREATE TABLE t2 (m2 int, n2 char(1));<br><br>INSERT INTO t1 VALUES(1, &#x27;a&#x27;), (2, &#x27;b&#x27;), (3, &#x27;c&#x27;);<br><br>INSERT INTO t2 VALUES(2, &#x27;b&#x27;), (3, &#x27;c&#x27;), (4, &#x27;d&#x27;);<br><br><br><br><br>连接 的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。<br><br>过程看起来就是把 t1 表的记录和 t2 的记录连起来组成新的更大的记录，所以这个查询过程称之为连接查<br>询。连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果<br>集就可以称之为 笛卡尔积 。<br><br><br><br>SELECT m1,n1,`name` FROM t1, employee  where t1.m1 &gt;2   and employee.salary &gt;8000 ; <br><br><br><br><br>CREATE TABLE student (<br> number INT NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,<br> name VARCHAR(5) COMMENT &#x27;姓名&#x27;,<br> major VARCHAR(30) COMMENT &#x27;专业&#x27;,<br> PRIMARY KEY (number)<br>) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生信息表&#x27;;<br><br><br><br>CREATE TABLE score (<br> number INT COMMENT &#x27;学号&#x27;,<br> subject VARCHAR(30) COMMENT &#x27;科目&#x27;,<br> score TINYINT COMMENT &#x27;成绩&#x27;,<br> PRIMARY KEY (number, score)<br>) Engine=InnoDB CHARSET=utf8 COMMENT &#x27;学生成绩表&#x27;;<br><br><br>INSERT INTO student VALUES (1,&quot;五&quot;, &quot;cs1&quot;),(2,&quot;五2&quot;,&quot;cs2&quot;),(3,&quot;五3&quot;,&quot;cs3&quot;);<br><br><br><br><br>一般情况下，我们都把只涉及单表的过滤条件放到 WHERE 子句中，把涉及两表的过滤条件都放到 ON 子句中，我<br>们也一般把放到 ON 子句中的过滤条件也称之为 连接条件 。<br><br><br>-- 内连接中的where子句和on子句是等价的。<br><br>-- left join  左外连接 左边是驱动表，右边是被驱动表。<br><br>SELECT s1.number, s1.name, s2.subject, s2.score FROM student AS s1 LEFT JOIN score<br>AS s2 ON s1.number = s2.number;<br><br><br>-- 对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件<br>-- on + 连接条件<br><br><br>SELECT  stu.address , stu.english  FROM student left JOIN stu on student.number = stu.id ;<br><br><br><br><br>内连接和外连接的根本区别就是在驱动表中的记录不符合 ON 子句中的连接条件时不会把该记录加入到最后的结<br>果集<br><br>由于在内连接中ON子句和WHERE子句是等价的，所以内连接中不要求强制写明ON子句。<br><br><br><br><br>嵌套循环连接<br>这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于<br>对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为 嵌套循环连接 （ Nested-Loop Join ），<br>这是最简单，也是最笨拙的一种连接查询算法。<br><br><br><br><br>假设 m2 和 n2 列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对 t2 表的查询。当<br>然，建立了索引不一定使用索引，只有在 二级索引 + 回表 的代价比全表扫描的代价更低时才会使用索引。<br><br><br><br>另外，有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部<br>分，这种情况下即使不能使用 eq_ref 、 ref 、 ref_or_null 或者 range 这些访问方法执行对被驱动表的查询的<br>话，也可以使用索引扫描，也就是 index 的访问方法来查询被驱动表。所以我们建议在真实工作中最好不要使<br>用 * 作为查询列表，最好把真实用到的列作为查询列表。<br><br><br><br>这个 join buffer 的大小是可以通过启动参数或者系统变量 join_buffer_size 进行配置，默认大小为 262144字<br>节 （也就是 256KB ），最小可以设置为 128字节 。当然，对于优化被驱动表的查询来说，最好是为被驱动表加<br>上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大 join_buffer_size 的<br>值来对连接查询进行优化。<br><br><br><br><br>-- 查看表的统计信息<br><br>SHOW TABLE STATUS like &quot;stu&quot; ;<br><br><br>SHOW VARIABLES LIKE &#x27;optimizer_trace&#x27;;<br><br><br><br>SHOW VARIABLES LIKE &quot;%bin%&quot;<br><br><br><br><br><br>SHOW VARIABLES like &quot; innodb_purge_threads&quot; ;<br><br><br><br>SHOW ENGINE INNODB STATUS ;<br><br><br><br><br>-- 错误日志<br><br>SHOW VARIABLES like &quot;log_error&quot;;<br><br><br>-- 慢查询日志  设置 慢查询的阈值<br><br>show VARIABLES like &quot;long_query_time&quot; ;<br><br>show VARIABLES like &quot;log_slow_queries&quot; ;<br><br>SHOW VARIABLES like &#x27;%slow%&#x27; ;<br><br>-- 无索引下的慢查询<br>SHOW VARIABLES like &#x27;log_queries_not_using_indexes&#x27;  ;<br><br><br><br>show CREATE table mysql.slow_log ;<br><br>alter TABLE mysql.slow_log ENGINE = MyISM; <br><br>show VARIABLES like &#x27;%bin%&#x27; ;<br><br>show master status;<br><br>UPDATE book set name = &quot;test&quot; WHERE id =1;<br><br><br>-- SHOW BINLOG EVENTS in  &#x27;mysqld.???&#x27; ;<br>-- <br><br><br>-- 恢复 recovery    复制 replication   审计  audit  <br><br><br>-- 套接字文件<br><br>show VARIABLES like &#x27;SOCKET&#x27; ;<br><br><br>-- pid 文件<br><br>show  VARIABLES like  &#x27;pid_file&#x27; ;<br><br><br><br><br>CREATE table mytest (<br>t1 VARCHAR(10),<br>t2 VARCHAR(10),<br>t3 VARCHAR(10),<br>t4 VARCHAR(10)<br>) NGINE = INNODB CHARACTER;<br><br><br><br>SELECT * FROM  mytest ;<br><br><br>CREATE table mytest (<br>t1 VARCHAR(61)<br>) ENGINE = INNODB CHARSET=GBK ;<br><br>-- 约束<br><br>--  表建立时进行约束定义， 利用 ALTER table 命令进行创建约束。<br><br><br>CREATE TABLE u (<br>id int,<br>name VARCHAR(30),<br>id_card char(10),<br>PRIMARY KEY(id),<br>UNIQUE KEY (NAME) <br><br>);<br><br><br><br>CREATE TABLE p (<br>id int ,<br>u_id int ,<br>PRIMARY KEY(id),<br>FOREIGN KEY(u_id) REFERENCES p (id));<br><br><br><br><br><br><br>-- 对错误数据的约束<br><br><br>CREATE  TABLE a (<br>id int not NULL ,<br>date  DATE not null<br>);<br><br><br><br><br><br>INSERT into a SELECT 122, &#x27;2022-09-29&#x27; ;<br><br><br>SELECT * FROM a;<br><br>show WARNINGS ;<br><br><br><br><br> --  enum  和 set 约束<br> <br> <br> CREATE TABLE enumTest (<br>id int ,<br>sex enum(&#x27;male&#x27;,&#x27;female&#x27;));<br><br><br>INSERT into enumTest SELECT 3, &#x27;male&#x27; ;<br><br>SELECT * FROM enumTest ;<br><br><br>--  触法器和约束<br><br><br><br><br>-- 外键约束  myisam 存储引擎不支持 外键，INNODB 存储引擎则完整支持外键约束。<br><br>-- 可以在创建表 时添加外键， 也可以在创建表后 alter table  来添加。 <br><br><br>CREATE TABLE parent (<br><br>id int not null,<br>PRIMARY KEY(id)<br>)  ENGINE = INNODB;<br><br><br>CREATE TABLE child (<br><br>id int ,parent_id int ,<br>FOREIGN KEY (parent_id) REFERENCES parent(id)<br>) ENGINE =INNODB;<br><br><br> 一般来说 被引用的表为父表，引用的表为子表，外键定义时 的 on delete 和 on update<br> 表示 在父类进行 delete 和 update 操作时，对子表所作的操作 可定义的子操作有：<br> CASCADE, SETNULL, NO ACTION, RESTRECIT .<br> <br> <br> <br>SHOW TABLES;<br><br>  <br>-- 查看是否分区<br>RANGE 分区， LIST 分区，HASH分区， KEY分区<br>show VARIABLES like &quot;%partition%&quot;;  <br><br>show PLUGINS;<br><br><br><br><br><br>B+ 树索引。  --- 聚簇索引，辅助索引。 clustered index, secondary index .高度平衡<br>叶子节点存放着所有数据。 两种索引的区别是： 叶子节点存放的是否是一整行的信息。<br><br><br><br><br> 聚簇索引： 按照每张表的主键构造一颗B+树，同时叶子节点种存放的即为整张表的行记录数据，也叫聚簇索引的叶子节点<br> 叫做数据页。 数据页通过双向链表进行连接。 <br> 由于实际的数据页只能按一颗B+树进行排序，所以每张表只能有一个聚簇索引。多数情况，查询优化器倾向于用聚簇索引。<br> <br> 因为聚簇索引能够再B+树索引上的叶子节点上直接找到数据，并且由于定义了数据的逻辑顺序，聚簇索引能特别快的访问对范围值的查询。<br> 查询优化器能快速发现某一段范围的数据页需要扫描。<br> <br> <br> <br> CREATE TABLE index_test(<br>a int not null,<br>b VARCHAR(8000),<br>c int not null,<br>PRIMARY key(a),<br>key idx_c(c)) ENGINE =INNODB;<br> <br><br><br>INSERT into index_test SELECT 1,repeat(&#x27;a&#x27;,7000),-1;<br>INSERT into index_test SELECT 2,repeat(&#x27;a&#x27;,7000),-2;<br>INSERT into index_test SELECT 3,repeat(&#x27;a&#x27;,7000),-3;<br>INSERT into index_test SELECT 4,repeat(&#x27;a&#x27;,7000),-4;<br><br><br><br>聚簇索引的存储不是物理上连续的，而是逻辑上连续的，这其中有两两点：一是页面通过双向链表连接，按照<br>主键的顺序排序。二十每个页中的记录也是通过双向链表进行维护的，物理存储上可以同样不按照主键存储。<br><br><br><br><br><br>show INDEX from index_test;<br><br>ALTER table t add key idx_b (b(100)) ;<br><br>show index from t;<br><br><br><br><br><br><br><br><br><br><br><br>测试   联合索引<br><br><br>CREATE TABLE buy_log(<br>userid int UNSIGNED not null,<br>buy_date DATE<br>)ENGINE=INNODB ;<br><br><br>INSERT INTO buy_log VALUES(1,&#x27;2022-10-09&#x27;);<br>INSERT INTO buy_log VALUES(2,&#x27;2022-10-09&#x27;);<br>INSERT INTO buy_log VALUES(3,&#x27;2022-10-09&#x27;);<br>INSERT INTO buy_log VALUES(1,&#x27;2022-10-10&#x27;);<br>INSERT INTO buy_log VALUES(3,&#x27;2022-10-10&#x27;);<br>INSERT INTO buy_log VALUES(1,&#x27;2022-8-09&#x27;);<br>INSERT INTO buy_log VALUES(1,&#x27;2022-9-09&#x27;);<br><br><br><br>ALTER TABLE buy_log add key(userid);<br>ALTER TABLE buy_log add key(userid,buy_date);<br><br><br>show index from buy_log ;<br><br>EXPLAIN  SELECT * FROM buy_log WHERE userid = 2;<br><br><br>EXPLAIN SELECT * FROM buy_log where userid = 1 ORDER BY buy_date DESC LIMIT 3;<br><br><br><br>测试 索引覆盖<br><br>EXPLAIN  SELECT count(*) from buy_log ;<br><br><br>EXPLAIN SELECT count(*) FROM buy_log <br>where buy_date &gt;=&#x27;2022-10-02&#x27; and buy_date &lt;&#x27;2023-01-01&#x27; ;<br><br><br>force index 强制使用 索引。<br><br>EXPLAIN SELECT count(*) FROM buy_log force INDEX(userid_2)<br>where buy_date &gt;=&#x27;2022-10-02&#x27; and buy_date &lt;&#x27;2023-01-01&#x27; ;<br><br>  <br>drop table if EXISTS t; <br><br>CREATE table t(<br>a int ,<br>b int ,<br>key (a),<br>key (b)<br>) ENGINE = INNODB;<br><br><br>SELECT * FROM t ;<br><br><br>INSERT into t SELECT 1,1;<br>INSERT into t SELECT 1,2;<br>INSERT into t SELECT 2,3;<br>INSERT into t SELECT 2,4;<br>INSERT into t SELECT 1,2;<br><br><br>EXPLAIN SELECT * FROM t where a=1 and b=2 ;  <br><br><br>使用 use index(a);  优化器还是会自己分析来 决定是否使用 索引。<br><br>EXPLAIN SELECT * FROM t use index(a) where a= 1 and b =2;<br><br><br>但使用 force index 的索引提示 ，会 强制使用 指定的索引，<br><br><br>EXPLAIN SELECT * FROM t force index(a) where a = 1 and b=2;<br><br><br><br>show index from t;<br><br><br><br><br>全文检索 测试<br><br>CREATE table fts_a(<br><br>FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL,<br>BODY TEXT,<br>PRIMARY KEY(FTS_DOC_ID)<br><br>) ENGINE = INNODB;<br><br><br>INSERT INTO fts_a select null, &#x27;please porridge in pot&#x27;;<br>INSERT INTO fts_a select null, &#x27;please porridge in cold&#x27;;<br>INSERT INTO fts_a select null, &#x27;nice day&#x27;;<br>INSERT INTO fts_a select null, &#x27;some like it hot, some like it cold&#x27;;<br>INSERT INTO fts_a select null, &#x27;some like it in the  pot&#x27;;<br>INSERT INTO fts_a select null, &#x27;nine days old&#x27;;<br>INSERT INTO fts_a select null, &#x27;i like code days&#x27;;<br><br><br><br>CREATE FULLTEXT index idx_fts on fts_a(body);<br><br><br>SELECT * FROM fts_a;  <br><br><br>set GLOBAL INNODB_ft_aux_table = &#x27;test/fts_a&#x27; ;<br><br><br><br><br>全文查询  使用 match  against   <br><br>SELECT * FROM fts_a WHERE MATCH(body)<br>AGAINST(&#x27;cold&#x27; in NATURAL LANGUAGE MODE);<br><br><br><br>因为 match against 是默认的全文检索模式，因此可以省略查询修饰词。 上面的查询 等价于：<br><br>SELECT * FROM fts_a where  MATCH(body) against (&#x27;pot&#x27; );<br><br><br>查看存储引擎中的latch <br>show ENGINE INNODB MUTEX;<br><br><br>查看存储引擎中的lock 信息<br><br><br>show ENGINE INNODB STATUS;     --  ============================<br><br><br><br>begin;<br><br><br><br><br><br><br>-- 锁问题<br><br><br>SELECT * from t ;<br><br>begin<br><br><br>SELECT * FROM t WHERE a &lt;2 for UPDATE ;<br><br>BEGIN<br><br>insert INTO t SELECT 5,6;<br>INSERT into t VALUES (10,20),(14,20),(30,100);<br><br><br>COMMIT;<br><br><br><br><br><br>show ENGINES ;<br><br><br><br><br>测试 事务的隔离级别  RR 和 RC <br><br><br><br>CREATE TABLE `account_log` (<br>  `log_id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;流水号&#x27;,<br>  `amount` int NOT NULL COMMENT &#x27;交易金额&#x27;,<br>  `timestamp` datetime NOT NULL COMMENT &#x27;时间戳&#x27;,<br>  `from_system` int NOT NULL COMMENT &#x27;转出系统编码&#x27;,<br>  `from_system_transaction_number` int DEFAULT NULL COMMENT &#x27;转出系统的交易号&#x27;,<br>  `from_account` int DEFAULT NULL COMMENT &#x27;转出账户&#x27;,<br>  `to_system` int NOT NULL COMMENT &#x27;转入系统编码&#x27;,<br>  `to_system_transaction_number` int DEFAULT NULL COMMENT &#x27;转入系统的交易号&#x27;,<br>  `to_account` int DEFAULT NULL COMMENT &#x27;转入账户&#x27;,<br>  `transaction_type` int NOT NULL COMMENT &#x27;交易类型编码&#x27;,<br>  PRIMARY KEY (`log_id`)<br>);<br><br><br>CREATE TABLE `account_balance` (<br>  `user_id` int NOT NULL COMMENT &#x27;用户ID&#x27;,<br>  `balance` int NOT NULL COMMENT &#x27;余额&#x27;,<br>  `timestamp` datetime NOT NULL COMMENT &#x27;时间戳&#x27;,<br>  `log_id` int NOT NULL COMMENT &#x27;最后一笔交易的流水号&#x27;,<br>  PRIMARY KEY (`user_id`)<br>);<br><br>insert into account_log values (NULL, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);<br><br>insert into account_balance values (0, 100, NOW(), 1);<br><br><br>修改MySQL事务隔离级别<br><br>默认是RR <br>SELECT @@global.transaction_isolation, @@transaction_isolation;<br><br><br>2、MySQL5.7 及更高版本<br><br><br>set global transaction_isolation=&#x27;read-uncommitted&#x27;;<br>set global transaction_isolation=&#x27;read-committed&#x27;;<br>set global transaction_isolation=&#x27;repeatable-read&#x27;;<br>set global transaction_isolation=&#x27;serializable&#x27;;<br><br><br><br>修改为 RC类型  不可重复读<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>SELECT @@global.transaction_isolation, @@transaction_isolation;<br><br>修改为 RR类型  可重复读 INNODB 默认 隔离级别<br><br>SELECT @@global.transaction_isolation, @@transaction_isolation;<br><br>set global transaction_isolation=&#x27;repeatable-read&#x27;;<br>set SESSION transaction_isolation=&#x27;repeatable-read&#x27;;<br><br><br>测试RC级别  <br><br>开始会话1<br><br><br>begin;<br>select log_id, amount, timestamp from account_log order by log_id;<br><br><br>select user_id, balance, timestamp, log_id from account_balance;<br><br><br><br>开始会话2<br><br>begin;<br>select log_id, amount, timestamp from account_log order by log_id;<br><br>-- 写入流水<br>insert into account_log values (NULL, 100, NOW(), 1, 1001, NULL, 0, NULL, 0, 0);<br>-- 更新余额<br>update account_balance set balance = balance + 100, log_id = LAST_INSERT_ID(), timestamp = NOW() where user_id = 0 and log_id = 1;<br>-- 当前账户有2条流水记录<br>select log_id, amount, timestamp from account_log order by log_id;<br><br>select user_id, balance, timestamp, log_id from account_balance;<br><br>commit;<br>-- 提交会话2<br><br><br>结束会话2  回到会话1<br><br>-- 再次查询流水<br>select log_id, amount, timestamp from account_log order by log_id;<br><br>-- 再次查询账号余额<br>select user_id, balance, timestamp, log_id from account_balance;<br><br>commit;<br>-- 结束会话1<br><br>从会话1中可以看到第一次查询账号余额是100，但会话2中事务提交数据后，会话1再次查询账号余额变成了200，这就相当于会话1中的事务能够感知到其他已经提交了事务的数据变化，就这就是不可重复读（会话1中的事务能够总是能够读到最新数据），这就是RC事务隔离级别的特点。<br><br><br><br><br><br><br><br><br>SELECT VERSION();<br><br><br>show VARIABLES like &#x27;TRANSACTION_isolation&#x27; ;<br><br><br>CREATE TABLE `person`(<br>`id` BIGINT(20) UNSIGNED not null auto_increment COMMENT  &#x27;自增主键&#x27; ,<br>`income` BIGINT(20) not NULL COMMENT  &#x27;收入&#x27; ,<br>`expend` BIGINT(20) not NULL COMMENT  &#x27;支出&#x27; ,<br>PRIMARY KEY (`id`),<br>key `idx_income` (`income`)<br><br>) ENGINE = INNODB auto_increment =1 default CHARSET = utf8 COMMENT = &#x27;个人收支表&#x27; ;<br><br><br>INSERT into person  VALUES(100,1000,1000);<br>INSERT into person  VALUES(200,2000,2000);<br>INSERT into person  VALUES(300,3000,3000);<br>INSERT into person  VALUES(400,4000,4000);<br>INSERT into person  VALUES(500,5000,5000);<br><br><br><br>show MASTER STATUS ;<br><br>查看 binlog  内容 <br><br>show BINLOG EVENTS in &#x27;OVESH-bin.000050&#x27; ;<br><br><br><br><br>select user_id as buyer_id, join_date, count(order_id) as orders_in_2019<br>from Users as u left join Orders as o on u.user_id = o.buyer_id and year(order_date)=&#x27;2019&#x27;<br>group by user_id   ;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Suzy</title>
      <link href="/2022/10/15/Suzy/"/>
      <url>/2022/10/15/Suzy/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Suzy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Suzy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2022/10/15/JVM/"/>
      <url>/2022/10/15/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java虚拟机"><a href="#深入理解Java虚拟机" class="headerlink" title="深入理解Java虚拟机"></a>深入理解Java虚拟机</h1><h2 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h2><h2 id="Chapter-2-Java-内存区域与内存溢出异常"><a href="#Chapter-2-Java-内存区域与内存溢出异常" class="headerlink" title="Chapter 2  Java 内存区域与内存溢出异常"></a>Chapter 2  Java 内存区域与内存溢出异常</h2><h3 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2  运行时数据区域"></a>2.2  运行时数据区域</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220712225621082.png" alt="image-20220712225621082"></p><h4 id="2-2-1-程序计数器-（program-counter-register）"><a href="#2-2-1-程序计数器-（program-counter-register）" class="headerlink" title="2.2.1   程序计数器  （program counter register）"></a>2.2.1   程序计数器  （program counter register）</h4><ol><li><h4 id="是一块比较小的内存空间"><a href="#是一块比较小的内存空间" class="headerlink" title="是一块比较小的内存空间"></a>是一块比较小的内存空间</h4></li><li><h4 id="可以看作是当前线程执行的字节码的行号指示器"><a href="#可以看作是当前线程执行的字节码的行号指示器" class="headerlink" title="可以看作是当前线程执行的字节码的行号指示器"></a>可以看作是当前线程执行的字节码的行号指示器</h4></li><li><h4 id="是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。"><a href="#是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。" class="headerlink" title="是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。"></a>是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</h4></li><li><h4 id="java-虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。"><a href="#java-虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。" class="headerlink" title="java 虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。"></a>java 虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。</h4></li><li><h4 id="在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为-x3D-x3D-线程私有-x3D-x3D-的内存。"><a href="#在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为-x3D-x3D-线程私有-x3D-x3D-的内存。" class="headerlink" title="在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为&#x3D;&#x3D;线程私有&#x3D;&#x3D;的内存。"></a>在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为&#x3D;&#x3D;线程私有&#x3D;&#x3D;的内存。</h4></li><li><h4 id="如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。-x3D-x3D-此内存区域是唯-一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域-x3D-x3D-。"><a href="#如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。-x3D-x3D-此内存区域是唯-一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域-x3D-x3D-。" class="headerlink" title="如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。&#x3D;&#x3D;此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域&#x3D;&#x3D;。"></a>如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。&#x3D;&#x3D;此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域&#x3D;&#x3D;。</h4></li></ol><h4 id="2-2-2-JAVA-虚拟机栈"><a href="#2-2-2-JAVA-虚拟机栈" class="headerlink" title="2.2.2  JAVA 虚拟机栈"></a>2.2.2  JAVA 虚拟机栈</h4><ol><li><h4 id="与PC相同，java虚拟机栈也是线程私有的，-x3D-x3D-它的生命周期与线程相同-x3D-x3D-。"><a href="#与PC相同，java虚拟机栈也是线程私有的，-x3D-x3D-它的生命周期与线程相同-x3D-x3D-。" class="headerlink" title="与PC相同，java虚拟机栈也是线程私有的，&#x3D;&#x3D;它的生命周期与线程相同&#x3D;&#x3D;。"></a>与PC相同，java虚拟机栈也是线程私有的，&#x3D;&#x3D;它的生命周期与线程相同&#x3D;&#x3D;。</h4></li><li><h4 id="虚拟机栈描述的是JAVA方法执行的线程内存模型：-x3D-x3D-每个方法被执行的时候，Java虚拟机都-会同步创建一个栈帧-1-（Stack-Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信-息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。-x3D-x3D"><a href="#虚拟机栈描述的是JAVA方法执行的线程内存模型：-x3D-x3D-每个方法被执行的时候，Java虚拟机都-会同步创建一个栈帧-1-（Stack-Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信-息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。-x3D-x3D" class="headerlink" title="虚拟机栈描述的是JAVA方法执行的线程内存模型：&#x3D;&#x3D;每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&#x3D;&#x3D;"></a>虚拟机栈描述的是JAVA方法执行的线程内存模型：&#x3D;&#x3D;每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&#x3D;&#x3D;</h4></li><li></li></ol><ul><li><h4 id="经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继-承自传统的C、C-程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比-这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区-域是“堆”和“栈”两块。其中，-x3D-x3D-“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或-者更多的情况下只是指虚拟机栈中局部变量表部分-x3D-x3D-。"><a href="#经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继-承自传统的C、C-程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比-这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区-域是“堆”和“栈”两块。其中，-x3D-x3D-“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或-者更多的情况下只是指虚拟机栈中局部变量表部分-x3D-x3D-。" class="headerlink" title="经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继 承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比 这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区 域是“堆”和“栈”两块。其中，&#x3D;&#x3D;“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或 者更多的情况下只是指虚拟机栈中局部变量表部分&#x3D;&#x3D;。"></a>经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继 承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比 这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区 域是“堆”和“栈”两块。其中，&#x3D;&#x3D;“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或 者更多的情况下只是指虚拟机栈中局部变量表部分&#x3D;&#x3D;。</h4></li></ul><ol><li><h4 id="局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，-x3D-x3D-（reference类型，它并不等同于对象本身，可能是一个指向对象起始-地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）-x3D-x3D-和return-address类型（指向了一条字节码指令的地址）。"><a href="#局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，-x3D-x3D-（reference类型，它并不等同于对象本身，可能是一个指向对象起始-地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）-x3D-x3D-和return-address类型（指向了一条字节码指令的地址）。" class="headerlink" title="局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，&#x3D;&#x3D;（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）&#x3D;&#x3D;和return address类型（指向了一条字节码指令的地址）。"></a>局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，&#x3D;&#x3D;（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）&#x3D;&#x3D;和return address类型（指向了一条字节码指令的地址）。</h4></li><li><h4 id="这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，-x3D-x3D-当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定-的，在方法运行期间不会改变局部变量表的大小。-x3D-x3D"><a href="#这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，-x3D-x3D-当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定-的，在方法运行期间不会改变局部变量表的大小。-x3D-x3D" class="headerlink" title="这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，&#x3D;&#x3D;当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。&#x3D;&#x3D;"></a>这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，&#x3D;&#x3D;当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。&#x3D;&#x3D;</h4></li><li><h4 id="请读者注意，这里说的“大小”是指变量槽的数量，-虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一-个变量槽，这是完全由具体的虚拟机实现自行决定的事情。"><a href="#请读者注意，这里说的“大小”是指变量槽的数量，-虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一-个变量槽，这是完全由具体的虚拟机实现自行决定的事情。" class="headerlink" title="请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。"></a>请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</h4></li><li><h4 id="在《java虚拟机规范》中，对这个内存区域规定了-x3D-x3D-两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常-x3D-x3D-。"><a href="#在《java虚拟机规范》中，对这个内存区域规定了-x3D-x3D-两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常-x3D-x3D-。" class="headerlink" title="在《java虚拟机规范》中，对这个内存区域规定了&#x3D;&#x3D;两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常&#x3D;&#x3D;。"></a>在《java虚拟机规范》中，对这个内存区域规定了&#x3D;&#x3D;两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常&#x3D;&#x3D;。</h4></li></ol><ul><li><h4 id="HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟-机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不-会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情-况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。"><a href="#HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟-机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不-会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情-况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。" class="headerlink" title="HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情 况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。"></a>HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情 况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。</h4></li></ul><h4 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3  本地方法栈"></a>2.2.3  本地方法栈</h4><ol><li><h4 id="本地方法栈（Native-Method-Stack）-与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。"><a href="#本地方法栈（Native-Method-Stack）-与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。" class="headerlink" title="本地方法栈（Native Method Stack） 与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。"></a>本地方法栈（Native Method Stack） 与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。</h4><ol><li><h4 id="《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规-定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接-就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，-x3D-x3D-本地方法栈也会在栈深度溢出或者栈扩展失-败时分别抛出StackOverflowError和OutOfMemoryError异常-x3D-x3D"><a href="#《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规-定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接-就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，-x3D-x3D-本地方法栈也会在栈深度溢出或者栈扩展失-败时分别抛出StackOverflowError和OutOfMemoryError异常-x3D-x3D" class="headerlink" title="《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，&#x3D;&#x3D;本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常&#x3D;&#x3D;"></a>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，&#x3D;&#x3D;本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常&#x3D;&#x3D;</h4></li></ol></li></ol><h4 id="2-2-4-Java-堆"><a href="#2-2-4-Java-堆" class="headerlink" title="2.2.4   Java 堆"></a>2.2.4   Java 堆</h4><ol><li><h4 id="对于java应用程序来说，-x3D-x3D-Java堆（java-heap）-是虚拟机所管的的内存中最大的一块。-x3D-x3D-java堆是被所有线程共享的一块内存区域。"><a href="#对于java应用程序来说，-x3D-x3D-Java堆（java-heap）-是虚拟机所管的的内存中最大的一块。-x3D-x3D-java堆是被所有线程共享的一块内存区域。" class="headerlink" title="对于java应用程序来说，&#x3D;&#x3D;Java堆（java heap） 是虚拟机所管的的内存中最大的一块。&#x3D;&#x3D; java堆是被所有线程共享的一块内存区域。"></a>对于java应用程序来说，&#x3D;&#x3D;Java堆（java heap） 是虚拟机所管的的内存中最大的一块。&#x3D;&#x3D; java堆是被所有线程共享的一块内存区域。</h4></li><li><h4 id="x3D-x3D-Java堆是垃圾收集器管理的内存区域-x3D-x3D-，因此一些资料中它也被称作-x3D-x3D-“GC堆”-x3D-x3D-（Garbage-Collected-Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分-代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From-Survivor空-间”“To-Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的-是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体-实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着-类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年-之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部-都基于“经典分代”-3-来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还-算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出-现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。"><a href="#x3D-x3D-Java堆是垃圾收集器管理的内存区域-x3D-x3D-，因此一些资料中它也被称作-x3D-x3D-“GC堆”-x3D-x3D-（Garbage-Collected-Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分-代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From-Survivor空-间”“To-Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的-是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体-实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着-类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年-之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部-都基于“经典分代”-3-来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还-算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出-现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。" class="headerlink" title="&#x3D;&#x3D;Java堆是垃圾收集器管理的内存区域&#x3D;&#x3D;，因此一些资料中它也被称作&#x3D;&#x3D;“GC堆”&#x3D;&#x3D;（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分 代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空 间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的 是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体 实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着 类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年 之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” [3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。"></a>&#x3D;&#x3D;Java堆是垃圾收集器管理的内存区域&#x3D;&#x3D;，因此一些资料中它也被称作&#x3D;&#x3D;“GC堆”&#x3D;&#x3D;（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分 代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空 间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的 是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体 实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着 类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年 之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” [3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。</h4></li><li><h4 id="x3D-x3D-如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区-（Thread-Local-Allocation-Buffer，TLAB），以提升对象分配时的效率。-x3D-x3D-不过无论从什么角度，无论如-何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java-堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的-作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。"><a href="#x3D-x3D-如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区-（Thread-Local-Allocation-Buffer，TLAB），以提升对象分配时的效率。-x3D-x3D-不过无论从什么角度，无论如-何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java-堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的-作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。" class="headerlink" title="&#x3D;&#x3D;如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。&#x3D;&#x3D;不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的 作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。"></a>&#x3D;&#x3D;如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。&#x3D;&#x3D;不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的 作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。</h4></li><li><h4 id="根据《Java虚拟机规范》的规定，-x3D-x3D-Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该-被视为连续的-x3D-x3D-，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。-x3D-x3D-但对于大-对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的-内存空间。-x3D-x3D"><a href="#根据《Java虚拟机规范》的规定，-x3D-x3D-Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该-被视为连续的-x3D-x3D-，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。-x3D-x3D-但对于大-对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的-内存空间。-x3D-x3D" class="headerlink" title="根据《Java虚拟机规范》的规定，&#x3D;&#x3D;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的&#x3D;&#x3D;，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。&#x3D;&#x3D;但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。&#x3D;&#x3D;"></a>根据《Java虚拟机规范》的规定，&#x3D;&#x3D;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的&#x3D;&#x3D;，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。&#x3D;&#x3D;但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。&#x3D;&#x3D;</h4></li></ol><ul><li><h4 id="Java堆既可以被实现成固定大小的，也可以是可扩展的，-x3D-x3D-不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）-x3D-x3D-。-x3D-x3D-如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。-x3D-x3D"><a href="#Java堆既可以被实现成固定大小的，也可以是可扩展的，-x3D-x3D-不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）-x3D-x3D-。-x3D-x3D-如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。-x3D-x3D" class="headerlink" title="Java堆既可以被实现成固定大小的，也可以是可扩展的，&#x3D;&#x3D;不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）&#x3D;&#x3D;。&#x3D;&#x3D;如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&#x3D;&#x3D;"></a>Java堆既可以被实现成固定大小的，也可以是可扩展的，&#x3D;&#x3D;不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）&#x3D;&#x3D;。&#x3D;&#x3D;如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&#x3D;&#x3D;</h4></li></ul><h4 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5   方法区"></a>2.2.5   方法区</h4><ol><li><h4 id="方法区-Method-Area-与-Java-堆一样，是各个-x3D-x3D-线程共享的内存区域-x3D-x3D-，它用于存储已被虚拟机加载的-x3D-x3D-类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。-x3D-x3D-虽然《Java虚拟机规范》中把-方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区-分开来。"><a href="#方法区-Method-Area-与-Java-堆一样，是各个-x3D-x3D-线程共享的内存区域-x3D-x3D-，它用于存储已被虚拟机加载的-x3D-x3D-类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。-x3D-x3D-虽然《Java虚拟机规范》中把-方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区-分开来。" class="headerlink" title="方法区(Method Area ) 与 Java 堆一样，是各个&#x3D;&#x3D;线程共享的内存区域-&#x3D;&#x3D;，它用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。&#x3D;&#x3D;虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来。"></a>方法区(Method Area ) 与 Java 堆一样，是各个&#x3D;&#x3D;线程共享的内存区域-&#x3D;&#x3D;，它用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。&#x3D;&#x3D;虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来。</h4></li></ol><ul><li><h4 id="说到方法区，不得不提一下-x3D-x3D-“永久代”-x3D-x3D-这个概念，尤其是在JDK-8以前，许多Java程序员都习惯在-HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent-Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设-计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得-HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的-工作。但是对于其他虚拟机实现，譬如BEA-JRockit、IBM-J9等来说，是不存在永久代的概念的。原则-上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头-来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到-内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要-没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法-（例如String-intern-）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了-JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java-Mission-Control管理工具，移植到HotSpot-虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK-6的-时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native-Memory）来实现方法区的计-划了-1-，-x3D-x3D-到了JDK-7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了-JDK-8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK-7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。-x3D-x3D"><a href="#说到方法区，不得不提一下-x3D-x3D-“永久代”-x3D-x3D-这个概念，尤其是在JDK-8以前，许多Java程序员都习惯在-HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent-Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设-计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得-HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的-工作。但是对于其他虚拟机实现，譬如BEA-JRockit、IBM-J9等来说，是不存在永久代的概念的。原则-上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头-来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到-内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要-没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法-（例如String-intern-）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了-JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java-Mission-Control管理工具，移植到HotSpot-虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK-6的-时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native-Memory）来实现方法区的计-划了-1-，-x3D-x3D-到了JDK-7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了-JDK-8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK-7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。-x3D-x3D" class="headerlink" title="说到方法区，不得不提一下&#x3D;&#x3D;“永久代”&#x3D;&#x3D;这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，&#x3D;&#x3D;到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&#x3D;&#x3D;"></a>说到方法区，不得不提一下&#x3D;&#x3D;“永久代”&#x3D;&#x3D;这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，&#x3D;&#x3D;到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&#x3D;&#x3D;</h4></li><li><h4 id="《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选-择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的-确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。-x3D-x3D-这区域的内存回-收目标主要是针对常量池的回收和对类型的卸载，-x3D-x3D-一般来说这个区域的回收效果比较难令人满意，尤-其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列-表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存-泄漏。"><a href="#《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选-择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的-确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。-x3D-x3D-这区域的内存回-收目标主要是针对常量池的回收和对类型的卸载，-x3D-x3D-一般来说这个区域的回收效果比较难令人满意，尤-其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列-表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存-泄漏。" class="headerlink" title="《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。&#x3D;&#x3D;这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，&#x3D;&#x3D;一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列 表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。"></a>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。&#x3D;&#x3D;这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，&#x3D;&#x3D;一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列 表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。</h4></li></ul><ol><li><h4 id="根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出-OutOfMemoryError异常。"><a href="#根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出-OutOfMemoryError异常。" class="headerlink" title="根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。"></a>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</h4></li></ol><h4 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6   运行时常量池"></a>2.2.6   运行时常量池</h4><ol><li><h4 id="运行时常量池（Runtime-Constant-Pool-是方法区的一部分。Class-文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。"><a href="#运行时常量池（Runtime-Constant-Pool-是方法区的一部分。Class-文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。" class="headerlink" title="运行时常量池（Runtime Constant Pool )  是方法区的一部分。Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。"></a>运行时常量池（Runtime Constant Pool )  是方法区的一部分。Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。</h4></li><li><h4 id="Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用-于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，-《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现-这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来-的直接引用也存储在运行时常量池中-1-。"><a href="#Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用-于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，-《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现-这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来-的直接引用也存储在运行时常量池中-1-。" class="headerlink" title="Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用 于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来 的直接引用也存储在运行时常量池中[1]。"></a>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用 于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来 的直接引用也存储在运行时常量池中[1]。</h4></li><li><h4 id="运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量-一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常-量池，-x3D-x3D-运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的-intern-方法。-x3D-x3D"><a href="#运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量-一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常-量池，-x3D-x3D-运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的-intern-方法。-x3D-x3D" class="headerlink" title="运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，&#x3D;&#x3D;运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&#x3D;&#x3D;"></a>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，&#x3D;&#x3D;运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&#x3D;&#x3D;</h4></li><li><h4 id="x3D-x3D-既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存-时会抛出OutOfMemoryError异常。-x3D-x3D"><a href="#x3D-x3D-既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存-时会抛出OutOfMemoryError异常。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。&#x3D;&#x3D;"></a>&#x3D;&#x3D;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。&#x3D;&#x3D;</h4></li></ol><h4 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7    直接内存"></a>2.2.7    直接内存</h4><ol><li><h4 id="直接内存（Direct-Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中-定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所-以我们放到这里一起讲解。"><a href="#直接内存（Direct-Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中-定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所-以我们放到这里一起讲解。" class="headerlink" title="直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。"></a>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。</h4></li><li><h4 id="在JDK-1-4中新加入了-x3D-x3D-NIO（New-Input-x2F-Output）类-x3D-x3D-，引入了-x3D-x3D-一种基于通道（Channel）与缓冲区-（Buffer）的I-x2F-O方式-x3D-x3D-，-x3D-x3D-它可以使用Native函数库直接分配堆外内存-x3D-x3D-，然后通过一个存储在Java堆里面的-DirectByteBuffer对象作为这块内存的引用进行操作。-x3D-x3D-这样能在一些场景中显著提高性能，因为避免了-在Java堆和Native堆中来回复制数据。-x3D-x3D"><a href="#在JDK-1-4中新加入了-x3D-x3D-NIO（New-Input-x2F-Output）类-x3D-x3D-，引入了-x3D-x3D-一种基于通道（Channel）与缓冲区-（Buffer）的I-x2F-O方式-x3D-x3D-，-x3D-x3D-它可以使用Native函数库直接分配堆外内存-x3D-x3D-，然后通过一个存储在Java堆里面的-DirectByteBuffer对象作为这块内存的引用进行操作。-x3D-x3D-这样能在一些场景中显著提高性能，因为避免了-在Java堆和Native堆中来回复制数据。-x3D-x3D" class="headerlink" title="在JDK 1.4中新加入了&#x3D;&#x3D;NIO（New Input&#x2F;Output）类&#x3D;&#x3D;，引入了&#x3D;&#x3D;一种基于通道（Channel）与缓冲区 （Buffer）的I&#x2F;O方式&#x3D;&#x3D;，&#x3D;&#x3D;它可以使用Native函数库直接分配堆外内存&#x3D;&#x3D;，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。&#x3D;&#x3D;这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。&#x3D;&#x3D;"></a>在JDK 1.4中新加入了&#x3D;&#x3D;NIO（New Input&#x2F;Output）类&#x3D;&#x3D;，引入了&#x3D;&#x3D;一种基于通道（Channel）与缓冲区 （Buffer）的I&#x2F;O方式&#x3D;&#x3D;，&#x3D;&#x3D;它可以使用Native函数库直接分配堆外内存&#x3D;&#x3D;，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。&#x3D;&#x3D;这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。&#x3D;&#x3D;</h4></li><li><h4 id="显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到-本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务-器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得-各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现-OutOfMemoryError异常。"><a href="#显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到-本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务-器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得-各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现-OutOfMemoryError异常。" class="headerlink" title="显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。"></a>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。</h4></li></ol><h3 id="2-3-HotSpot-虚拟机对象探秘"><a href="#2-3-HotSpot-虚拟机对象探秘" class="headerlink" title="2.3 HotSpot 虚拟机对象探秘"></a>2.3 HotSpot 虚拟机对象探秘</h3><h4 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1  对象的创建"></a>2.3.1  对象的创建</h4><ul><li><h4 id="Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面-上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文-中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？"><a href="#Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面-上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文-中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？" class="headerlink" title="Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面 上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文 中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？"></a>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面 上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文 中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</h4></li></ul><ol><li><h4 id="x3D-x3D-当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到-一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那-必须先执行相应的类加载过程-x3D-x3D-，详情见第七章"><a href="#x3D-x3D-当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到-一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那-必须先执行相应的类加载过程-x3D-x3D-，详情见第七章" class="headerlink" title="&#x3D;&#x3D;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程&#x3D;&#x3D;，详情见第七章"></a>&#x3D;&#x3D;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程&#x3D;&#x3D;，详情见第七章</h4></li><li><h4 id="在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，-x3D-x3D-为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。-x3D-x3D-假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，-x3D-x3D-中间放着一个指针作为分解点的指示器，-x3D-x3D-那所分配内粗你就仅仅是-x3D-x3D-把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump-the-pointer-）-x3D-x3D-但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那-就没有办法简单地进行指针碰撞了，-x3D-x3D-虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分-配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称-为“空闲列表”（Free-List）。-x3D-x3D"><a href="#在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，-x3D-x3D-为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。-x3D-x3D-假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，-x3D-x3D-中间放着一个指针作为分解点的指示器，-x3D-x3D-那所分配内粗你就仅仅是-x3D-x3D-把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump-the-pointer-）-x3D-x3D-但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那-就没有办法简单地进行指针碰撞了，-x3D-x3D-虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分-配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称-为“空闲列表”（Free-List）。-x3D-x3D" class="headerlink" title="在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，&#x3D;&#x3D;为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。&#x3D;&#x3D;假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，&#x3D;&#x3D;中间放着一个指针作为分解点的指示器，&#x3D;&#x3D;那所分配内粗你就仅仅是&#x3D;&#x3D;把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump the pointer ）&#x3D;&#x3D; 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，&#x3D;&#x3D;虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。&#x3D;&#x3D;"></a>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，&#x3D;&#x3D;为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。&#x3D;&#x3D;假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，&#x3D;&#x3D;中间放着一个指针作为分解点的指示器，&#x3D;&#x3D;那所分配内粗你就仅仅是&#x3D;&#x3D;把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump the pointer ）&#x3D;&#x3D; 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，&#x3D;&#x3D;虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。&#x3D;&#x3D;</h4><ol><li><h4 id="选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用-的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩-整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除-（Sweep）算法的收集器时，理论上-1-就只能采用较为复杂的空闲列表来分配内存。"><a href="#选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用-的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩-整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除-（Sweep）算法的收集器时，理论上-1-就只能采用较为复杂的空闲列表来分配内存。" class="headerlink" title="选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用 的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。"></a>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用 的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</h4></li></ol></li><li><h4 id="除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行-为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象-A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题-有两种可选方案：-x3D-x3D-一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败-重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进-行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread-Local-Allocation-Buffer，TLAB）-x3D-x3D-，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完-了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以-x3D-x3D-通过-XX：-x2F-UseTLAB-x3D-x3D-参数来-设定。"><a href="#除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行-为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象-A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题-有两种可选方案：-x3D-x3D-一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败-重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进-行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread-Local-Allocation-Buffer，TLAB）-x3D-x3D-，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完-了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以-x3D-x3D-通过-XX：-x2F-UseTLAB-x3D-x3D-参数来-设定。" class="headerlink" title="除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：&#x3D;&#x3D;一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）&#x3D;&#x3D;，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以&#x3D;&#x3D;通过-XX：+&#x2F;-UseTLAB&#x3D;&#x3D;参数来 设定。"></a>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：&#x3D;&#x3D;一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）&#x3D;&#x3D;，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以&#x3D;&#x3D;通过-XX：+&#x2F;-UseTLAB&#x3D;&#x3D;参数来 设定。</h4></li></ol><ul><li><h4 id="x3D-x3D-内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值-x3D-x3D-，如果-使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段-在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。"><a href="#x3D-x3D-内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值-x3D-x3D-，如果-使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段-在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。" class="headerlink" title="&#x3D;&#x3D;内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值&#x3D;&#x3D;，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。"></a>&#x3D;&#x3D;内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值&#x3D;&#x3D;，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</h4></li><li><h4 id="x3D-x3D-接下来，Java虚拟机还要对对象进行必要的设置-x3D-x3D-，例如这个对象是哪个类的实例、如何才能找到-类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object-hashCode-方法时才-计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object-Header）之中。根据虚拟-机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内-容，稍后会详细介绍。"><a href="#x3D-x3D-接下来，Java虚拟机还要对对象进行必要的设置-x3D-x3D-，例如这个对象是哪个类的实例、如何才能找到-类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object-hashCode-方法时才-计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object-Header）之中。根据虚拟-机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内-容，稍后会详细介绍。" class="headerlink" title="&#x3D;&#x3D;接下来，Java虚拟机还要对对象进行必要的设置&#x3D;&#x3D;，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内 容，稍后会详细介绍。"></a>&#x3D;&#x3D;接下来，Java虚拟机还要对对象进行必要的设置&#x3D;&#x3D;，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内 容，稍后会详细介绍。</h4></li><li><h4 id="在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视-角看来，对象创建才刚刚开始——构造函数，即Class文件中的-方法还没有执行，所有的字段都-为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节-码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成-这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），-x3D-x3D-new指令之后会接着执行-方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。-x3D-x3D"><a href="#在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视-角看来，对象创建才刚刚开始——构造函数，即Class文件中的-方法还没有执行，所有的字段都-为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节-码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成-这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），-x3D-x3D-new指令之后会接着执行-方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。-x3D-x3D" class="headerlink" title="在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），&#x3D;&#x3D;new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。&#x3D;&#x3D;"></a>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），&#x3D;&#x3D;new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。&#x3D;&#x3D;</h4></li></ul><h4 id="2-3-2-对象的布局"><a href="#2-3-2-对象的布局" class="headerlink" title="2.3.2  对象的布局"></a>2.3.2  对象的布局</h4><ul><li><h4 id="在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例-数据（Instance-Data）和对齐填充（Padding）。"><a href="#在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例-数据（Instance-Data）和对齐填充（Padding）。" class="headerlink" title="在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）。"></a>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）。</h4></li></ul><p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部 分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它 为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的 最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效 率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根 据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年 龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标 记、可偏向）[1]下对象的存储内容如表2-1所示。</p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718183513160.png" alt="image-20220718183513160"></p><p>对象头的另外一部分是类型指针，&#x3D;&#x3D;即对象指向它的类型元数据的指针&#x3D;&#x3D;，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话 说，查找对象的元数据信息并不一定要经过对象本身，这点我们会在下一节具体讨论。此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，&#x3D;&#x3D;因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。&#x3D;&#x3D;</p><h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3  对象的访问定位"></a>2.3.3  对象的访问定位</h3><p>所以对象访问方式也是由虚拟机实 现而定的，主流的访问方式主要有使用&#x3D;&#x3D;句柄和直接指针&#x3D;&#x3D;两种：</p><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图2-2所 示。</p><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销，如图2-3所示。</p><p>这两种对象访问方式各有优势，&#x3D;&#x3D;使用句柄来访问的最大好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。&#x3D;&#x3D;</p><p>1. </p><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718193528820.png" alt="image-20220718193528820"></p><ol start="2"><li></li></ol><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718193540698.png" alt="image-20220718193540698"></p><p>&#x3D;&#x3D;使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销&#x3D;&#x3D;，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟 机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发，具体可参见第3章），但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。</p><h3 id="2-4-实战-：-OutOfMemoryError-异常"><a href="#2-4-实战-：-OutOfMemoryError-异常" class="headerlink" title="2.4     实战 ：  OutOfMemoryError 异常"></a>2.4     实战 ：  OutOfMemoryError 异常</h3><h4 id="2-4-1-Java堆溢出"><a href="#2-4-1-Java堆溢出" class="headerlink" title="2.4.1    Java堆溢出"></a>2.4.1    Java堆溢出</h4><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会 产生内存溢出异常。</p><p>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示&#x3D;&#x3D;“Java heap space“&#x3D;&#x3D;。</p><p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。第一步首先应确认内存中导致OOM的对象是否是必 要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。图2-5显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。</p><p> 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内 存泄漏的代码的具体位置。</p><p>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，&#x3D;&#x3D;那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运 行期的内存消耗。 以上是处理Java堆内&#x3D;&#x3D;</p><h4 id="2-4-2-虚拟机栈和本地方法栈溢出"><a href="#2-4-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.4.2  虚拟机栈和本地方法栈溢出"></a>2.4.2  虚拟机栈和本地方法栈溢出</h4><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置 本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟 机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：</p><ol><li>&#x3D;&#x3D;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。&#x3D;&#x3D;</li><li>&#x3D;&#x3D;如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。&#x3D;&#x3D;</li></ol><h4 id="2-4-3-方法区和运行时常量池溢出"><a href="#2-4-3-方法区和运行时常量池溢出" class="headerlink" title="2.4.3    方法区和运行时常量池溢出"></a>2.4.3    方法区和运行时常量池溢出</h4><p>&#x3D;&#x3D;由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。前面曾经 提到HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代的背景 故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，对程序有什么 实际的影响。&#x3D;&#x3D;</p><p>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加 到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配 在永久代中，我们可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其 中常量池的容量，</p><h4 id="2-4-4-本机直接内存溢出"><a href="#2-4-4-本机直接内存溢出" class="headerlink" title="2.4.4    本机直接内存溢出"></a>2.4.4    本机直接内存溢出</h4><ul><li><h4 id="直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。"><a href="#直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。" class="headerlink" title="直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。"></a>直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。</h4></li></ul><p>使用unsafe 分配主机内存。</p><p>由直接内存导致的内存溢出： 一个明显的特征是 Heao Dump 文件中不会看见由什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory （典型的间接使用了NIO），那就可以考虑重点检查一下直接内存方面女的问题了。</p><h2 id="Chapter-3-垃圾收集器与内存分配策略"><a href="#Chapter-3-垃圾收集器与内存分配策略" class="headerlink" title="Chapter  3     垃圾收集器与内存分配策略"></a>Chapter  3     垃圾收集器与内存分配策略</h2><ul><li><h4 id="Java-与C-之间有一堵由-内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。"><a href="#Java-与C-之间有一堵由-内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。" class="headerlink" title="Java 与C++ 之间有一堵由 内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。"></a>Java 与C++ 之间有一堵由 内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</h4></li></ul><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1   概述"></a>3.1   概述</h3><ol><li><h4 id="那些内存需要回收？"><a href="#那些内存需要回收？" class="headerlink" title="那些内存需要回收？"></a>那些内存需要回收？</h4></li><li><h4 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h4></li><li><h4 id="如何回收-。"><a href="#如何回收-。" class="headerlink" title="如何回收?。"></a>如何回收?。</h4></li></ol><ul><li><h4 id="java-堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。-x3D-x3D-垃圾收集器所关注的正式这部分内存该管理-x3D-x3D-。"><a href="#java-堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。-x3D-x3D-垃圾收集器所关注的正式这部分内存该管理-x3D-x3D-。" class="headerlink" title="java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。&#x3D;&#x3D;垃圾收集器所关注的正式这部分内存该管理&#x3D;&#x3D;。"></a>java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。&#x3D;&#x3D;垃圾收集器所关注的正式这部分内存该管理&#x3D;&#x3D;。</h4></li></ul><h3 id="3-2-对象已死？"><a href="#3-2-对象已死？" class="headerlink" title="3.2    对象已死？"></a>3.2    对象已死？</h3><ul><li><h4 id="如何确定哪些对象还“存活“着，哪些已经”死去“？"><a href="#如何确定哪些对象还“存活“着，哪些已经”死去“？" class="headerlink" title="如何确定哪些对象还“存活“着，哪些已经”死去“？"></a>如何确定哪些对象还“存活“着，哪些已经”死去“？</h4></li></ul><h4 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1    引用计数算法"></a>3.2.1    引用计数算法</h4><p>大多教科书的算法：</p><ul><li><h4 id="x3D-x3D-在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。-x3D-x3D"><a href="#x3D-x3D-在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。&#x3D;&#x3D;"></a>&#x3D;&#x3D;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。&#x3D;&#x3D;</h4></li><li><h4 id="引用计数很难解决对象之间相互循环引用的问题。"><a href="#引用计数很难解决对象之间相互循环引用的问题。" class="headerlink" title="引用计数很难解决对象之间相互循环引用的问题。"></a>引用计数很难解决对象之间相互循环引用的问题。</h4></li><li><h4 id="两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。"><a href="#两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。" class="headerlink" title="两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。"></a>两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。</h4></li></ul><h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2      可达性分析算法"></a>3.2.2      可达性分析算法</h4><p>当前主流的商用应用程序的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。</p><ul><li><h4 id="这个算法的思路就是通过一系列-称为-”GC-Roots”-的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC-Roots-间没有任何引用链相连，-x3D-x3D-或者用图论的话说就是从GC-Roots-到这个对象不可达时，则证明此对象是不可能再被使用的。-x3D-x3D"><a href="#这个算法的思路就是通过一系列-称为-”GC-Roots”-的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC-Roots-间没有任何引用链相连，-x3D-x3D-或者用图论的话说就是从GC-Roots-到这个对象不可达时，则证明此对象是不可能再被使用的。-x3D-x3D" class="headerlink" title="这个算法的思路就是通过一系列 称为 ”GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots 间没有任何引用链相连，&#x3D;&#x3D;或者用图论的话说就是从GC Roots  到这个对象不可达时，则证明此对象是不可能再被使用的。&#x3D;&#x3D;"></a>这个算法的思路就是通过一系列 称为 ”GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots 间没有任何引用链相连，&#x3D;&#x3D;或者用图论的话说就是从GC Roots  到这个对象不可达时，则证明此对象是不可能再被使用的。&#x3D;&#x3D;</h4></li><li><h4 id="在JAVA技术体系中里面，固定可作为GC-Roots-的对象包括以下几种："><a href="#在JAVA技术体系中里面，固定可作为GC-Roots-的对象包括以下几种：" class="headerlink" title="在JAVA技术体系中里面，固定可作为GC Roots 的对象包括以下几种："></a>在JAVA技术体系中里面，固定可作为GC Roots 的对象包括以下几种：</h4><ul><li><h4 id="在-x3D-x3D-虚拟机栈（栈帧中的本地变量表）中引用的对象-x3D-x3D-，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量"><a href="#在-x3D-x3D-虚拟机栈（栈帧中的本地变量表）中引用的对象-x3D-x3D-，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量" class="headerlink" title="在&#x3D;&#x3D;虚拟机栈（栈帧中的本地变量表）中引用的对象&#x3D;&#x3D;，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量"></a>在&#x3D;&#x3D;虚拟机栈（栈帧中的本地变量表）中引用的对象&#x3D;&#x3D;，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量</h4></li><li><h4 id="x3D-x3D-在方法区中类静态属性引用的对象-x3D-x3D-，譬如java类的引用类型静态变量"><a href="#x3D-x3D-在方法区中类静态属性引用的对象-x3D-x3D-，譬如java类的引用类型静态变量" class="headerlink" title="&#x3D;&#x3D;在方法区中类静态属性引用的对象&#x3D;&#x3D;，譬如java类的引用类型静态变量"></a>&#x3D;&#x3D;在方法区中类静态属性引用的对象&#x3D;&#x3D;，譬如java类的引用类型静态变量</h4></li><li><h4 id="在方法区中常量引用的对象，譬如字符串常量池（String-Table）里的引用"><a href="#在方法区中常量引用的对象，譬如字符串常量池（String-Table）里的引用" class="headerlink" title="在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用"></a>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</h4></li><li><h4 id="在本地方法栈中JNI（即通常所说的Native方法）引用的对象"><a href="#在本地方法栈中JNI（即通常所说的Native方法）引用的对象" class="headerlink" title="在本地方法栈中JNI（即通常所说的Native方法）引用的对象"></a>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</h4></li><li><h4 id="java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器"><a href="#java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器" class="headerlink" title="java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器"></a>java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</h4></li><li><h4 id="所有被同步锁（synchronized关键字）持有的对象"><a href="#所有被同步锁（synchronized关键字）持有的对象" class="headerlink" title="所有被同步锁（synchronized关键字）持有的对象"></a>所有被同步锁（synchronized关键字）持有的对象</h4></li><li><h4 id="反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。"><a href="#反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。" class="headerlink" title="反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。"></a>反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。</h4></li></ul></li></ul><h4 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3    再谈引用"></a>3.2.3    再谈引用</h4><ul><li><h4 id="x3D-x3D-当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。-x3D-x3D"><a href="#x3D-x3D-当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。&#x3D;&#x3D;"></a>&#x3D;&#x3D;当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。&#x3D;&#x3D;</h4></li><li><h4 id="java的引用，-x3D-x3D-强引用，软引用，弱引用，和虚引用-x3D-x3D-4种，这四种引用强度一次逐渐减弱。"><a href="#java的引用，-x3D-x3D-强引用，软引用，弱引用，和虚引用-x3D-x3D-4种，这四种引用强度一次逐渐减弱。" class="headerlink" title="java的引用，&#x3D;&#x3D;强引用，软引用，弱引用，和虚引用&#x3D;&#x3D;4种，这四种引用强度一次逐渐减弱。"></a>java的引用，&#x3D;&#x3D;强引用，软引用，弱引用，和虚引用&#x3D;&#x3D;4种，这四种引用强度一次逐渐减弱。</h4></li></ul><h5 id="3-2-3-1-4种引用类型"><a href="#3-2-3-1-4种引用类型" class="headerlink" title="3.2.3.1    4种引用类型"></a>3.2.3.1    4种引用类型</h5><ul><li><h4 id="x3D-x3D-强引用-x3D-x3D-是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object-obj-x3D-new-Object（）”这种引用关系，-x3D-x3D-只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象-x3D-x3D-。"><a href="#x3D-x3D-强引用-x3D-x3D-是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object-obj-x3D-new-Object（）”这种引用关系，-x3D-x3D-只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;强引用&#x3D;&#x3D;是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object obj &#x3D; new Object（）”这种引用关系，&#x3D;&#x3D;只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象&#x3D;&#x3D;。"></a>&#x3D;&#x3D;强引用&#x3D;&#x3D;是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object obj &#x3D; new Object（）”这种引用关系，&#x3D;&#x3D;只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象&#x3D;&#x3D;。</h4></li><li><h4 id="软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内-存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，-才会抛出内存溢出异常。在JDK-1-2版之后提供了SoftReference类来实现软引用。"><a href="#软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内-存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，-才会抛出内存溢出异常。在JDK-1-2版之后提供了SoftReference类来实现软引用。" class="headerlink" title="软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。"></a>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</h4></li><li><h4 id="弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只-能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只-被弱引用关联的对象。在JDK-1-2版之后提供了WeakReference类来实现弱引用。"><a href="#弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只-能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只-被弱引用关联的对象。在JDK-1-2版之后提供了WeakReference类来实现弱引用。" class="headerlink" title="弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。"></a>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</h4></li><li><h4 id="虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的-存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚-引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK-1-2版之后提供-了PhantomReference类来实现虚引用。"><a href="#虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的-存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚-引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK-1-2版之后提供-了PhantomReference类来实现虚引用。" class="headerlink" title="虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。"></a>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。</h4></li></ul><h4 id="3-2-4-生存还是死亡？"><a href="#3-2-4-生存还是死亡？" class="headerlink" title="3.2.4    生存还是死亡？"></a>3.2.4    生存还是死亡？</h4><ul><li><h4 id="即使在-x3D-x3D-可达性分析算法中判定为不可达的对象-x3D-x3D-，也不是“非死不可”的，这时候它们暂时还处于“缓-刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没-有与GC-Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是-否有必要执行finalize-方法。假如对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用-过，那么虚拟机将这两种情况都视为“没有必要执行”。"><a href="#即使在-x3D-x3D-可达性分析算法中判定为不可达的对象-x3D-x3D-，也不是“非死不可”的，这时候它们暂时还处于“缓-刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没-有与GC-Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是-否有必要执行finalize-方法。假如对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用-过，那么虚拟机将这两种情况都视为“没有必要执行”。" class="headerlink" title="即使在&#x3D;&#x3D;可达性分析算法中判定为不可达的对象&#x3D;&#x3D;，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。"></a>即使在&#x3D;&#x3D;可达性分析算法中判定为不可达的对象&#x3D;&#x3D;，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</h4></li><li><h4 id="如果这个对象被判定为确有必要执行finalize-方法，那么该对象将会被放置在一个名为F-Queue的-队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize-方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。-这样做的原因是，如果某个对象的finalize-方法执行缓慢，或者更极端地发生了死循环，将很可能导-致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。-x3D-x3D-finalize-方法是对-象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对-象要在finalize-中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己-（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合-x3D-x3D-；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个-对象的finalize-被执行，但是它仍然可以存活"><a href="#如果这个对象被判定为确有必要执行finalize-方法，那么该对象将会被放置在一个名为F-Queue的-队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize-方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。-这样做的原因是，如果某个对象的finalize-方法执行缓慢，或者更极端地发生了死循环，将很可能导-致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。-x3D-x3D-finalize-方法是对-象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对-象要在finalize-中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己-（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合-x3D-x3D-；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个-对象的finalize-被执行，但是它仍然可以存活" class="headerlink" title="如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。&#x3D;&#x3D;finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合&#x3D;&#x3D;；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个 对象的finalize()被执行，但是它仍然可以存活"></a>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。&#x3D;&#x3D;finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合&#x3D;&#x3D;；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个 对象的finalize()被执行，但是它仍然可以存活</h4></li></ul><h4 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5  回收方法区"></a>3.2.5  回收方法区</h4><ul><li><h4 id="有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚-拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整-实现方法区类型卸载的收集器存在（如JDK-11时期的ZGC收集器就不支持类卸载），方法区垃圾收集-的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常-可以回收70-至99-的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回-收成果往往远低于此。"><a href="#有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚-拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整-实现方法区类型卸载的收集器存在（如JDK-11时期的ZGC收集器就不支持类卸载），方法区垃圾收集-的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常-可以回收70-至99-的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回-收成果往往远低于此。" class="headerlink" title="有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。"></a>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。</h4></li><li><h4 id="x3D-x3D-方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型-x3D-x3D-。回收废弃常量与回收-Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池-中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用-常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且-垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接-口）、方法、字段的符号引用也与此类似。"><a href="#x3D-x3D-方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型-x3D-x3D-。回收废弃常量与回收-Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池-中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用-常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且-垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接-口）、方法、字段的符号引用也与此类似。" class="headerlink" title="&#x3D;&#x3D;方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型&#x3D;&#x3D;。回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接 口）、方法、字段的符号引用也与此类似。"></a>&#x3D;&#x3D;方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型&#x3D;&#x3D;。回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接 口）、方法、字段的符号引用也与此类似。</h4></li><li><h4 id="定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就-比较苛刻了。需要-x3D-x3D-同时满足-x3D-x3D-下面三个条件："><a href="#定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就-比较苛刻了。需要-x3D-x3D-同时满足-x3D-x3D-下面三个条件：" class="headerlink" title="定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要&#x3D;&#x3D;同时满足&#x3D;&#x3D;下面三个条件："></a>定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要&#x3D;&#x3D;同时满足&#x3D;&#x3D;下面三个条件：</h4></li></ul><ol><li><h4 id="·-x3D-x3D-该类所有的实例都已经被回收-x3D-x3D-，也就是Java堆中不存在该类及其任何派生子类的实例。"><a href="#·-x3D-x3D-该类所有的实例都已经被回收-x3D-x3D-，也就是Java堆中不存在该类及其任何派生子类的实例。" class="headerlink" title="·&#x3D;&#x3D;该类所有的实例都已经被回收&#x3D;&#x3D;，也就是Java堆中不存在该类及其任何派生子类的实例。"></a>·&#x3D;&#x3D;该类所有的实例都已经被回收&#x3D;&#x3D;，也就是Java堆中不存在该类及其任何派生子类的实例。</h4></li><li><h4 id="·-x3D-x3D-加载该类的类加载器已经被回收-x3D-x3D-，这个条件除非是经过精心设计的可替换类加载器的场景，如-OSGi、JSP的重加载等，否则通常是很难达成的。"><a href="#·-x3D-x3D-加载该类的类加载器已经被回收-x3D-x3D-，这个条件除非是经过精心设计的可替换类加载器的场景，如-OSGi、JSP的重加载等，否则通常是很难达成的。" class="headerlink" title="·&#x3D;&#x3D;加载该类的类加载器已经被回收&#x3D;&#x3D;，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。"></a>·&#x3D;&#x3D;加载该类的类加载器已经被回收&#x3D;&#x3D;，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。</h4></li><li><h4 id="·-x3D-x3D-该类对应的java-lang-Class对象没有在任何地方被引用-x3D-x3D-，无法在任何地方通过反射访问该类的方-法。"><a href="#·-x3D-x3D-该类对应的java-lang-Class对象没有在任何地方被引用-x3D-x3D-，无法在任何地方通过反射访问该类的方-法。" class="headerlink" title="·&#x3D;&#x3D;该类对应的java.lang.Class对象没有在任何地方被引用&#x3D;&#x3D;，无法在任何地方通过反射访问该类的方 法。"></a>·&#x3D;&#x3D;该类对应的java.lang.Class对象没有在任何地方被引用&#x3D;&#x3D;，无法在任何地方通过反射访问该类的方 法。</h4></li></ol><ul><li><h4 id="x3D-x3D-在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载-器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压-力。-x3D-x3D"><a href="#x3D-x3D-在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载-器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压-力。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。&#x3D;&#x3D;"></a>&#x3D;&#x3D;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。&#x3D;&#x3D;</h4></li></ul><h3 id="3-3-垃圾回收算法"><a href="#3-3-垃圾回收算法" class="headerlink" title="3.3  垃圾回收算法"></a>3.3  垃圾回收算法</h3><ul><li><h4 id="从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference-Counting-GC）和“追踪式垃圾收集”（Tracing-GC）两大类，这两类也常被称作“直接垃圾收集”和“间接-垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不-把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。"><a href="#从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference-Counting-GC）和“追踪式垃圾收集”（Tracing-GC）两大类，这两类也常被称作“直接垃圾收集”和“间接-垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不-把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。" class="headerlink" title="从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。"></a>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。</h4></li></ul><h4 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1   分代收集理论"></a>3.3.1   分代收集理论</h4><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进 行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分 代假说之上：</p><ol><li><h4 id="弱分代假说-week-generation-hypothesis-绝大多数对象都是朝生夕灭的"><a href="#弱分代假说-week-generation-hypothesis-绝大多数对象都是朝生夕灭的" class="headerlink" title="弱分代假说(week generation hypothesis): 绝大多数对象都是朝生夕灭的"></a>弱分代假说(week generation hypothesis): 绝大多数对象都是朝生夕灭的</h4></li><li><h4 id="强分代假说-Strong-generation-hypothesis-熬过越多次垃圾收集过程的对象就越难以消亡。"><a href="#强分代假说-Strong-generation-hypothesis-熬过越多次垃圾收集过程的对象就越难以消亡。" class="headerlink" title="强分代假说(Strong generation hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。"></a>强分代假说(Strong generation hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。</h4></li></ol><ul><li><h4 id="这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：-x3D-x3D-收集器应该将Java堆划分-出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区-域之中存储。-x3D-x3D-显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那-么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对-象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，-虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有-效利用。"><a href="#这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：-x3D-x3D-收集器应该将Java堆划分-出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区-域之中存储。-x3D-x3D-显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那-么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对-象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，-虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有-效利用。" class="headerlink" title="这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：&#x3D;&#x3D;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。&#x3D;&#x3D;显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。"></a>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：&#x3D;&#x3D;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。&#x3D;&#x3D;显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。</h4></li><li><h4 id="在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域-——因而才有了“Minor-GC”“Major-GC”“Full-GC”这样的回收类型的划分；也才能够针对不同的区域安-排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算-法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的-重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。"><a href="#在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域-——因而才有了“Minor-GC”“Major-GC”“Full-GC”这样的回收类型的划分；也才能够针对不同的区域安-排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算-法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的-重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。" class="headerlink" title="在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的 重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。"></a>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的 重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。</h4></li><li><h4 id="3）跨代引用假说（Intergenerational-Reference-Hypothesis）：跨代引用相对于同代引用来说仅占极-少数。"><a href="#3）跨代引用假说（Intergenerational-Reference-Hypothesis）：跨代引用相对于同代引用来说仅占极-少数。" class="headerlink" title="3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。"></a>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。</h4></li></ul><p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p><ol><li><h4 id="·部分收集（Partial-GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为："><a href="#·部分收集（Partial-GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：" class="headerlink" title="·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为："></a>·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</h4></li></ol><ul><li><h4 id="■新生代收集（Minor-GC-x2F-Young-GC）：指目标只是新生代的垃圾收集"><a href="#■新生代收集（Minor-GC-x2F-Young-GC）：指目标只是新生代的垃圾收集" class="headerlink" title="■新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集"></a>■新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</h4></li><li><h4 id="■老年代收集（Major-GC-x2F-Old-GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单-独收集老年代的行为。另外请注意“Major-GC”这个说法现在有点混淆，在不同资料上常有不同所指，-读者需按上下文区分到底是指老年代的收集还是整堆收集。"><a href="#■老年代收集（Major-GC-x2F-Old-GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单-独收集老年代的行为。另外请注意“Major-GC”这个说法现在有点混淆，在不同资料上常有不同所指，-读者需按上下文区分到底是指老年代的收集还是整堆收集。" class="headerlink" title="■老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。"></a>■老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。</h4></li><li><h4 id="■混合收集（Mixed-GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收-集器会有这种行为。"><a href="#■混合收集（Mixed-GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收-集器会有这种行为。" class="headerlink" title="■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。"></a>■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</h4></li><li><h4 id="·整堆收集（Full-GC）：收集整个Java堆和方法区的垃圾收集。"><a href="#·整堆收集（Full-GC）：收集整个Java堆和方法区的垃圾收集。" class="headerlink" title="·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。"></a>·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深入理解JAVA虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL面试</title>
      <link href="/2022/10/14/MySQL%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/10/14/MySQL%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h3><h3 id="1-数据库的三范式"><a href="#1-数据库的三范式" class="headerlink" title="1.数据库的三范式"></a>1.数据库的三范式</h3><ol><li><h4 id="列不可再分"><a href="#列不可再分" class="headerlink" title="列不可再分"></a>列不可再分</h4></li><li><h4 id="行可以唯一区分，主键约束"><a href="#行可以唯一区分，主键约束" class="headerlink" title="行可以唯一区分，主键约束"></a>行可以唯一区分，主键约束</h4></li><li><h4 id="表的非主属性不能依赖于其他表的非主属性，外键约束，且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一第二范式上。"><a href="#表的非主属性不能依赖于其他表的非主属性，外键约束，且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一第二范式上。" class="headerlink" title="表的非主属性不能依赖于其他表的非主属性，外键约束，且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一第二范式上。"></a>表的非主属性不能依赖于其他表的非主属性，外键约束，且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一第二范式上。</h4></li></ol><h2 id="2-MySQL的存储引擎"><a href="#2-MySQL的存储引擎" class="headerlink" title="2.MySQL的存储引擎"></a>2.MySQL的存储引擎</h2><ol><li><h4 id="常用的包括：MyISAM-InnoDB，Memory-MERGE"><a href="#常用的包括：MyISAM-InnoDB，Memory-MERGE" class="headerlink" title="常用的包括：MyISAM,InnoDB，Memory,MERGE."></a>常用的包括：MyISAM,InnoDB，Memory,MERGE.</h4></li></ol><ul><li><h4 id="MyISAM：提供全表锁，有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求。以select，insert-为主的应用可以使用此引擎，老版本的默认存储引擎。"><a href="#MyISAM：提供全表锁，有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求。以select，insert-为主的应用可以使用此引擎，老版本的默认存储引擎。" class="headerlink" title="MyISAM：提供全表锁，有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求。以select，insert 为主的应用可以使用此引擎，老版本的默认存储引擎。"></a>MyISAM：提供全表锁，有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对较小，对事务完整性没有要求。以select，insert 为主的应用可以使用此引擎，老版本的默认存储引擎。</h4></li><li><h4 id="InnoDB：行级锁，提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，支持外键约束，并发能力去，占用空间是MyISAM的数倍，处理效率会差点，是现在MySQL的默认存储引擎。"><a href="#InnoDB：行级锁，提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，支持外键约束，并发能力去，占用空间是MyISAM的数倍，处理效率会差点，是现在MySQL的默认存储引擎。" class="headerlink" title="InnoDB：行级锁，提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，支持外键约束，并发能力去，占用空间是MyISAM的数倍，处理效率会差点，是现在MySQL的默认存储引擎。"></a>InnoDB：行级锁，提供了具有提交，回滚和崩溃恢复能力的事务安全，支持自动增长列，支持外键约束，并发能力去，占用空间是MyISAM的数倍，处理效率会差点，是现在MySQL的默认存储引擎。</h4></li></ul><h2 id="3-数据库的事务"><a href="#3-数据库的事务" class="headerlink" title="3. 数据库的事务"></a>3. 数据库的事务</h2><ul><li><h4 id="什么是事务？：多条SQL语句，要么全部成功，要么全部失败。"><a href="#什么是事务？：多条SQL语句，要么全部成功，要么全部失败。" class="headerlink" title="什么是事务？：多条SQL语句，要么全部成功，要么全部失败。"></a>什么是事务？：多条SQL语句，要么全部成功，要么全部失败。</h4></li><li><h4 id="事务的特性：原子性-Atomic-，一致性-Consistency-，隔离性（isolation），持久性（durability）。简称ACID。"><a href="#事务的特性：原子性-Atomic-，一致性-Consistency-，隔离性（isolation），持久性（durability）。简称ACID。" class="headerlink" title="事务的特性：原子性(Atomic)，一致性(Consistency)，隔离性（isolation），持久性（durability）。简称ACID。"></a>事务的特性：原子性(Atomic)，一致性(Consistency)，隔离性（isolation），持久性（durability）。简称ACID。</h4></li></ul><ol><li><h4 id="原子性是指：组成一个事务的多个数据库操作时一个不可在分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已执行的任何操作都要回滚"><a href="#原子性是指：组成一个事务的多个数据库操作时一个不可在分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已执行的任何操作都要回滚" class="headerlink" title="原子性是指：组成一个事务的多个数据库操作时一个不可在分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已执行的任何操作都要回滚"></a>原子性是指：组成一个事务的多个数据库操作时一个不可在分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已执行的任何操作都要回滚</h4></li><li><h4 id="一致性：事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏，如A转账100给B，不管操作是否成功，A和B的账户总额不变"><a href="#一致性：事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏，如A转账100给B，不管操作是否成功，A和B的账户总额不变" class="headerlink" title="一致性：事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏，如A转账100给B，不管操作是否成功，A和B的账户总额不变"></a>一致性：事务操作成功后，数据库所处的状态和他的业务规则是一致的，即数据不会被破坏，如A转账100给B，不管操作是否成功，A和B的账户总额不变</h4></li><li><h4 id="隔离性：在并发数据操作下，不同的事务拥有各自的数据空间，他们的操作不会对彼此产生干扰"><a href="#隔离性：在并发数据操作下，不同的事务拥有各自的数据空间，他们的操作不会对彼此产生干扰" class="headerlink" title="隔离性：在并发数据操作下，不同的事务拥有各自的数据空间，他们的操作不会对彼此产生干扰"></a>隔离性：在并发数据操作下，不同的事务拥有各自的数据空间，他们的操作不会对彼此产生干扰</h4></li><li><h4 id="持久性：一旦事务提交成功，事务中的所有操作都将持久化到数据库中。"><a href="#持久性：一旦事务提交成功，事务中的所有操作都将持久化到数据库中。" class="headerlink" title="持久性：一旦事务提交成功，事务中的所有操作都将持久化到数据库中。"></a>持久性：一旦事务提交成功，事务中的所有操作都将持久化到数据库中。</h4></li></ol><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4.索引"></a>4.索引</h2><ul><li><h4 id="常有的索引：-聚簇索引，联合索引，自适应哈希索引，唯一索引，前缀索引。是InnoDB-存储引擎所提供，数据结构是B-树。"><a href="#常有的索引：-聚簇索引，联合索引，自适应哈希索引，唯一索引，前缀索引。是InnoDB-存储引擎所提供，数据结构是B-树。" class="headerlink" title="常有的索引： 聚簇索引，联合索引，自适应哈希索引，唯一索引，前缀索引。是InnoDB 存储引擎所提供，数据结构是B+树。"></a>常有的索引： 聚簇索引，联合索引，自适应哈希索引，唯一索引，前缀索引。是InnoDB 存储引擎所提供，数据结构是B+树。</h4></li></ul><h2 id="5-SQL优化的手段"><a href="#5-SQL优化的手段" class="headerlink" title="5.SQL优化的手段"></a>5.SQL优化的手段</h2><ol><li><h4 id="查询语句中尽量避免使用-select-大字段时查询很耗时"><a href="#查询语句中尽量避免使用-select-大字段时查询很耗时" class="headerlink" title="查询语句中尽量避免使用 select *(大字段时查询很耗时)"></a>查询语句中尽量避免使用 select *(大字段时查询很耗时)</h4></li><li><h4 id="尽量减少子查询，使用关联查询代替-left-join-right-join-inner-join"><a href="#尽量减少子查询，使用关联查询代替-left-join-right-join-inner-join" class="headerlink" title="尽量减少子查询，使用关联查询代替(left join,right join, inner join)"></a>尽量减少子查询，使用关联查询代替(left join,right join, inner join)</h4></li><li><h4 id="减少使用-in-或者-not-in，使用exists-not-exists-或者关联查询代替"><a href="#减少使用-in-或者-not-in，使用exists-not-exists-或者关联查询代替" class="headerlink" title="减少使用 in 或者 not in，使用exists, not exists 或者关联查询代替"></a>减少使用 in 或者 not in，使用exists, not exists 或者关联查询代替</h4></li><li><h4 id="or的查询尽量使用union或-union-all代替（在确认没有重复数据或者不用剔除重复数据时，union-all-会更好）"><a href="#or的查询尽量使用union或-union-all代替（在确认没有重复数据或者不用剔除重复数据时，union-all-会更好）" class="headerlink" title="or的查询尽量使用union或 union all代替（在确认没有重复数据或者不用剔除重复数据时，union all 会更好）"></a>or的查询尽量使用union或 union all代替（在确认没有重复数据或者不用剔除重复数据时，union all 会更好）</h4></li><li><h4 id="尽量避免在where-子句中使用-！-x3D-操作符，否则引擎将放弃索引而使用全表扫描"><a href="#尽量避免在where-子句中使用-！-x3D-操作符，否则引擎将放弃索引而使用全表扫描" class="headerlink" title="尽量避免在where 子句中使用 ！&#x3D;操作符，否则引擎将放弃索引而使用全表扫描"></a>尽量避免在where 子句中使用 ！&#x3D;操作符，否则引擎将放弃索引而使用全表扫描</h4></li><li><h4 id="应尽量避免在where-子句中-对字段进行null-值判断，否则将导致存储引擎放弃使用索引而进行全表扫描，如-select-id-from-t-where-num-is-null-可以在null-上设置默认值0，确保表中num列没有null值，然后这样查询：select-id-from-t-where-num-x3D-0。"><a href="#应尽量避免在where-子句中-对字段进行null-值判断，否则将导致存储引擎放弃使用索引而进行全表扫描，如-select-id-from-t-where-num-is-null-可以在null-上设置默认值0，确保表中num列没有null值，然后这样查询：select-id-from-t-where-num-x3D-0。" class="headerlink" title="应尽量避免在where 子句中 对字段进行null 值判断，否则将导致存储引擎放弃使用索引而进行全表扫描，如: select id from t where num is null 可以在null 上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num &#x3D;0。"></a>应尽量避免在where 子句中 对字段进行null 值判断，否则将导致存储引擎放弃使用索引而进行全表扫描，如: select id from t where num is null 可以在null 上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num &#x3D;0。</h4></li></ol><h2 id="6-drop-delete-truncate的区别"><a href="#6-drop-delete-truncate的区别" class="headerlink" title="6.drop ,delete, truncate的区别"></a>6.drop ,delete, truncate的区别</h2><ul><li><h4 id="三者都是表示删除，而delete和-truncate-只删除表的数据而不删除表的结构，速度：-drop-gt-truncate-gt-delete-语句是dml，这个操作会放到rollback-segment，事务提交之后才会生效，如果有相应的trigger，执行时将会触发。truncate，drop是ddl，操作立即执行，原数据放不到rollback-segment中，不能回滚，操作不触发trigger。"><a href="#三者都是表示删除，而delete和-truncate-只删除表的数据而不删除表的结构，速度：-drop-gt-truncate-gt-delete-语句是dml，这个操作会放到rollback-segment，事务提交之后才会生效，如果有相应的trigger，执行时将会触发。truncate，drop是ddl，操作立即执行，原数据放不到rollback-segment中，不能回滚，操作不触发trigger。" class="headerlink" title="三者都是表示删除，而delete和 truncate 只删除表的数据而不删除表的结构，速度： drop&gt;truncate&gt;delete,语句是dml，这个操作会放到rollback segment，事务提交之后才会生效，如果有相应的trigger，执行时将会触发。truncate，drop是ddl，操作立即执行，原数据放不到rollback segment中，不能回滚，操作不触发trigger。"></a>三者都是表示删除，而delete和 truncate 只删除表的数据而不删除表的结构，速度： drop&gt;truncate&gt;delete,语句是dml，这个操作会放到rollback segment，事务提交之后才会生效，如果有相应的trigger，执行时将会触发。truncate，drop是ddl，操作立即执行，原数据放不到rollback segment中，不能回滚，操作不触发trigger。</h4></li></ul><h2 id="7-什么是视图？"><a href="#7-什么是视图？" class="headerlink" title="7.什么是视图？"></a>7.什么是视图？</h2><ul><li><h4 id="视图一种虚拟的表，具有和物理表的功能，可以对试图进行增删改查操作，视图通常是一个表或者多个表的列或者列的子集，对视图的修改不影响原来的表，视图可以让我们获取数据更容易，相比多表查询。"><a href="#视图一种虚拟的表，具有和物理表的功能，可以对试图进行增删改查操作，视图通常是一个表或者多个表的列或者列的子集，对视图的修改不影响原来的表，视图可以让我们获取数据更容易，相比多表查询。" class="headerlink" title="视图一种虚拟的表，具有和物理表的功能，可以对试图进行增删改查操作，视图通常是一个表或者多个表的列或者列的子集，对视图的修改不影响原来的表，视图可以让我们获取数据更容易，相比多表查询。"></a>视图一种虚拟的表，具有和物理表的功能，可以对试图进行增删改查操作，视图通常是一个表或者多个表的列或者列的子集，对视图的修改不影响原来的表，视图可以让我们获取数据更容易，相比多表查询。</h4></li></ul><h2 id="8-什么是内连接，左外连接，右外连接"><a href="#8-什么是内连接，左外连接，右外连接" class="headerlink" title="8.什么是内连接，左外连接，右外连接?"></a>8.什么是内连接，左外连接，右外连接?</h2><ol><li><h4 id="内连接：-inner-join，匹配两张表相关联的记录"><a href="#内连接：-inner-join，匹配两张表相关联的记录" class="headerlink" title="内连接： inner join，匹配两张表相关联的记录"></a>内连接： inner join，匹配两张表相关联的记录</h4></li><li><h4 id="左外连接：left-outer-join，out-可省略，除了匹配两张表相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示"><a href="#左外连接：left-outer-join，out-可省略，除了匹配两张表相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示" class="headerlink" title="左外连接：left outer  join，out 可省略，除了匹配两张表相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示"></a>左外连接：left outer  join，out 可省略，除了匹配两张表相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示</h4></li><li><h4 id="右外连接：right-outer-join，out-可省略，除了匹配两张表相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。"><a href="#右外连接：right-outer-join，out-可省略，除了匹配两张表相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。" class="headerlink" title="右外连接：right outer join，out 可省略，除了匹配两张表相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。"></a>右外连接：right outer join，out 可省略，除了匹配两张表相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。</h4></li></ol><ul><li><h4 id="判断左表还是右表，要根据表名出现在outer-join-的左右位置关系"><a href="#判断左表还是右表，要根据表名出现在outer-join-的左右位置关系" class="headerlink" title="判断左表还是右表，要根据表名出现在outer join 的左右位置关系"></a>判断左表还是右表，要根据表名出现在outer join 的左右位置关系</h4></li></ul><h2 id="9-并发事务会带来那些问题？"><a href="#9-并发事务会带来那些问题？" class="headerlink" title="9.并发事务会带来那些问题？"></a>9.并发事务会带来那些问题？</h2><p>在多个事务并发运行时，多个用户对同一数据进行操作。可能会导致以下的问题：</p><ol><li><h4 id="x3D-x3D-脏读-dirty-read-x3D-x3D-：当一个事务正在访问数据并且对数据进行了修改，而且这种修改还没有-commit，这时候另一个事务也访问了这个数据，然后使用这个数据，因为这个数据还没有commit，那么另一个事务-读取到的这个数据是脏数据-也就是还没有更新的数据）"><a href="#x3D-x3D-脏读-dirty-read-x3D-x3D-：当一个事务正在访问数据并且对数据进行了修改，而且这种修改还没有-commit，这时候另一个事务也访问了这个数据，然后使用这个数据，因为这个数据还没有commit，那么另一个事务-读取到的这个数据是脏数据-也就是还没有更新的数据）" class="headerlink" title="&#x3D;&#x3D;脏读(dirty read)&#x3D;&#x3D;：当一个事务正在访问数据并且对数据进行了修改，而且这种修改还没有 commit，这时候另一个事务也访问了这个数据，然后使用这个数据，因为这个数据还没有commit，那么另一个事务 读取到的这个数据是脏数据(也就是还没有更新的数据）"></a>&#x3D;&#x3D;脏读(dirty read)&#x3D;&#x3D;：当一个事务正在访问数据并且对数据进行了修改，而且这种修改还没有 commit，这时候另一个事务也访问了这个数据，然后使用这个数据，因为这个数据还没有commit，那么另一个事务 读取到的这个数据是脏数据(也就是还没有更新的数据）</h4></li><li><h4 id="x3D-x3D-丢失修改-x3D-x3D-：指在一个事务读取一个数据时，另一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了这个数据，那么第一个事务所修改的数据就会丢失，因此称为丢失修改，如：事务A读取到数据num-x3D-100，事务B读取到-num-x3D-100，而A将num改为200，B将num改为300，事务A的修改会丢失"><a href="#x3D-x3D-丢失修改-x3D-x3D-：指在一个事务读取一个数据时，另一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了这个数据，那么第一个事务所修改的数据就会丢失，因此称为丢失修改，如：事务A读取到数据num-x3D-100，事务B读取到-num-x3D-100，而A将num改为200，B将num改为300，事务A的修改会丢失" class="headerlink" title="&#x3D;&#x3D;丢失修改&#x3D;&#x3D;：指在一个事务读取一个数据时，另一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了这个数据，那么第一个事务所修改的数据就会丢失，因此称为丢失修改，如：事务A读取到数据num&#x3D;100，事务B读取到 num&#x3D;100，而A将num改为200，B将num改为300，事务A的修改会丢失"></a>&#x3D;&#x3D;丢失修改&#x3D;&#x3D;：指在一个事务读取一个数据时，另一个事务也访问了该数据，那么第一个事务中修改了这个数据后，第二个事务也修改了这个数据，那么第一个事务所修改的数据就会丢失，因此称为丢失修改，如：事务A读取到数据num&#x3D;100，事务B读取到 num&#x3D;100，而A将num改为200，B将num改为300，事务A的修改会丢失</h4></li><li><h4 id="x3D-x3D-不可重复读（Unrepeatableread）-x3D-x3D-：指在一个事务内多次读取童一个数据，在这个事务还没有完结时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了一个事务内两次读取到的数据不一样的情况，因此称为不可重复读"><a href="#x3D-x3D-不可重复读（Unrepeatableread）-x3D-x3D-：指在一个事务内多次读取童一个数据，在这个事务还没有完结时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了一个事务内两次读取到的数据不一样的情况，因此称为不可重复读" class="headerlink" title="&#x3D;&#x3D;不可重复读（Unrepeatableread）&#x3D;&#x3D;：指在一个事务内多次读取童一个数据，在这个事务还没有完结时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了一个事务内两次读取到的数据不一样的情况，因此称为不可重复读"></a>&#x3D;&#x3D;不可重复读（Unrepeatableread）&#x3D;&#x3D;：指在一个事务内多次读取童一个数据，在这个事务还没有完结时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样，这就发生了一个事务内两次读取到的数据不一样的情况，因此称为不可重复读</h4></li><li><h4 id="x3D-x3D-幻读-Phantom-read-x3D-x3D-幻读与不可重复读-类似，他发生在一个事务A读取了几行数据，接着另一个事务B插入了一些数据，在随后的查询中，第一个事务就会发现原本不存在的记录，就像幻觉一样，所以称为幻读。"><a href="#x3D-x3D-幻读-Phantom-read-x3D-x3D-幻读与不可重复读-类似，他发生在一个事务A读取了几行数据，接着另一个事务B插入了一些数据，在随后的查询中，第一个事务就会发现原本不存在的记录，就像幻觉一样，所以称为幻读。" class="headerlink" title="&#x3D;&#x3D;幻读(Phantom read)&#x3D;&#x3D;: 幻读与不可重复读 类似，他发生在一个事务A读取了几行数据，接着另一个事务B插入了一些数据，在随后的查询中，第一个事务就会发现原本不存在的记录，就像幻觉一样，所以称为幻读。"></a>&#x3D;&#x3D;幻读(Phantom read)&#x3D;&#x3D;: 幻读与不可重复读 类似，他发生在一个事务A读取了几行数据，接着另一个事务B插入了一些数据，在随后的查询中，第一个事务就会发现原本不存在的记录，就像幻觉一样，所以称为幻读。</h4></li></ol><ul><li><h4 id="幻读和不可重复读的区别：不可重复读的重点是修改，-x3D-x3D-比如多次读取一条记录发现其中某些列被修改-x3D-x3D-，幻读的重点在于新增或者删除，-x3D-x3D-比如读取一条记录发现记录增多或者减少了。-x3D-x3D"><a href="#幻读和不可重复读的区别：不可重复读的重点是修改，-x3D-x3D-比如多次读取一条记录发现其中某些列被修改-x3D-x3D-，幻读的重点在于新增或者删除，-x3D-x3D-比如读取一条记录发现记录增多或者减少了。-x3D-x3D" class="headerlink" title="幻读和不可重复读的区别：不可重复读的重点是修改，&#x3D;&#x3D;比如多次读取一条记录发现其中某些列被修改&#x3D;&#x3D;，幻读的重点在于新增或者删除，&#x3D;&#x3D;比如读取一条记录发现记录增多或者减少了。&#x3D;&#x3D;"></a>幻读和不可重复读的区别：不可重复读的重点是修改，&#x3D;&#x3D;比如多次读取一条记录发现其中某些列被修改&#x3D;&#x3D;，幻读的重点在于新增或者删除，&#x3D;&#x3D;比如读取一条记录发现记录增多或者减少了。&#x3D;&#x3D;</h4></li></ul><h2 id="10-事务隔离级别有哪些？MySQL的默认事务隔离级别是？"><a href="#10-事务隔离级别有哪些？MySQL的默认事务隔离级别是？" class="headerlink" title="10. 事务隔离级别有哪些？MySQL的默认事务隔离级别是？"></a>10. 事务隔离级别有哪些？MySQL的默认事务隔离级别是？</h2><ul><li><h4 id="SQL标准定义了四个隔离级别："><a href="#SQL标准定义了四个隔离级别：" class="headerlink" title="SQL标准定义了四个隔离级别："></a>SQL标准定义了四个隔离级别：</h4><ol><li><h4 id="READ-UNCOMMITED-读取未提交-最低的隔离级别，允许读取尚未提交的数据变更，-x3D-x3D-可能会导致脏读，幻读或不可重复读-x3D-x3D"><a href="#READ-UNCOMMITED-读取未提交-最低的隔离级别，允许读取尚未提交的数据变更，-x3D-x3D-可能会导致脏读，幻读或不可重复读-x3D-x3D" class="headerlink" title="READ-UNCOMMITED(读取未提交):最低的隔离级别，允许读取尚未提交的数据变更，&#x3D;&#x3D;可能会导致脏读，幻读或不可重复读&#x3D;&#x3D;"></a>READ-UNCOMMITED(读取未提交):最低的隔离级别，允许读取尚未提交的数据变更，&#x3D;&#x3D;可能会导致脏读，幻读或不可重复读&#x3D;&#x3D;</h4></li><li><h4 id="READ-COMMITTED-读取已提交-：允许读取并发事务已经提交的数据，-x3D-x3D-可以阻止-脏读，但是幻读和不可重复读仍有可能发生-x3D-x3D"><a href="#READ-COMMITTED-读取已提交-：允许读取并发事务已经提交的数据，-x3D-x3D-可以阻止-脏读，但是幻读和不可重复读仍有可能发生-x3D-x3D" class="headerlink" title="READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，&#x3D;&#x3D;可以阻止 脏读，但是幻读和不可重复读仍有可能发生&#x3D;&#x3D;"></a>READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，&#x3D;&#x3D;可以阻止 脏读，但是幻读和不可重复读仍有可能发生&#x3D;&#x3D;</h4></li><li><h4 id="READ-REPAETABLE-可重复读-对同一字段的多次读取结果都是一致的，除非数据是被本身的事务自己修改，-x3D-x3D-可以阻止脏读和不可重复读，但幻读仍可能发生-x3D-x3D"><a href="#READ-REPAETABLE-可重复读-对同一字段的多次读取结果都是一致的，除非数据是被本身的事务自己修改，-x3D-x3D-可以阻止脏读和不可重复读，但幻读仍可能发生-x3D-x3D" class="headerlink" title="READ-REPAETABLE(可重复读):对同一字段的多次读取结果都是一致的，除非数据是被本身的事务自己修改，&#x3D;&#x3D;可以阻止脏读和不可重复读，但幻读仍可能发生&#x3D;&#x3D;"></a>READ-REPAETABLE(可重复读):对同一字段的多次读取结果都是一致的，除非数据是被本身的事务自己修改，&#x3D;&#x3D;可以阻止脏读和不可重复读，但幻读仍可能发生&#x3D;&#x3D;</h4></li><li><h4 id="SERIALIZABLE-可串行化-最高的隔离级别，完全服从ACID的事务隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该-x3D-x3D-级别可以阻止-脏读，不可重复读，幻读-x3D-x3D-。"><a href="#SERIALIZABLE-可串行化-最高的隔离级别，完全服从ACID的事务隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该-x3D-x3D-级别可以阻止-脏读，不可重复读，幻读-x3D-x3D-。" class="headerlink" title="SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的事务隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该&#x3D;&#x3D;级别可以阻止 脏读，不可重复读，幻读&#x3D;&#x3D;。"></a>SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的事务隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该&#x3D;&#x3D;级别可以阻止 脏读，不可重复读，幻读&#x3D;&#x3D;。</h4></li></ol></li><li><h4 id="MySQl-InnoDB存储引擎的默认支持的事务隔离级别是-READ-REPEATABLE-即-可重复读"><a href="#MySQl-InnoDB存储引擎的默认支持的事务隔离级别是-READ-REPEATABLE-即-可重复读" class="headerlink" title="MySQl InnoDB存储引擎的默认支持的事务隔离级别是 READ-REPEATABLE 即 可重复读"></a>MySQl InnoDB存储引擎的默认支持的事务隔离级别是 READ-REPEATABLE 即 可重复读</h4></li><li><h4 id="在分布式事务的情况下，一般会使用SERIALIZABLE隔离级别。"><a href="#在分布式事务的情况下，一般会使用SERIALIZABLE隔离级别。" class="headerlink" title="在分布式事务的情况下，一般会使用SERIALIZABLE隔离级别。"></a>在分布式事务的情况下，一般会使用SERIALIZABLE隔离级别。</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-MySql</title>
      <link href="/2022/10/14/leetcode-MySql/"/>
      <url>/2022/10/14/leetcode-MySql/</url>
      
        <content type="html"><![CDATA[<h4 id="511-游戏玩法分析-I"><a href="#511-游戏玩法分析-I" class="headerlink" title="511. 游戏玩法分析 I"></a><a href="https://leetcode.cn/problems/game-play-analysis-i/">511. 游戏玩法分析 I</a></h4><p>难度简单76收藏分享切换为英文接收动态反馈</p><p>SQL架构</p><p>活动表 <code>Activity</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+--------------+---------+<br>| Column Name  | Type    |<br>+--------------+---------+<br>| player_id    | int     |<br>| device_id    | int     |<br>| event_date   | date    |<br>| games_played | int     |<br>+--------------+---------+<br>表的主键是 (player_id, event_date)。<br>这张表展示了一些游戏玩家在游戏平台上的行为活动。<br>每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。<br></code></pre></td></tr></table></figure><p>写一条 SQL 查询语句获取每位玩家 <strong>第一次登陆平台的日期</strong>。</p><p>查询结果的格式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Activity 表：<br>+-----------+-----------+------------+--------------+<br>| player_id | device_id | event_date | games_played |<br>+-----------+-----------+------------+--------------+<br>| 1         | 2         | 2016-03-01 | 5            |<br>| 1         | 2         | 2016-05-02 | 6            |<br>| 2         | 3         | 2017-06-25 | 1            |<br>| 3         | 1         | 2016-03-02 | 0            |<br>| 3         | 4         | 2018-07-03 | 5            |<br>+-----------+-----------+------------+--------------+<br><br>Result 表：<br>+-----------+-------------+<br>| player_id | first_login |<br>+-----------+-------------+<br>| 1         | 2016-03-01  |<br>| 2         | 2017-06-25  |<br>| 3         | 2016-03-02  |<br>+-----------+-------------+<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># Write your MySQL query statement below<br><br>select player_id, min(event_date) as first_login from activity <br>group by player_id;<br></code></pre></td></tr></table></figure><h4 id="584-寻找用户推荐人"><a href="#584-寻找用户推荐人" class="headerlink" title="584. 寻找用户推荐人"></a><a href="https://leetcode.cn/problems/find-customer-referee/">584. 寻找用户推荐人</a></h4><p>难度简单107收藏分享切换为英文接收动态反馈</p><p>SQL架构</p><p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+------+------+-----------+<br>| id   | name | referee_id|<br>+------+------+-----------+<br>|    1 | Will |      NULL |<br>|    2 | Jane |      NULL |<br>|    3 | Alex |         2 |<br>|    4 | Bill |      NULL |<br>|    5 | Zack |         1 |<br>|    6 | Mark |         2 |<br>+------+------+-----------+<br></code></pre></td></tr></table></figure><p>写一个查询语句，返回一个客户列表，列表中客户的推荐人的编号都 <strong>不是</strong> 2。</p><p>对于上面的示例数据，结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">+------+<br>| name |<br>+------+<br>| Will |<br>| Jane |<br>| Bill |<br>| Zack |<br>+------+<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Mysql"># Write your MySQL query statement below<br><br>select name <br>from customer<br>where id  not in <br>(select id <br>from customer where  referee_id =2)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2022/10/14/leetcode/"/>
      <url>/2022/10/14/leetcode/</url>
      
        <content type="html"><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h4><p>难度简单15566收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,3], target = 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure><ul><li>有人相爱，有人看海，有人力扣第一题做不出来 :cry:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 利用哈希表来存储记录答案。</span><br>        Map&lt;Integer,Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> target-nums[i];<br>            <span class="hljs-comment">// 判断答案集合是否已经存在符合和当前数加起来等于target的</span><br>            <span class="hljs-comment">// 若符合，则返回答案。不符合则把当前的nums[i]添加，继续遍历。</span><br>            <span class="hljs-keyword">if</span>(hashmap.containsKey(target-nums[i]))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [] &#123;hashmap.get(target-nums[i]),i&#125;;<br>            &#125;<br>            hashmap.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-comment">// 不存在这样的 两个数。返回0.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h4><p>难度中等8767收藏分享切换为英文接收动态反馈</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br>示例 2：<br><br>输入：l1 = [0], l2 = [0]<br>输出：[0]<br></code></pre></td></tr></table></figure><ul><li>创建虚拟头节点，并维护一个进位变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// 初始化一个虚拟节点，和一个前节点，将两者绑定。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>), pre = dummyHead;<br>        <span class="hljs-comment">//  进位变量。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1 !=<span class="hljs-literal">null</span> || l2 !=<span class="hljs-literal">null</span> || temp !=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 把 l1,l2 对位节点上的值相加。</span><br>            <span class="hljs-keyword">if</span>(l1 !=<span class="hljs-literal">null</span>)&#123;<br>                temp += l1.val;<br>                l1 = l1.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">null</span>)&#123;<br>                temp +=l2.val;<br>                l2 = l2.next;<br>            &#125;<br>            <span class="hljs-comment">//若存在进位则将进位值赋给下一位。 如第一个temp相加得12，12%10 =2 则把2赋值给了下一个节点。</span><br>            pre.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(temp %<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">//节点移动到下一个。</span><br>            pre =pre.next;<br>            temp /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode.cn/problems/reverse-integer/">7. 整数反转</a></h4><p>难度中等3657收藏分享切换为英文接收动态反馈</p><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = 123<br>输出：321<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = -123<br>输出：-321<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = 120<br>输出：21<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = 0<br>输出：0<br></code></pre></td></tr></table></figure><ul><li>经典的数字反转，和位数少的相比更多了点值得注意的细节。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x !=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(ans &lt;Integer.MIN_VALUE /<span class="hljs-number">10</span> || ans &gt; Integer.MAX_VALUE /<span class="hljs-number">10</span>)<br>                <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// 经典的取模从最低位开始取数进行反转回填。</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">digit</span> <span class="hljs-operator">=</span> x %<span class="hljs-number">10</span>;<br>            x /=<span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//答案依次 * 10 + 低位。因为每多一位高位就 *10. 10的n次方。</span><br>            ans = ans * <span class="hljs-number">10</span> +digit;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode.cn/problems/palindrome-number/">9. 回文数</a></h4><p>难度简单2260收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = 121<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。<br></code></pre></td></tr></table></figure><ul><li>经典判断回文的方法：先把整形变字符串类型，在对称地从头到尾比较对称位上的字符是否相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> x + <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> num.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(num.charAt(i)==num.charAt(l-<span class="hljs-number">1</span>-i))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>懒狗面试回去等通知法： 调用API。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(String.valueOf(x)).reverse().toString().equals(String.valueOf(x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>还有就是和上面那题整数反转地思想啦，先把待定的数反转。再和原来相比是否相等。从而判断是否是回文数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> a=x;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;<br>            sum=sum*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>            x/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum==a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="769-最多能完成排序的块"><a href="#769-最多能完成排序的块" class="headerlink" title="769. 最多能完成排序的块"></a><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted/">769. 最多能完成排序的块</a></h4><p>难度中等357收藏分享切换为英文接收动态反馈</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。</p><p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p><p>返回数组能分成的最多块数量。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: arr = [4,3,2,1,0]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: arr = [1,0,2,3,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。<br>然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">//当遍历到第i个位置时，如果可以切分为块，那前i个位置的最大值一定等于i。</span><br>        <span class="hljs-comment">//否则，一定有比i小的数划分到后面的块，那块排序后，一定不满足升序。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            max = Math.max(max, arr[i]);<span class="hljs-comment">//统计前i个位置的最大元素</span><br>            <span class="hljs-keyword">if</span> (max == i) res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="考察层次遍历，根左右顺序进队列。"><a href="#考察层次遍历，根左右顺序进队列。" class="headerlink" title="考察层次遍历，根左右顺序进队列。"></a>考察层次遍历，根左右顺序进队列。</h4></li></ul><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><p>难度中等1484收藏分享切换为英文接收动态反馈</p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = [1]<br>输出：[[1]]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root = []<br>输出：[]<br></code></pre></td></tr></table></figure><ul><li>高频题目。简直是老生常谈了。多做几遍。滤清思路。:利用队列来解决问题。先将头节点装入队列中。然后判断数是否为空。不为空的话把根节点的值加入结果集合，同时继续遍历左右子树。先进左子树，再进右子树。知道遍历完整棵树之后循环结束。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root== <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(! queue.isEmpty())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> queue.size();<br>            List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>                list.add(node.val);<br><br>                <span class="hljs-keyword">if</span>(node.left!=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right !=<span class="hljs-literal">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                count--;<br>            &#125;<br>            res.add(list);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h4><p>难度简单2799收藏分享切换为英文接收动态反馈</p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><ul><li><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseListIterative</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//前指针节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//当前指针节点</span><br>        <span class="hljs-comment">//每次循环，都将当前节点指向它前面的节点，然后当前节点和前节点后移</span><br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">nextTemp</span> <span class="hljs-operator">=</span> curr.next; <span class="hljs-comment">//临时节点，暂存当前节点的下一节点，用于后移</span><br>            curr.next = prev; <span class="hljs-comment">//将当前节点指向它前面的节点</span><br>            prev = curr; <span class="hljs-comment">//前指针后移</span><br>            curr = nextTemp; <span class="hljs-comment">//当前指针后移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">// 边缘条件判断</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <br>        <span class="hljs-comment">// 递归调用，翻转第二个节点开始往后的链表</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>        <span class="hljs-comment">// 翻转头节点与第二个节点的指向</span><br>        head.next.next = head;<br>        <span class="hljs-comment">// 此时的 head 节点为尾节点，next 需要指向 NULL</span><br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h4><p>难度简单288收藏分享切换为英文接收动态反馈</p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br></code></pre></td></tr></table></figure><ul><li>同样是链表的经典老题。思路要清晰。细节要到位。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">// 创建一个虚拟头节点。</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">preHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>) ;<br>        <span class="hljs-comment">// 将二者绑定</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> preHead;<br><br>        <span class="hljs-keyword">while</span>(l1 !=<span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                prev.next= l1;<br>                l1=l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                prev.next = l2;<br>                l2 = l2.next;<br>            &#125;<br>            prev = prev.next;<br>        &#125;<br><br>        <span class="hljs-comment">//如果某个链表比较长，则将未合并的接在尾部。</span><br>        prev.next = l1== <span class="hljs-literal">null</span>? l2 : l1 ;<br><br>        <span class="hljs-keyword">return</span> preHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>难度中等1925收藏分享切换为英文接收动态反馈</p><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p><p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,3,4,2,2]<br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [3,1,3,4,2]<br>输出：3<br></code></pre></td></tr></table></figure><ul><li><h4 id="快慢指针-Floyd判圈算法"><a href="#快慢指针-Floyd判圈算法" class="headerlink" title="快慢指针(Floyd判圈算法)"></a>快慢指针(Floyd判圈算法)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,fast =<span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            Floyd判圈算法</span><br><span class="hljs-comment">            如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步。**/</span><br>            slow = nums[slow];<br>            <span class="hljs-comment">//把快指针移动到相遇的位置</span><br>            fast =nums[nums[fast]];<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <span class="hljs-comment">//让慢指针从起点去追快指针，相遇点就是环节点，即重复的数。</span><br>        slow =<span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow= nums[slow] ;<br>            fast = nums[fast];<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h4><p>难度简单1761收藏分享切换为英文接收动态反馈</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: nums = [0]<br>输出: [0]<br></code></pre></td></tr></table></figure><ul><li><h4 id="覆盖法-看大佬评论说好像不太符合题意"><a href="#覆盖法-看大佬评论说好像不太符合题意" class="headerlink" title="覆盖法(看大佬评论说好像不太符合题意)"></a>覆盖法(看大佬评论说好像不太符合题意)</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">// 标记多少个非0的数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-comment">//如果是非零的则从下标0开始赋值给原 nums 数组</span><br>            <span class="hljs-keyword">if</span>(nums[i] !=<span class="hljs-number">0</span>)&#123;<br>                nums[flag++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把0元素在最后的位置赋值上</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=flag;i&lt;nums.length;i++)&#123;<br>            nums[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="双指针交换"><a href="#双指针交换" class="headerlink" title="双指针交换"></a>双指针交换</h4><ul><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li></ul><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>                swap(nums, left, right);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h4><p>难度中等1329收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: temperatures = [30,40,50,60]<br>输出: [1,1,1,0]<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: temperatures = [30,60,90]<br>输出: [1,1,0]<br></code></pre></td></tr></table></figure><ul><li><h4 id="看这题目的意思大概就是找出数组里第一个比当前位置大的元素的元素，然后返回两个数索引之差并回填在当前位置"><a href="#看这题目的意思大概就是找出数组里第一个比当前位置大的元素的元素，然后返回两个数索引之差并回填在当前位置" class="headerlink" title="看这题目的意思大概就是找出数组里第一个比当前位置大的元素的元素，然后返回两个数索引之差并回填在当前位置"></a>看这题目的意思大概就是找出数组里第一个比当前位置大的元素的元素，然后返回两个数索引之差并回填在当前位置</h4><ul><li><h4 id="作为塞拉斯，当然是在题解和评论区偷来了答案：一眼丁真，鉴定为单调栈！"><a href="#作为塞拉斯，当然是在题解和评论区偷来了答案：一眼丁真，鉴定为单调栈！" class="headerlink" title="作为塞拉斯，当然是在题解和评论区偷来了答案：一眼丁真，鉴定为单调栈！"></a>作为塞拉斯，当然是在题解和评论区偷来了答案：一眼丁真，鉴定为单调栈！</h4></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] temperatures) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> temperatures.length;<br>        <span class="hljs-type">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temperature</span> <span class="hljs-operator">=</span> temperatures[i];<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">prevIndex</span> <span class="hljs-operator">=</span> stack.pop();<br>                ans[prevIndex] = i - prevIndex;<br>            &#125;<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><p>难度简单1104收藏分享切换为英文接收动态反馈</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]<br></code></pre></td></tr></table></figure><ul><li>递归解决。左右子树节点值相加当作新的节点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root1 ==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root2==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">merged</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val+ root2.val);<br>        merged.left = mergeTrees(root1.left,root2.left);<br>        merged.right = mergeTrees(root1.right,root2.right);<br><br>        <span class="hljs-keyword">return</span> merged;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>难度简单1175收藏分享切换为英文接收动态反馈</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    1<br>   / \<br>  2   3<br> / \     <br>4   5    <br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><ul><li>递归。分别计算出每个节点的最大深度并记录最大深度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> maxd=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        depth(root);<br>        <span class="hljs-keyword">return</span> maxd;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">depth</span><span class="hljs-params">(TreeNode node)</span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">Left</span> <span class="hljs-operator">=</span> depth(node.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">Right</span> <span class="hljs-operator">=</span> depth(node.right);<br>        maxd=Math.max(Left+Right,maxd);<span class="hljs-comment">//将每个节点最大直径(左子树深度+右子树深度)当前最大值比较并取大者</span><br>        <span class="hljs-keyword">return</span> Math.max(Left,Right)+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回节点深度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></h4><p>难度中等280收藏分享切换为英文接收动态反馈</p><p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p><p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p><p>例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]<br>输出：[null,1,1,1,2,1,4,6]<br>解释：<br>首先，初始化 S = StockSpanner()，然后：<br>S.next(100) 被调用并返回 1，<br>S.next(80) 被调用并返回 1，<br>S.next(60) 被调用并返回 1，<br>S.next(70) 被调用并返回 2，<br>S.next(60) 被调用并返回 1，<br>S.next(75) 被调用并返回 4，<br>S.next(85) 被调用并返回 6。<br><br>注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格<br>(包括今天的价格 75) 小于或等于今天的价格。<br></code></pre></td></tr></table></figure><ul><li><p>这题目什么意思？无非就是找出给定数组里，当前元素前面有多少个数比自己小，最后返回比自己小的个数再加上自己本身（即+1）。显然一次遍历便可以得到结果。但是时间这一块显然拉了。有什么方法能更快呢？自己不会就看别人的！！！看看官方题解，给出第二种思路~。</p></li><li><p>暴力遍历法：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Integer&gt; priceList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        priceList.add(price);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> priceList.size();<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; priceList.get(i) &lt;= price)i--;<br>        <span class="hljs-keyword">return</span> n - i - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>官方题解法：使用单调栈。求出下标之差？？？好像之前也有类似的题目啊也是用到了单调栈。哦原来是739题 每日温度。就在上面，可以去回味一下。继续努力！~</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StockSpanner</span> &#123;<br>    Deque&lt;<span class="hljs-type">int</span>[]&gt; stack;<br>    <span class="hljs-type">int</span> idx;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StockSpanner</span><span class="hljs-params">()</span> &#123;<br>        stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;<span class="hljs-type">int</span>[]&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, Integer.MAX_VALUE&#125;);<br>        idx = -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">int</span> price)</span> &#123;<br>        idx++;<br>        <span class="hljs-keyword">while</span> (price &gt;= stack.peek()[<span class="hljs-number">1</span>]) &#123;<br>            stack.pop();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> idx - stack.peek()[<span class="hljs-number">0</span>];<br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;idx, price&#125;);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="754-到达终点数字"><a href="#754-到达终点数字" class="headerlink" title="754. 到达终点数字"></a><a href="https://leetcode.cn/problems/reach-a-number/">754. 到达终点数字</a></h4><p>难度中等335收藏分享切换为英文接收动态反馈</p><p>在一根无限长的数轴上，你站在<code>0</code>的位置。终点在<code>target</code>的位置。</p><p>你可以做一些数量的移动 <code>numMoves</code> :</p><ul><li>每次你可以选择向左或向右移动。</li><li>第 <code>i</code> 次移动（从  <code>i == 1</code> 开始，到 <code>i == numMoves</code> ），在选择的方向上走 <code>i</code> 步。</li></ul><p>给定整数 <code>target</code> ，返回 <em>到达目标所需的 <strong>最小</strong> 移动次数(即最小 <code>numMoves</code> )</em> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: target = 2<br>输出: 3<br>解释:<br>第一次移动，从 0 到 1 。<br>第二次移动，从 1 到 -1 。<br>第三次移动，从 -1 到 2 。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: target = 3<br>输出: 2<br>解释:<br>第一次移动，从 0 到 1 。<br>第二次移动，从 1 到 3 。<br></code></pre></td></tr></table></figure><ul><li>数学题：找规律找对称性的。。。。。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reachNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        target = Math.abs(target);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (target &gt; <span class="hljs-number">0</span>) &#123;<br>            k++;<br>            target -= k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? k : k + <span class="hljs-number">1</span> + k % <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 力扣算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/2022/10/13/about/"/>
      <url>/2022/10/13/about/</url>
      
        <content type="html"><![CDATA[<ul><li><h4 id="重庆科班在读，创此博客记录学习和生活的点滴"><a href="#重庆科班在读，创此博客记录学习和生活的点滴" class="headerlink" title="重庆科班在读，创此博客记录学习和生活的点滴~"></a>重庆科班在读，创此博客记录学习和生活的点滴~</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> 关于我 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> about </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comment</title>
      <link href="/2022/10/13/comment/"/>
      <url>/2022/10/13/comment/</url>
      
        <content type="html"><![CDATA[<p>希望你永远热爱你的生活</p>]]></content>
      
      
      <categories>
          
          <category> 记录生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> comment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oveshPost</title>
      <link href="/2022/10/12/oveshPost/"/>
      <url>/2022/10/12/oveshPost/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 测试上传博文是否成功 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
