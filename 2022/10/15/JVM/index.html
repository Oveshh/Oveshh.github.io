<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM | Ovesh's home</title><meta name="keywords" content="JVM"><meta name="author" content="Ovesh"><meta name="copyright" content="Ovesh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入理解Java虚拟机chapter 1Chapter 2  Java 内存区域与内存溢出异常2.2  运行时数据区域 2.2.1   程序计数器  （program counter register） 是一块比较小的内存空间 可以看作是当前线程执行的字节码的行号指示器 是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。 java 虚拟机的多线程是通过">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/10/15/JVM/index.html">
<meta property="og:site_name" content="Ovesh&#39;s home">
<meta property="og:description" content="深入理解Java虚拟机chapter 1Chapter 2  Java 内存区域与内存溢出异常2.2  运行时数据区域 2.2.1   程序计数器  （program counter register） 是一块比较小的内存空间 可以看作是当前线程执行的字节码的行号指示器 是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。 java 虚拟机的多线程是通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/suzy.jpg">
<meta property="article:published_time" content="2022-10-15T02:29:24.000Z">
<meta property="article:modified_time" content="2022-10-15T07:25:17.633Z">
<meta property="article:author" content="Ovesh">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/suzy.jpg"><link rel="shortcut icon" href="/image/suzy.jpg"><link rel="canonical" href="http://example.com/2022/10/15/JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/Ovesh's%20Home" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-15 15:25:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/image/background.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/suzy.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ovesh's home</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-15T02:29:24.000Z" title="发表于 2022-10-15 10:29:24">2022-10-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-15T07:25:17.633Z" title="更新于 2022-10-15 15:25:17">2022-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/">深入理解JAVA虚拟机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="深入理解Java虚拟机"><a href="#深入理解Java虚拟机" class="headerlink" title="深入理解Java虚拟机"></a>深入理解Java虚拟机</h1><h2 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h2><h2 id="Chapter-2-Java-内存区域与内存溢出异常"><a href="#Chapter-2-Java-内存区域与内存溢出异常" class="headerlink" title="Chapter 2  Java 内存区域与内存溢出异常"></a>Chapter 2  Java 内存区域与内存溢出异常</h2><h3 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2  运行时数据区域"></a>2.2  运行时数据区域</h3><p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220712225621082.png" alt="image-20220712225621082"></p>
<h4 id="2-2-1-程序计数器-（program-counter-register）"><a href="#2-2-1-程序计数器-（program-counter-register）" class="headerlink" title="2.2.1   程序计数器  （program counter register）"></a>2.2.1   程序计数器  （program counter register）</h4><ol>
<li><h4 id="是一块比较小的内存空间"><a href="#是一块比较小的内存空间" class="headerlink" title="是一块比较小的内存空间"></a>是一块比较小的内存空间</h4></li>
<li><h4 id="可以看作是当前线程执行的字节码的行号指示器"><a href="#可以看作是当前线程执行的字节码的行号指示器" class="headerlink" title="可以看作是当前线程执行的字节码的行号指示器"></a>可以看作是当前线程执行的字节码的行号指示器</h4></li>
<li><h4 id="是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。"><a href="#是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。" class="headerlink" title="是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。"></a>是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</h4></li>
<li><h4 id="java-虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。"><a href="#java-虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。" class="headerlink" title="java 虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。"></a>java 虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。</h4></li>
<li><h4 id="在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为-x3D-x3D-线程私有-x3D-x3D-的内存。"><a href="#在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为-x3D-x3D-线程私有-x3D-x3D-的内存。" class="headerlink" title="在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为&#x3D;&#x3D;线程私有&#x3D;&#x3D;的内存。"></a>在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为&#x3D;&#x3D;线程私有&#x3D;&#x3D;的内存。</h4></li>
<li><h4 id="如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。-x3D-x3D-此内存区域是唯-一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域-x3D-x3D-。"><a href="#如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。-x3D-x3D-此内存区域是唯-一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域-x3D-x3D-。" class="headerlink" title="如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。&#x3D;&#x3D;此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域&#x3D;&#x3D;。"></a>如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。&#x3D;&#x3D;此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域&#x3D;&#x3D;。</h4></li>
</ol>
<h4 id="2-2-2-JAVA-虚拟机栈"><a href="#2-2-2-JAVA-虚拟机栈" class="headerlink" title="2.2.2  JAVA 虚拟机栈"></a>2.2.2  JAVA 虚拟机栈</h4><ol>
<li><h4 id="与PC相同，java虚拟机栈也是线程私有的，-x3D-x3D-它的生命周期与线程相同-x3D-x3D-。"><a href="#与PC相同，java虚拟机栈也是线程私有的，-x3D-x3D-它的生命周期与线程相同-x3D-x3D-。" class="headerlink" title="与PC相同，java虚拟机栈也是线程私有的，&#x3D;&#x3D;它的生命周期与线程相同&#x3D;&#x3D;。"></a>与PC相同，java虚拟机栈也是线程私有的，&#x3D;&#x3D;它的生命周期与线程相同&#x3D;&#x3D;。</h4></li>
<li><h4 id="虚拟机栈描述的是JAVA方法执行的线程内存模型：-x3D-x3D-每个方法被执行的时候，Java虚拟机都-会同步创建一个栈帧-1-（Stack-Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信-息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。-x3D-x3D"><a href="#虚拟机栈描述的是JAVA方法执行的线程内存模型：-x3D-x3D-每个方法被执行的时候，Java虚拟机都-会同步创建一个栈帧-1-（Stack-Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信-息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。-x3D-x3D" class="headerlink" title="虚拟机栈描述的是JAVA方法执行的线程内存模型：&#x3D;&#x3D;每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&#x3D;&#x3D;"></a>虚拟机栈描述的是JAVA方法执行的线程内存模型：&#x3D;&#x3D;每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&#x3D;&#x3D;</h4></li>
<li></li>
</ol>
<ul>
<li><h4 id="经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继-承自传统的C、C-程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比-这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区-域是“堆”和“栈”两块。其中，-x3D-x3D-“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或-者更多的情况下只是指虚拟机栈中局部变量表部分-x3D-x3D-。"><a href="#经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继-承自传统的C、C-程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比-这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区-域是“堆”和“栈”两块。其中，-x3D-x3D-“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或-者更多的情况下只是指虚拟机栈中局部变量表部分-x3D-x3D-。" class="headerlink" title="经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继 承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比 这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区 域是“堆”和“栈”两块。其中，&#x3D;&#x3D;“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或 者更多的情况下只是指虚拟机栈中局部变量表部分&#x3D;&#x3D;。"></a>经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继 承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比 这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区 域是“堆”和“栈”两块。其中，&#x3D;&#x3D;“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或 者更多的情况下只是指虚拟机栈中局部变量表部分&#x3D;&#x3D;。</h4></li>
</ul>
<ol>
<li><h4 id="局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，-x3D-x3D-（reference类型，它并不等同于对象本身，可能是一个指向对象起始-地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）-x3D-x3D-和return-address类型（指向了一条字节码指令的地址）。"><a href="#局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，-x3D-x3D-（reference类型，它并不等同于对象本身，可能是一个指向对象起始-地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）-x3D-x3D-和return-address类型（指向了一条字节码指令的地址）。" class="headerlink" title="局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，&#x3D;&#x3D;（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）&#x3D;&#x3D;和return address类型（指向了一条字节码指令的地址）。"></a>局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，&#x3D;&#x3D;（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）&#x3D;&#x3D;和return address类型（指向了一条字节码指令的地址）。</h4></li>
<li><h4 id="这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，-x3D-x3D-当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定-的，在方法运行期间不会改变局部变量表的大小。-x3D-x3D"><a href="#这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，-x3D-x3D-当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定-的，在方法运行期间不会改变局部变量表的大小。-x3D-x3D" class="headerlink" title="这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，&#x3D;&#x3D;当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。&#x3D;&#x3D;"></a>这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，&#x3D;&#x3D;当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。&#x3D;&#x3D;</h4></li>
<li><h4 id="请读者注意，这里说的“大小”是指变量槽的数量，-虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一-个变量槽，这是完全由具体的虚拟机实现自行决定的事情。"><a href="#请读者注意，这里说的“大小”是指变量槽的数量，-虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一-个变量槽，这是完全由具体的虚拟机实现自行决定的事情。" class="headerlink" title="请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。"></a>请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</h4></li>
<li><h4 id="在《java虚拟机规范》中，对这个内存区域规定了-x3D-x3D-两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常-x3D-x3D-。"><a href="#在《java虚拟机规范》中，对这个内存区域规定了-x3D-x3D-两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常-x3D-x3D-。" class="headerlink" title="在《java虚拟机规范》中，对这个内存区域规定了&#x3D;&#x3D;两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常&#x3D;&#x3D;。"></a>在《java虚拟机规范》中，对这个内存区域规定了&#x3D;&#x3D;两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常&#x3D;&#x3D;。</h4></li>
</ol>
<ul>
<li><h4 id="HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟-机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不-会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情-况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。"><a href="#HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟-机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不-会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情-况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。" class="headerlink" title="HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情 况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。"></a>HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情 况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。</h4></li>
</ul>
<h4 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3  本地方法栈"></a>2.2.3  本地方法栈</h4><ol>
<li><h4 id="本地方法栈（Native-Method-Stack）-与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。"><a href="#本地方法栈（Native-Method-Stack）-与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。" class="headerlink" title="本地方法栈（Native Method Stack） 与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。"></a>本地方法栈（Native Method Stack） 与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。</h4><ol>
<li><h4 id="《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规-定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接-就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，-x3D-x3D-本地方法栈也会在栈深度溢出或者栈扩展失-败时分别抛出StackOverflowError和OutOfMemoryError异常-x3D-x3D"><a href="#《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规-定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接-就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，-x3D-x3D-本地方法栈也会在栈深度溢出或者栈扩展失-败时分别抛出StackOverflowError和OutOfMemoryError异常-x3D-x3D" class="headerlink" title="《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，&#x3D;&#x3D;本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常&#x3D;&#x3D;"></a>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，&#x3D;&#x3D;本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常&#x3D;&#x3D;</h4></li>
</ol>
</li>
</ol>
<h4 id="2-2-4-Java-堆"><a href="#2-2-4-Java-堆" class="headerlink" title="2.2.4   Java 堆"></a>2.2.4   Java 堆</h4><ol>
<li><h4 id="对于java应用程序来说，-x3D-x3D-Java堆（java-heap）-是虚拟机所管的的内存中最大的一块。-x3D-x3D-java堆是被所有线程共享的一块内存区域。"><a href="#对于java应用程序来说，-x3D-x3D-Java堆（java-heap）-是虚拟机所管的的内存中最大的一块。-x3D-x3D-java堆是被所有线程共享的一块内存区域。" class="headerlink" title="对于java应用程序来说，&#x3D;&#x3D;Java堆（java heap） 是虚拟机所管的的内存中最大的一块。&#x3D;&#x3D; java堆是被所有线程共享的一块内存区域。"></a>对于java应用程序来说，&#x3D;&#x3D;Java堆（java heap） 是虚拟机所管的的内存中最大的一块。&#x3D;&#x3D; java堆是被所有线程共享的一块内存区域。</h4></li>
<li><h4 id="x3D-x3D-Java堆是垃圾收集器管理的内存区域-x3D-x3D-，因此一些资料中它也被称作-x3D-x3D-“GC堆”-x3D-x3D-（Garbage-Collected-Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分-代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From-Survivor空-间”“To-Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的-是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体-实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着-类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年-之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部-都基于“经典分代”-3-来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还-算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出-现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。"><a href="#x3D-x3D-Java堆是垃圾收集器管理的内存区域-x3D-x3D-，因此一些资料中它也被称作-x3D-x3D-“GC堆”-x3D-x3D-（Garbage-Collected-Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分-代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From-Survivor空-间”“To-Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的-是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体-实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着-类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年-之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部-都基于“经典分代”-3-来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还-算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出-现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。" class="headerlink" title="&#x3D;&#x3D;Java堆是垃圾收集器管理的内存区域&#x3D;&#x3D;，因此一些资料中它也被称作&#x3D;&#x3D;“GC堆”&#x3D;&#x3D;（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分 代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空 间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的 是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体 实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着 类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年 之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” [3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。"></a>&#x3D;&#x3D;Java堆是垃圾收集器管理的内存区域&#x3D;&#x3D;，因此一些资料中它也被称作&#x3D;&#x3D;“GC堆”&#x3D;&#x3D;（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分 代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空 间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的 是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体 实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着 类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年 之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” [3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。</h4></li>
<li><h4 id="x3D-x3D-如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区-（Thread-Local-Allocation-Buffer，TLAB），以提升对象分配时的效率。-x3D-x3D-不过无论从什么角度，无论如-何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java-堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的-作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。"><a href="#x3D-x3D-如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区-（Thread-Local-Allocation-Buffer，TLAB），以提升对象分配时的效率。-x3D-x3D-不过无论从什么角度，无论如-何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java-堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的-作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。" class="headerlink" title="&#x3D;&#x3D;如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。&#x3D;&#x3D;不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的 作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。"></a>&#x3D;&#x3D;如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。&#x3D;&#x3D;不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的 作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。</h4></li>
<li><h4 id="根据《Java虚拟机规范》的规定，-x3D-x3D-Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该-被视为连续的-x3D-x3D-，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。-x3D-x3D-但对于大-对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的-内存空间。-x3D-x3D"><a href="#根据《Java虚拟机规范》的规定，-x3D-x3D-Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该-被视为连续的-x3D-x3D-，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。-x3D-x3D-但对于大-对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的-内存空间。-x3D-x3D" class="headerlink" title="根据《Java虚拟机规范》的规定，&#x3D;&#x3D;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的&#x3D;&#x3D;，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。&#x3D;&#x3D;但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。&#x3D;&#x3D;"></a>根据《Java虚拟机规范》的规定，&#x3D;&#x3D;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的&#x3D;&#x3D;，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。&#x3D;&#x3D;但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。&#x3D;&#x3D;</h4></li>
</ol>
<ul>
<li><h4 id="Java堆既可以被实现成固定大小的，也可以是可扩展的，-x3D-x3D-不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）-x3D-x3D-。-x3D-x3D-如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。-x3D-x3D"><a href="#Java堆既可以被实现成固定大小的，也可以是可扩展的，-x3D-x3D-不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）-x3D-x3D-。-x3D-x3D-如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。-x3D-x3D" class="headerlink" title="Java堆既可以被实现成固定大小的，也可以是可扩展的，&#x3D;&#x3D;不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）&#x3D;&#x3D;。&#x3D;&#x3D;如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&#x3D;&#x3D;"></a>Java堆既可以被实现成固定大小的，也可以是可扩展的，&#x3D;&#x3D;不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）&#x3D;&#x3D;。&#x3D;&#x3D;如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&#x3D;&#x3D;</h4></li>
</ul>
<h4 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5   方法区"></a>2.2.5   方法区</h4><ol>
<li><h4 id="方法区-Method-Area-与-Java-堆一样，是各个-x3D-x3D-线程共享的内存区域-x3D-x3D-，它用于存储已被虚拟机加载的-x3D-x3D-类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。-x3D-x3D-虽然《Java虚拟机规范》中把-方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区-分开来。"><a href="#方法区-Method-Area-与-Java-堆一样，是各个-x3D-x3D-线程共享的内存区域-x3D-x3D-，它用于存储已被虚拟机加载的-x3D-x3D-类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。-x3D-x3D-虽然《Java虚拟机规范》中把-方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区-分开来。" class="headerlink" title="方法区(Method Area ) 与 Java 堆一样，是各个&#x3D;&#x3D;线程共享的内存区域-&#x3D;&#x3D;，它用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。&#x3D;&#x3D;虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来。"></a>方法区(Method Area ) 与 Java 堆一样，是各个&#x3D;&#x3D;线程共享的内存区域-&#x3D;&#x3D;，它用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。&#x3D;&#x3D;虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来。</h4></li>
</ol>
<ul>
<li><h4 id="说到方法区，不得不提一下-x3D-x3D-“永久代”-x3D-x3D-这个概念，尤其是在JDK-8以前，许多Java程序员都习惯在-HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent-Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设-计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得-HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的-工作。但是对于其他虚拟机实现，譬如BEA-JRockit、IBM-J9等来说，是不存在永久代的概念的。原则-上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头-来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到-内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要-没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法-（例如String-intern-）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了-JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java-Mission-Control管理工具，移植到HotSpot-虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK-6的-时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native-Memory）来实现方法区的计-划了-1-，-x3D-x3D-到了JDK-7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了-JDK-8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK-7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。-x3D-x3D"><a href="#说到方法区，不得不提一下-x3D-x3D-“永久代”-x3D-x3D-这个概念，尤其是在JDK-8以前，许多Java程序员都习惯在-HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent-Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设-计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得-HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的-工作。但是对于其他虚拟机实现，譬如BEA-JRockit、IBM-J9等来说，是不存在永久代的概念的。原则-上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头-来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到-内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要-没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法-（例如String-intern-）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了-JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java-Mission-Control管理工具，移植到HotSpot-虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK-6的-时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native-Memory）来实现方法区的计-划了-1-，-x3D-x3D-到了JDK-7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了-JDK-8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK-7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。-x3D-x3D" class="headerlink" title="说到方法区，不得不提一下&#x3D;&#x3D;“永久代”&#x3D;&#x3D;这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，&#x3D;&#x3D;到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&#x3D;&#x3D;"></a>说到方法区，不得不提一下&#x3D;&#x3D;“永久代”&#x3D;&#x3D;这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，&#x3D;&#x3D;到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&#x3D;&#x3D;</h4></li>
<li><h4 id="《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选-择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的-确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。-x3D-x3D-这区域的内存回-收目标主要是针对常量池的回收和对类型的卸载，-x3D-x3D-一般来说这个区域的回收效果比较难令人满意，尤-其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列-表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存-泄漏。"><a href="#《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选-择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的-确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。-x3D-x3D-这区域的内存回-收目标主要是针对常量池的回收和对类型的卸载，-x3D-x3D-一般来说这个区域的回收效果比较难令人满意，尤-其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列-表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存-泄漏。" class="headerlink" title="《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。&#x3D;&#x3D;这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，&#x3D;&#x3D;一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列 表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。"></a>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。&#x3D;&#x3D;这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，&#x3D;&#x3D;一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列 表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。</h4></li>
</ul>
<ol>
<li><h4 id="根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出-OutOfMemoryError异常。"><a href="#根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出-OutOfMemoryError异常。" class="headerlink" title="根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。"></a>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</h4></li>
</ol>
<h4 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6   运行时常量池"></a>2.2.6   运行时常量池</h4><ol>
<li><h4 id="运行时常量池（Runtime-Constant-Pool-是方法区的一部分。Class-文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。"><a href="#运行时常量池（Runtime-Constant-Pool-是方法区的一部分。Class-文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。" class="headerlink" title="运行时常量池（Runtime Constant Pool )  是方法区的一部分。Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。"></a>运行时常量池（Runtime Constant Pool )  是方法区的一部分。Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。</h4></li>
<li><h4 id="Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用-于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，-《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现-这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来-的直接引用也存储在运行时常量池中-1-。"><a href="#Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用-于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，-《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现-这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来-的直接引用也存储在运行时常量池中-1-。" class="headerlink" title="Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用 于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来 的直接引用也存储在运行时常量池中[1]。"></a>Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用 于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来 的直接引用也存储在运行时常量池中[1]。</h4></li>
<li><h4 id="运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量-一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常-量池，-x3D-x3D-运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的-intern-方法。-x3D-x3D"><a href="#运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量-一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常-量池，-x3D-x3D-运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的-intern-方法。-x3D-x3D" class="headerlink" title="运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，&#x3D;&#x3D;运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&#x3D;&#x3D;"></a>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，&#x3D;&#x3D;运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&#x3D;&#x3D;</h4></li>
<li><h4 id="x3D-x3D-既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存-时会抛出OutOfMemoryError异常。-x3D-x3D"><a href="#x3D-x3D-既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存-时会抛出OutOfMemoryError异常。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。&#x3D;&#x3D;"></a>&#x3D;&#x3D;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。&#x3D;&#x3D;</h4></li>
</ol>
<h4 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7    直接内存"></a>2.2.7    直接内存</h4><ol>
<li><h4 id="直接内存（Direct-Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中-定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所-以我们放到这里一起讲解。"><a href="#直接内存（Direct-Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中-定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所-以我们放到这里一起讲解。" class="headerlink" title="直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。"></a>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。</h4></li>
<li><h4 id="在JDK-1-4中新加入了-x3D-x3D-NIO（New-Input-x2F-Output）类-x3D-x3D-，引入了-x3D-x3D-一种基于通道（Channel）与缓冲区-（Buffer）的I-x2F-O方式-x3D-x3D-，-x3D-x3D-它可以使用Native函数库直接分配堆外内存-x3D-x3D-，然后通过一个存储在Java堆里面的-DirectByteBuffer对象作为这块内存的引用进行操作。-x3D-x3D-这样能在一些场景中显著提高性能，因为避免了-在Java堆和Native堆中来回复制数据。-x3D-x3D"><a href="#在JDK-1-4中新加入了-x3D-x3D-NIO（New-Input-x2F-Output）类-x3D-x3D-，引入了-x3D-x3D-一种基于通道（Channel）与缓冲区-（Buffer）的I-x2F-O方式-x3D-x3D-，-x3D-x3D-它可以使用Native函数库直接分配堆外内存-x3D-x3D-，然后通过一个存储在Java堆里面的-DirectByteBuffer对象作为这块内存的引用进行操作。-x3D-x3D-这样能在一些场景中显著提高性能，因为避免了-在Java堆和Native堆中来回复制数据。-x3D-x3D" class="headerlink" title="在JDK 1.4中新加入了&#x3D;&#x3D;NIO（New Input&#x2F;Output）类&#x3D;&#x3D;，引入了&#x3D;&#x3D;一种基于通道（Channel）与缓冲区 （Buffer）的I&#x2F;O方式&#x3D;&#x3D;，&#x3D;&#x3D;它可以使用Native函数库直接分配堆外内存&#x3D;&#x3D;，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。&#x3D;&#x3D;这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。&#x3D;&#x3D;"></a>在JDK 1.4中新加入了&#x3D;&#x3D;NIO（New Input&#x2F;Output）类&#x3D;&#x3D;，引入了&#x3D;&#x3D;一种基于通道（Channel）与缓冲区 （Buffer）的I&#x2F;O方式&#x3D;&#x3D;，&#x3D;&#x3D;它可以使用Native函数库直接分配堆外内存&#x3D;&#x3D;，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。&#x3D;&#x3D;这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。&#x3D;&#x3D;</h4></li>
<li><h4 id="显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到-本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务-器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得-各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现-OutOfMemoryError异常。"><a href="#显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到-本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务-器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得-各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现-OutOfMemoryError异常。" class="headerlink" title="显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。"></a>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。</h4></li>
</ol>
<h3 id="2-3-HotSpot-虚拟机对象探秘"><a href="#2-3-HotSpot-虚拟机对象探秘" class="headerlink" title="2.3 HotSpot 虚拟机对象探秘"></a>2.3 HotSpot 虚拟机对象探秘</h3><h4 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1  对象的创建"></a>2.3.1  对象的创建</h4><ul>
<li><h4 id="Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面-上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文-中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？"><a href="#Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面-上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文-中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？" class="headerlink" title="Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面 上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文 中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？"></a>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面 上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文 中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</h4></li>
</ul>
<ol>
<li><h4 id="x3D-x3D-当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到-一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那-必须先执行相应的类加载过程-x3D-x3D-，详情见第七章"><a href="#x3D-x3D-当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到-一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那-必须先执行相应的类加载过程-x3D-x3D-，详情见第七章" class="headerlink" title="&#x3D;&#x3D;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程&#x3D;&#x3D;，详情见第七章"></a>&#x3D;&#x3D;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程&#x3D;&#x3D;，详情见第七章</h4></li>
<li><h4 id="在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，-x3D-x3D-为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。-x3D-x3D-假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，-x3D-x3D-中间放着一个指针作为分解点的指示器，-x3D-x3D-那所分配内粗你就仅仅是-x3D-x3D-把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump-the-pointer-）-x3D-x3D-但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那-就没有办法简单地进行指针碰撞了，-x3D-x3D-虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分-配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称-为“空闲列表”（Free-List）。-x3D-x3D"><a href="#在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，-x3D-x3D-为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。-x3D-x3D-假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，-x3D-x3D-中间放着一个指针作为分解点的指示器，-x3D-x3D-那所分配内粗你就仅仅是-x3D-x3D-把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump-the-pointer-）-x3D-x3D-但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那-就没有办法简单地进行指针碰撞了，-x3D-x3D-虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分-配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称-为“空闲列表”（Free-List）。-x3D-x3D" class="headerlink" title="在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，&#x3D;&#x3D;为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。&#x3D;&#x3D;假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，&#x3D;&#x3D;中间放着一个指针作为分解点的指示器，&#x3D;&#x3D;那所分配内粗你就仅仅是&#x3D;&#x3D;把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump the pointer ）&#x3D;&#x3D; 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，&#x3D;&#x3D;虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。&#x3D;&#x3D;"></a>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，&#x3D;&#x3D;为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。&#x3D;&#x3D;假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，&#x3D;&#x3D;中间放着一个指针作为分解点的指示器，&#x3D;&#x3D;那所分配内粗你就仅仅是&#x3D;&#x3D;把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump the pointer ）&#x3D;&#x3D; 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，&#x3D;&#x3D;虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。&#x3D;&#x3D;</h4><ol>
<li><h4 id="选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用-的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩-整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除-（Sweep）算法的收集器时，理论上-1-就只能采用较为复杂的空闲列表来分配内存。"><a href="#选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用-的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩-整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除-（Sweep）算法的收集器时，理论上-1-就只能采用较为复杂的空闲列表来分配内存。" class="headerlink" title="选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用 的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。"></a>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用 的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</h4></li>
</ol>
</li>
<li><h4 id="除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行-为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象-A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题-有两种可选方案：-x3D-x3D-一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败-重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进-行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread-Local-Allocation-Buffer，TLAB）-x3D-x3D-，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完-了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以-x3D-x3D-通过-XX：-x2F-UseTLAB-x3D-x3D-参数来-设定。"><a href="#除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行-为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象-A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题-有两种可选方案：-x3D-x3D-一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败-重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进-行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread-Local-Allocation-Buffer，TLAB）-x3D-x3D-，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完-了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以-x3D-x3D-通过-XX：-x2F-UseTLAB-x3D-x3D-参数来-设定。" class="headerlink" title="除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：&#x3D;&#x3D;一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）&#x3D;&#x3D;，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以&#x3D;&#x3D;通过-XX：+&#x2F;-UseTLAB&#x3D;&#x3D;参数来 设定。"></a>除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：&#x3D;&#x3D;一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）&#x3D;&#x3D;，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以&#x3D;&#x3D;通过-XX：+&#x2F;-UseTLAB&#x3D;&#x3D;参数来 设定。</h4></li>
</ol>
<ul>
<li><h4 id="x3D-x3D-内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值-x3D-x3D-，如果-使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段-在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。"><a href="#x3D-x3D-内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值-x3D-x3D-，如果-使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段-在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。" class="headerlink" title="&#x3D;&#x3D;内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值&#x3D;&#x3D;，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。"></a>&#x3D;&#x3D;内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值&#x3D;&#x3D;，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</h4></li>
<li><h4 id="x3D-x3D-接下来，Java虚拟机还要对对象进行必要的设置-x3D-x3D-，例如这个对象是哪个类的实例、如何才能找到-类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object-hashCode-方法时才-计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object-Header）之中。根据虚拟-机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内-容，稍后会详细介绍。"><a href="#x3D-x3D-接下来，Java虚拟机还要对对象进行必要的设置-x3D-x3D-，例如这个对象是哪个类的实例、如何才能找到-类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object-hashCode-方法时才-计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object-Header）之中。根据虚拟-机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内-容，稍后会详细介绍。" class="headerlink" title="&#x3D;&#x3D;接下来，Java虚拟机还要对对象进行必要的设置&#x3D;&#x3D;，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内 容，稍后会详细介绍。"></a>&#x3D;&#x3D;接下来，Java虚拟机还要对对象进行必要的设置&#x3D;&#x3D;，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内 容，稍后会详细介绍。</h4></li>
<li><h4 id="在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视-角看来，对象创建才刚刚开始——构造函数，即Class文件中的-方法还没有执行，所有的字段都-为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节-码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成-这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），-x3D-x3D-new指令之后会接着执行-方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。-x3D-x3D"><a href="#在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视-角看来，对象创建才刚刚开始——构造函数，即Class文件中的-方法还没有执行，所有的字段都-为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节-码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成-这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），-x3D-x3D-new指令之后会接着执行-方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。-x3D-x3D" class="headerlink" title="在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），&#x3D;&#x3D;new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。&#x3D;&#x3D;"></a>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），&#x3D;&#x3D;new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。&#x3D;&#x3D;</h4></li>
</ul>
<h4 id="2-3-2-对象的布局"><a href="#2-3-2-对象的布局" class="headerlink" title="2.3.2  对象的布局"></a>2.3.2  对象的布局</h4><ul>
<li><h4 id="在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例-数据（Instance-Data）和对齐填充（Padding）。"><a href="#在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例-数据（Instance-Data）和对齐填充（Padding）。" class="headerlink" title="在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）。"></a>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）。</h4></li>
</ul>
<p>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部 分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它 为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的 最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效 率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根 据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年 龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态（轻量级锁定、重量级锁定、GC标 记、可偏向）[1]下对象的存储内容如表2-1所示。</p>
<p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718183513160.png" alt="image-20220718183513160"></p>
<p>对象头的另外一部分是类型指针，&#x3D;&#x3D;即对象指向它的类型元数据的指针&#x3D;&#x3D;，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话 说，查找对象的元数据信息并不一定要经过对象本身，这点我们会在下一节具体讨论。此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，&#x3D;&#x3D;因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。&#x3D;&#x3D;</p>
<h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3  对象的访问定位"></a>2.3.3  对象的访问定位</h3><p>所以对象访问方式也是由虚拟机实 现而定的，主流的访问方式主要有使用&#x3D;&#x3D;句柄和直接指针&#x3D;&#x3D;两种：</p>
<p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图2-2所 示。</p>
<p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销，如图2-3所示。</p>
<p>这两种对象访问方式各有优势，&#x3D;&#x3D;使用句柄来访问的最大好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。&#x3D;&#x3D;</p>
<p>1. </p>
<p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718193528820.png" alt="image-20220718193528820"></p>
<ol start="2">
<li></li>
</ol>
<p><img src="C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220718193540698.png" alt="image-20220718193540698"></p>
<p>&#x3D;&#x3D;使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销&#x3D;&#x3D;，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟 机HotSpot而言，它主要使用第二种方式进行对象访问（有例外情况，如果使用了Shenandoah收集器的 话也会有一次额外的转发，具体可参见第3章），但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。</p>
<h3 id="2-4-实战-：-OutOfMemoryError-异常"><a href="#2-4-实战-：-OutOfMemoryError-异常" class="headerlink" title="2.4     实战 ：  OutOfMemoryError 异常"></a>2.4     实战 ：  OutOfMemoryError 异常</h3><h4 id="2-4-1-Java堆溢出"><a href="#2-4-1-Java堆溢出" class="headerlink" title="2.4.1    Java堆溢出"></a>2.4.1    Java堆溢出</h4><p>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径 来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会 产生内存溢出异常。</p>
<p>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存 溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示&#x3D;&#x3D;“Java heap space“&#x3D;&#x3D;。</p>
<p>要解决这个内存区域的异常，常规的处理方法是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。第一步首先应确认内存中导致OOM的对象是否是必 要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。图2-5显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。</p>
<p> 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎 样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内 存泄漏的代码的具体位置。</p>
<p>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，&#x3D;&#x3D;那就应当检查Java虚拟机 的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查 是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运 行期的内存消耗。 以上是处理Java堆内&#x3D;&#x3D;</p>
<h4 id="2-4-2-虚拟机栈和本地方法栈溢出"><a href="#2-4-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.4.2  虚拟机栈和本地方法栈溢出"></a>2.4.2  虚拟机栈和本地方法栈溢出</h4><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置 本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟 机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：</p>
<ol>
<li>&#x3D;&#x3D;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。&#x3D;&#x3D;</li>
</ol>
<h4 id="2-4-3-方法区和运行时常量池溢出"><a href="#2-4-3-方法区和运行时常量池溢出" class="headerlink" title="2.4.3    方法区和运行时常量池溢出"></a>2.4.3    方法区和运行时常量池溢出</h4><p>&#x3D;&#x3D;由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。前面曾经 提到HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代的背景 故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，对程序有什么 实际的影响。&#x3D;&#x3D;</p>
<p>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的 字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加 到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配 在永久代中，我们可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其 中常量池的容量，</p>
<h4 id="2-4-4-本机直接内存溢出"><a href="#2-4-4-本机直接内存溢出" class="headerlink" title="2.4.4    本机直接内存溢出"></a>2.4.4    本机直接内存溢出</h4><ul>
<li><h4 id="直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。"><a href="#直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。" class="headerlink" title="直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。"></a>直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。</h4></li>
</ul>
<p>使用unsafe 分配主机内存。</p>
<p>由直接内存导致的内存溢出： 一个明显的特征是 Heao Dump 文件中不会看见由什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory （典型的间接使用了NIO），那就可以考虑重点检查一下直接内存方面女的问题了。</p>
<h2 id="Chapter-3-垃圾收集器与内存分配策略"><a href="#Chapter-3-垃圾收集器与内存分配策略" class="headerlink" title="Chapter  3     垃圾收集器与内存分配策略"></a>Chapter  3     垃圾收集器与内存分配策略</h2><ul>
<li><h4 id="Java-与C-之间有一堵由-内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。"><a href="#Java-与C-之间有一堵由-内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。" class="headerlink" title="Java 与C++ 之间有一堵由 内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。"></a>Java 与C++ 之间有一堵由 内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</h4></li>
</ul>
<h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1   概述"></a>3.1   概述</h3><ol>
<li><h4 id="那些内存需要回收？"><a href="#那些内存需要回收？" class="headerlink" title="那些内存需要回收？"></a>那些内存需要回收？</h4></li>
<li><h4 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h4></li>
<li><h4 id="如何回收-。"><a href="#如何回收-。" class="headerlink" title="如何回收?。"></a>如何回收?。</h4></li>
</ol>
<ul>
<li><h4 id="java-堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。-x3D-x3D-垃圾收集器所关注的正式这部分内存该管理-x3D-x3D-。"><a href="#java-堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。-x3D-x3D-垃圾收集器所关注的正式这部分内存该管理-x3D-x3D-。" class="headerlink" title="java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。&#x3D;&#x3D;垃圾收集器所关注的正式这部分内存该管理&#x3D;&#x3D;。"></a>java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。&#x3D;&#x3D;垃圾收集器所关注的正式这部分内存该管理&#x3D;&#x3D;。</h4></li>
</ul>
<h3 id="3-2-对象已死？"><a href="#3-2-对象已死？" class="headerlink" title="3.2    对象已死？"></a>3.2    对象已死？</h3><ul>
<li><h4 id="如何确定哪些对象还“存活“着，哪些已经”死去“？"><a href="#如何确定哪些对象还“存活“着，哪些已经”死去“？" class="headerlink" title="如何确定哪些对象还“存活“着，哪些已经”死去“？"></a>如何确定哪些对象还“存活“着，哪些已经”死去“？</h4></li>
</ul>
<h4 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1    引用计数算法"></a>3.2.1    引用计数算法</h4><p>大多教科书的算法：</p>
<ul>
<li><h4 id="x3D-x3D-在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。-x3D-x3D"><a href="#x3D-x3D-在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。&#x3D;&#x3D;"></a>&#x3D;&#x3D;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。&#x3D;&#x3D;</h4></li>
<li><h4 id="引用计数很难解决对象之间相互循环引用的问题。"><a href="#引用计数很难解决对象之间相互循环引用的问题。" class="headerlink" title="引用计数很难解决对象之间相互循环引用的问题。"></a>引用计数很难解决对象之间相互循环引用的问题。</h4></li>
<li><h4 id="两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。"><a href="#两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。" class="headerlink" title="两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。"></a>两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。</h4></li>
</ul>
<h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2      可达性分析算法"></a>3.2.2      可达性分析算法</h4><p>当前主流的商用应用程序的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。</p>
<ul>
<li><h4 id="这个算法的思路就是通过一系列-称为-”GC-Roots”-的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC-Roots-间没有任何引用链相连，-x3D-x3D-或者用图论的话说就是从GC-Roots-到这个对象不可达时，则证明此对象是不可能再被使用的。-x3D-x3D"><a href="#这个算法的思路就是通过一系列-称为-”GC-Roots”-的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC-Roots-间没有任何引用链相连，-x3D-x3D-或者用图论的话说就是从GC-Roots-到这个对象不可达时，则证明此对象是不可能再被使用的。-x3D-x3D" class="headerlink" title="这个算法的思路就是通过一系列 称为 ”GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots 间没有任何引用链相连，&#x3D;&#x3D;或者用图论的话说就是从GC Roots  到这个对象不可达时，则证明此对象是不可能再被使用的。&#x3D;&#x3D;"></a>这个算法的思路就是通过一系列 称为 ”GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots 间没有任何引用链相连，&#x3D;&#x3D;或者用图论的话说就是从GC Roots  到这个对象不可达时，则证明此对象是不可能再被使用的。&#x3D;&#x3D;</h4></li>
<li><h4 id="在JAVA技术体系中里面，固定可作为GC-Roots-的对象包括以下几种："><a href="#在JAVA技术体系中里面，固定可作为GC-Roots-的对象包括以下几种：" class="headerlink" title="在JAVA技术体系中里面，固定可作为GC Roots 的对象包括以下几种："></a>在JAVA技术体系中里面，固定可作为GC Roots 的对象包括以下几种：</h4><ul>
<li><h4 id="在-x3D-x3D-虚拟机栈（栈帧中的本地变量表）中引用的对象-x3D-x3D-，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量"><a href="#在-x3D-x3D-虚拟机栈（栈帧中的本地变量表）中引用的对象-x3D-x3D-，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量" class="headerlink" title="在&#x3D;&#x3D;虚拟机栈（栈帧中的本地变量表）中引用的对象&#x3D;&#x3D;，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量"></a>在&#x3D;&#x3D;虚拟机栈（栈帧中的本地变量表）中引用的对象&#x3D;&#x3D;，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量</h4></li>
<li><h4 id="x3D-x3D-在方法区中类静态属性引用的对象-x3D-x3D-，譬如java类的引用类型静态变量"><a href="#x3D-x3D-在方法区中类静态属性引用的对象-x3D-x3D-，譬如java类的引用类型静态变量" class="headerlink" title="&#x3D;&#x3D;在方法区中类静态属性引用的对象&#x3D;&#x3D;，譬如java类的引用类型静态变量"></a>&#x3D;&#x3D;在方法区中类静态属性引用的对象&#x3D;&#x3D;，譬如java类的引用类型静态变量</h4></li>
<li><h4 id="在方法区中常量引用的对象，譬如字符串常量池（String-Table）里的引用"><a href="#在方法区中常量引用的对象，譬如字符串常量池（String-Table）里的引用" class="headerlink" title="在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用"></a>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</h4></li>
<li><h4 id="在本地方法栈中JNI（即通常所说的Native方法）引用的对象"><a href="#在本地方法栈中JNI（即通常所说的Native方法）引用的对象" class="headerlink" title="在本地方法栈中JNI（即通常所说的Native方法）引用的对象"></a>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</h4></li>
<li><h4 id="java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器"><a href="#java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器" class="headerlink" title="java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器"></a>java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</h4></li>
<li><h4 id="所有被同步锁（synchronized关键字）持有的对象"><a href="#所有被同步锁（synchronized关键字）持有的对象" class="headerlink" title="所有被同步锁（synchronized关键字）持有的对象"></a>所有被同步锁（synchronized关键字）持有的对象</h4></li>
<li><h4 id="反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。"><a href="#反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。" class="headerlink" title="反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。"></a>反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。</h4></li>
</ul>
</li>
</ul>
<h4 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3    再谈引用"></a>3.2.3    再谈引用</h4><ul>
<li><h4 id="x3D-x3D-当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。-x3D-x3D"><a href="#x3D-x3D-当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。&#x3D;&#x3D;"></a>&#x3D;&#x3D;当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。&#x3D;&#x3D;</h4></li>
<li><h4 id="java的引用，-x3D-x3D-强引用，软引用，弱引用，和虚引用-x3D-x3D-4种，这四种引用强度一次逐渐减弱。"><a href="#java的引用，-x3D-x3D-强引用，软引用，弱引用，和虚引用-x3D-x3D-4种，这四种引用强度一次逐渐减弱。" class="headerlink" title="java的引用，&#x3D;&#x3D;强引用，软引用，弱引用，和虚引用&#x3D;&#x3D;4种，这四种引用强度一次逐渐减弱。"></a>java的引用，&#x3D;&#x3D;强引用，软引用，弱引用，和虚引用&#x3D;&#x3D;4种，这四种引用强度一次逐渐减弱。</h4></li>
</ul>
<h5 id="3-2-3-1-4种引用类型"><a href="#3-2-3-1-4种引用类型" class="headerlink" title="3.2.3.1    4种引用类型"></a>3.2.3.1    4种引用类型</h5><ul>
<li><h4 id="x3D-x3D-强引用-x3D-x3D-是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object-obj-x3D-new-Object（）”这种引用关系，-x3D-x3D-只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象-x3D-x3D-。"><a href="#x3D-x3D-强引用-x3D-x3D-是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object-obj-x3D-new-Object（）”这种引用关系，-x3D-x3D-只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象-x3D-x3D-。" class="headerlink" title="&#x3D;&#x3D;强引用&#x3D;&#x3D;是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object obj &#x3D; new Object（）”这种引用关系，&#x3D;&#x3D;只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象&#x3D;&#x3D;。"></a>&#x3D;&#x3D;强引用&#x3D;&#x3D;是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object obj &#x3D; new Object（）”这种引用关系，&#x3D;&#x3D;只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象&#x3D;&#x3D;。</h4></li>
<li><h4 id="软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内-存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，-才会抛出内存溢出异常。在JDK-1-2版之后提供了SoftReference类来实现软引用。"><a href="#软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内-存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，-才会抛出内存溢出异常。在JDK-1-2版之后提供了SoftReference类来实现软引用。" class="headerlink" title="软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。"></a>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</h4></li>
<li><h4 id="弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只-能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只-被弱引用关联的对象。在JDK-1-2版之后提供了WeakReference类来实现弱引用。"><a href="#弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只-能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只-被弱引用关联的对象。在JDK-1-2版之后提供了WeakReference类来实现弱引用。" class="headerlink" title="弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。"></a>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</h4></li>
<li><h4 id="虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的-存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚-引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK-1-2版之后提供-了PhantomReference类来实现虚引用。"><a href="#虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的-存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚-引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK-1-2版之后提供-了PhantomReference类来实现虚引用。" class="headerlink" title="虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。"></a>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。</h4></li>
</ul>
<h4 id="3-2-4-生存还是死亡？"><a href="#3-2-4-生存还是死亡？" class="headerlink" title="3.2.4    生存还是死亡？"></a>3.2.4    生存还是死亡？</h4><ul>
<li><h4 id="即使在-x3D-x3D-可达性分析算法中判定为不可达的对象-x3D-x3D-，也不是“非死不可”的，这时候它们暂时还处于“缓-刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没-有与GC-Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是-否有必要执行finalize-方法。假如对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用-过，那么虚拟机将这两种情况都视为“没有必要执行”。"><a href="#即使在-x3D-x3D-可达性分析算法中判定为不可达的对象-x3D-x3D-，也不是“非死不可”的，这时候它们暂时还处于“缓-刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没-有与GC-Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是-否有必要执行finalize-方法。假如对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用-过，那么虚拟机将这两种情况都视为“没有必要执行”。" class="headerlink" title="即使在&#x3D;&#x3D;可达性分析算法中判定为不可达的对象&#x3D;&#x3D;，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。"></a>即使在&#x3D;&#x3D;可达性分析算法中判定为不可达的对象&#x3D;&#x3D;，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</h4></li>
<li><h4 id="如果这个对象被判定为确有必要执行finalize-方法，那么该对象将会被放置在一个名为F-Queue的-队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize-方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。-这样做的原因是，如果某个对象的finalize-方法执行缓慢，或者更极端地发生了死循环，将很可能导-致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。-x3D-x3D-finalize-方法是对-象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对-象要在finalize-中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己-（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合-x3D-x3D-；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个-对象的finalize-被执行，但是它仍然可以存活"><a href="#如果这个对象被判定为确有必要执行finalize-方法，那么该对象将会被放置在一个名为F-Queue的-队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize-方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。-这样做的原因是，如果某个对象的finalize-方法执行缓慢，或者更极端地发生了死循环，将很可能导-致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。-x3D-x3D-finalize-方法是对-象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对-象要在finalize-中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己-（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合-x3D-x3D-；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个-对象的finalize-被执行，但是它仍然可以存活" class="headerlink" title="如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。&#x3D;&#x3D;finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合&#x3D;&#x3D;；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个 对象的finalize()被执行，但是它仍然可以存活"></a>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。&#x3D;&#x3D;finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合&#x3D;&#x3D;；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个 对象的finalize()被执行，但是它仍然可以存活</h4></li>
</ul>
<h4 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5  回收方法区"></a>3.2.5  回收方法区</h4><ul>
<li><h4 id="有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚-拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整-实现方法区类型卸载的收集器存在（如JDK-11时期的ZGC收集器就不支持类卸载），方法区垃圾收集-的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常-可以回收70-至99-的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回-收成果往往远低于此。"><a href="#有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚-拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整-实现方法区类型卸载的收集器存在（如JDK-11时期的ZGC收集器就不支持类卸载），方法区垃圾收集-的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常-可以回收70-至99-的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回-收成果往往远低于此。" class="headerlink" title="有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。"></a>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。</h4></li>
<li><h4 id="x3D-x3D-方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型-x3D-x3D-。回收废弃常量与回收-Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池-中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用-常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且-垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接-口）、方法、字段的符号引用也与此类似。"><a href="#x3D-x3D-方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型-x3D-x3D-。回收废弃常量与回收-Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池-中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用-常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且-垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接-口）、方法、字段的符号引用也与此类似。" class="headerlink" title="&#x3D;&#x3D;方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型&#x3D;&#x3D;。回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接 口）、方法、字段的符号引用也与此类似。"></a>&#x3D;&#x3D;方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型&#x3D;&#x3D;。回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接 口）、方法、字段的符号引用也与此类似。</h4></li>
<li><h4 id="定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就-比较苛刻了。需要-x3D-x3D-同时满足-x3D-x3D-下面三个条件："><a href="#定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就-比较苛刻了。需要-x3D-x3D-同时满足-x3D-x3D-下面三个条件：" class="headerlink" title="定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要&#x3D;&#x3D;同时满足&#x3D;&#x3D;下面三个条件："></a>定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要&#x3D;&#x3D;同时满足&#x3D;&#x3D;下面三个条件：</h4></li>
</ul>
<ol>
<li><h4 id="·-x3D-x3D-该类所有的实例都已经被回收-x3D-x3D-，也就是Java堆中不存在该类及其任何派生子类的实例。"><a href="#·-x3D-x3D-该类所有的实例都已经被回收-x3D-x3D-，也就是Java堆中不存在该类及其任何派生子类的实例。" class="headerlink" title="·&#x3D;&#x3D;该类所有的实例都已经被回收&#x3D;&#x3D;，也就是Java堆中不存在该类及其任何派生子类的实例。"></a>·&#x3D;&#x3D;该类所有的实例都已经被回收&#x3D;&#x3D;，也就是Java堆中不存在该类及其任何派生子类的实例。</h4></li>
<li><h4 id="·-x3D-x3D-加载该类的类加载器已经被回收-x3D-x3D-，这个条件除非是经过精心设计的可替换类加载器的场景，如-OSGi、JSP的重加载等，否则通常是很难达成的。"><a href="#·-x3D-x3D-加载该类的类加载器已经被回收-x3D-x3D-，这个条件除非是经过精心设计的可替换类加载器的场景，如-OSGi、JSP的重加载等，否则通常是很难达成的。" class="headerlink" title="·&#x3D;&#x3D;加载该类的类加载器已经被回收&#x3D;&#x3D;，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。"></a>·&#x3D;&#x3D;加载该类的类加载器已经被回收&#x3D;&#x3D;，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。</h4></li>
<li><h4 id="·-x3D-x3D-该类对应的java-lang-Class对象没有在任何地方被引用-x3D-x3D-，无法在任何地方通过反射访问该类的方-法。"><a href="#·-x3D-x3D-该类对应的java-lang-Class对象没有在任何地方被引用-x3D-x3D-，无法在任何地方通过反射访问该类的方-法。" class="headerlink" title="·&#x3D;&#x3D;该类对应的java.lang.Class对象没有在任何地方被引用&#x3D;&#x3D;，无法在任何地方通过反射访问该类的方 法。"></a>·&#x3D;&#x3D;该类对应的java.lang.Class对象没有在任何地方被引用&#x3D;&#x3D;，无法在任何地方通过反射访问该类的方 法。</h4></li>
</ol>
<ul>
<li><h4 id="x3D-x3D-在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载-器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压-力。-x3D-x3D"><a href="#x3D-x3D-在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载-器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压-力。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。&#x3D;&#x3D;"></a>&#x3D;&#x3D;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。&#x3D;&#x3D;</h4></li>
</ul>
<h3 id="3-3-垃圾回收算法"><a href="#3-3-垃圾回收算法" class="headerlink" title="3.3  垃圾回收算法"></a>3.3  垃圾回收算法</h3><ul>
<li><h4 id="从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference-Counting-GC）和“追踪式垃圾收集”（Tracing-GC）两大类，这两类也常被称作“直接垃圾收集”和“间接-垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不-把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。"><a href="#从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference-Counting-GC）和“追踪式垃圾收集”（Tracing-GC）两大类，这两类也常被称作“直接垃圾收集”和“间接-垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不-把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。" class="headerlink" title="从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。"></a>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。</h4></li>
</ul>
<h4 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1   分代收集理论"></a>3.3.1   分代收集理论</h4><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进 行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分 代假说之上：</p>
<ol>
<li><h4 id="弱分代假说-week-generation-hypothesis-绝大多数对象都是朝生夕灭的"><a href="#弱分代假说-week-generation-hypothesis-绝大多数对象都是朝生夕灭的" class="headerlink" title="弱分代假说(week generation hypothesis): 绝大多数对象都是朝生夕灭的"></a>弱分代假说(week generation hypothesis): 绝大多数对象都是朝生夕灭的</h4></li>
<li><h4 id="强分代假说-Strong-generation-hypothesis-熬过越多次垃圾收集过程的对象就越难以消亡。"><a href="#强分代假说-Strong-generation-hypothesis-熬过越多次垃圾收集过程的对象就越难以消亡。" class="headerlink" title="强分代假说(Strong generation hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。"></a>强分代假说(Strong generation hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。</h4></li>
</ol>
<ul>
<li><h4 id="这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：-x3D-x3D-收集器应该将Java堆划分-出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区-域之中存储。-x3D-x3D-显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那-么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对-象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，-虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有-效利用。"><a href="#这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：-x3D-x3D-收集器应该将Java堆划分-出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区-域之中存储。-x3D-x3D-显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那-么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对-象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，-虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有-效利用。" class="headerlink" title="这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：&#x3D;&#x3D;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。&#x3D;&#x3D;显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。"></a>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：&#x3D;&#x3D;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。&#x3D;&#x3D;显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。</h4></li>
<li><h4 id="在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域-——因而才有了“Minor-GC”“Major-GC”“Full-GC”这样的回收类型的划分；也才能够针对不同的区域安-排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算-法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的-重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。"><a href="#在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域-——因而才有了“Minor-GC”“Major-GC”“Full-GC”这样的回收类型的划分；也才能够针对不同的区域安-排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算-法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的-重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。" class="headerlink" title="在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的 重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。"></a>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的 重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。</h4></li>
<li><h4 id="3）跨代引用假说（Intergenerational-Reference-Hypothesis）：跨代引用相对于同代引用来说仅占极-少数。"><a href="#3）跨代引用假说（Intergenerational-Reference-Hypothesis）：跨代引用相对于同代引用来说仅占极-少数。" class="headerlink" title="3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。"></a>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。</h4></li>
</ul>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数 据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<ol>
<li><h4 id="·部分收集（Partial-GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为："><a href="#·部分收集（Partial-GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：" class="headerlink" title="·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为："></a>·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</h4></li>
</ol>
<ul>
<li><h4 id="■新生代收集（Minor-GC-x2F-Young-GC）：指目标只是新生代的垃圾收集"><a href="#■新生代收集（Minor-GC-x2F-Young-GC）：指目标只是新生代的垃圾收集" class="headerlink" title="■新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集"></a>■新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</h4></li>
<li><h4 id="■老年代收集（Major-GC-x2F-Old-GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单-独收集老年代的行为。另外请注意“Major-GC”这个说法现在有点混淆，在不同资料上常有不同所指，-读者需按上下文区分到底是指老年代的收集还是整堆收集。"><a href="#■老年代收集（Major-GC-x2F-Old-GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单-独收集老年代的行为。另外请注意“Major-GC”这个说法现在有点混淆，在不同资料上常有不同所指，-读者需按上下文区分到底是指老年代的收集还是整堆收集。" class="headerlink" title="■老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。"></a>■老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。</h4></li>
<li><h4 id="■混合收集（Mixed-GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收-集器会有这种行为。"><a href="#■混合收集（Mixed-GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收-集器会有这种行为。" class="headerlink" title="■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。"></a>■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</h4></li>
<li><h4 id="·整堆收集（Full-GC）：收集整个Java堆和方法区的垃圾收集。"><a href="#·整堆收集（Full-GC）：收集整个Java堆和方法区的垃圾收集。" class="headerlink" title="·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。"></a>·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</h4></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Ovesh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/15/JVM/">http://example.com/2022/10/15/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Ovesh's home</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/image/suzy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src="/"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src="/"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/15/Suzy/"><img class="prev-cover" src="/image/suzy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Suzy</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/14/MySQL%E9%9D%A2%E8%AF%95/"><img class="next-cover" src="/image/suzy.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL面试</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/image/background.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ovesh</div><div class="author-info__description">Let me be your cape~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Oveshh"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Oveshh" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=1057642402&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to Ovesh's Home</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">深入理解Java虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter-1"><span class="toc-number">1.1.</span> <span class="toc-text">chapter 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.</span> <span class="toc-text">Chapter 2  Java 内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.2  运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-%EF%BC%88program-counter-register%EF%BC%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.2.1   程序计数器  （program counter register）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%B8%80%E5%9D%97%E6%AF%94%E8%BE%83%E5%B0%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">是一块比较小的内存空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9C%8B%E4%BD%9C%E6%98%AF%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%A1%8C%E5%8F%B7%E6%8C%87%E7%A4%BA%E5%99%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">可以看作是当前线程执行的字节码的行号指示器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E6%B5%81%E7%9A%84%E6%8C%87%E7%A4%BA%E5%99%A8%EF%BC%8C%E5%88%86%E6%94%AF%EF%BC%8C%E5%BE%AA%E7%8E%AF%EF%BC%8C%E8%B7%B3%E8%BD%AC%EF%BC%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%81%A2%E5%A4%8D%E7%AD%89%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E9%83%BD%E9%9C%80%E8%A6%81%E4%BE%9D%E8%B5%96%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E6%9D%A5%E5%AE%8C%E6%88%90%E3%80%82"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖程序计数器来完成。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E5%88%87%E6%8D%A2%EF%BC%8C%E5%88%86%E9%85%8D%E5%A4%84%E7%90%86%E5%99%A8%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%E3%80%82"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">java 虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%97%B6%E5%88%BB%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E5%AF%B9%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E6%9D%A5%E8%AF%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%EF%BC%89%E9%83%BD%E5%8F%AA%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%8C%87%E4%BB%A4%E3%80%82%E5%9B%A0%E6%AD%A4%E3%80%82%E4%B8%BA%E4%BA%86%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E5%90%8E%E8%83%BD%E6%81%A2%E5%A4%8D%E5%88%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BD%8D%E7%BD%AE%EF%BC%8C%E6%AF%8F%E6%9D%A1%E7%BA%BF%E7%A8%8B%E9%83%BD%E9%9C%80%E8%A6%81%E6%9C%89%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84PC%EF%BC%8C%E5%90%84%E6%9D%A1%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84PC%E4%BA%92%E4%B8%8D%E5%BD%B1%E5%93%8D%EF%BC%8C%E7%8B%AC%E7%AB%8B%E5%AD%98%E5%82%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A7%B0%E8%BF%99%E7%B1%BB%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%BA-x3D-x3D-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89-x3D-x3D-%E7%9A%84%E5%86%85%E5%AD%98%E3%80%82"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的PC，各条线程之间的PC互不影响，独立存储，我们称这类内存区域为&#x3D;&#x3D;线程私有&#x3D;&#x3D;的内存。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AAjava%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AE%B0%E5%BD%95%E7%9A%84%E6%98%AF%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AF%E6%9C%AC%E5%9C%B0%EF%BC%88native%EF%BC%89%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%E5%80%BC%E5%88%99%E4%B8%BA%E7%A9%BA%E3%80%82-x3D-x3D-%E6%AD%A4%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%94%AF-%E4%B8%80%E4%B8%80%E4%B8%AA%E5%9C%A8%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A7%84%E5%AE%9A%E4%BB%BB%E4%BD%95OutOfMemoryError%E6%83%85%E5%86%B5%E7%9A%84%E5%8C%BA%E5%9F%9F-x3D-x3D-%E3%80%82"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（native）方法，这个计数器值则为空。&#x3D;&#x3D;此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-JAVA-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">2.2.2  JAVA 虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8EPC%E7%9B%B8%E5%90%8C%EF%BC%8Cjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B9%9F%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%8C-x3D-x3D-%E5%AE%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%90%8C-x3D-x3D-%E3%80%82"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">与PC相同，java虚拟机栈也是线程私有的，&#x3D;&#x3D;它的生命周期与线程相同&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%98%AFJAVA%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9A-x3D-x3D-%E6%AF%8F%E4%B8%AA%E6%96%B9%E6%B3%95%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD-%E4%BC%9A%E5%90%8C%E6%AD%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7-1-%EF%BC%88Stack-Frame%EF%BC%89%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E3%80%81%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E6%96%B9%E6%B3%95%E5%87%BA%E5%8F%A3%E7%AD%89%E4%BF%A1-%E6%81%AF%E3%80%82%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9B%B4%E8%87%B3%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%B0%B1%E5%AF%B9%E5%BA%94%E7%9D%80%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%AD%E4%BB%8E%E5%85%A5%E6%A0%88%E5%88%B0%E5%87%BA%E6%A0%88%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.10.</span> <span class="toc-text">虚拟机栈描述的是JAVA方法执行的线程内存模型：&#x3D;&#x3D;每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信 息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%B8%B8%E6%9C%89%E4%BA%BA%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AC%BC%E7%BB%9F%E5%9C%B0%E5%88%92%E5%88%86%E4%B8%BA%E5%A0%86%E5%86%85%E5%AD%98%EF%BC%88Heap%EF%BC%89%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%88Stack%EF%BC%89%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E7%BB%A7-%E6%89%BF%E8%87%AA%E4%BC%A0%E7%BB%9F%E7%9A%84C%E3%80%81C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%BB%93%E6%9E%84%EF%BC%8C%E5%9C%A8Java%E8%AF%AD%E8%A8%80%E9%87%8C%E5%B0%B1%E6%98%BE%E5%BE%97%E6%9C%89%E4%BA%9B%E7%B2%97%E7%B3%99%E4%BA%86%EF%BC%8C%E5%AE%9E%E9%99%85%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E8%A6%81%E6%AF%94-%E8%BF%99%E6%9B%B4%E5%A4%8D%E6%9D%82%E3%80%82%E4%B8%8D%E8%BF%87%E8%BF%99%E7%A7%8D%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%B5%81%E8%A1%8C%E4%B9%9F%E9%97%B4%E6%8E%A5%E8%AF%B4%E6%98%8E%E4%BA%86%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E5%85%B3%E6%B3%A8%E7%9A%84%E3%80%81%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%85%B3%E7%B3%BB%E6%9C%80%E5%AF%86%E5%88%87%E7%9A%84%E5%8C%BA-%E5%9F%9F%E6%98%AF%E2%80%9C%E5%A0%86%E2%80%9D%E5%92%8C%E2%80%9C%E6%A0%88%E2%80%9D%E4%B8%A4%E5%9D%97%E3%80%82%E5%85%B6%E4%B8%AD%EF%BC%8C-x3D-x3D-%E2%80%9C%E5%A0%86%E2%80%9D%E5%9C%A8%E7%A8%8D%E5%90%8E%E7%AC%94%E8%80%85%E4%BC%9A%E4%B8%93%E9%97%A8%E8%AE%B2%E8%BF%B0%EF%BC%8C%E8%80%8C%E2%80%9C%E6%A0%88%E2%80%9D%E9%80%9A%E5%B8%B8%E5%B0%B1%E6%98%AF%E6%8C%87%E8%BF%99%E9%87%8C%E8%AE%B2%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%8C%E6%88%96-%E8%80%85%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AA%E6%98%AF%E6%8C%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E9%83%A8%E5%88%86-x3D-x3D-%E3%80%82"><span class="toc-number">1.2.1.11.</span> <span class="toc-text">经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继 承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比 这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区 域是“堆”和“栈”两块。其中，&#x3D;&#x3D;“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或 者更多的情况下只是指虚拟机栈中局部变量表部分&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E5%AD%98%E6%94%BE%E4%BA%86%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%AF%E7%9F%A5%E7%9A%84%E5%90%84%E7%A7%8DJAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88boolean%EF%BC%8Cbyte%EF%BC%8Cchar%EF%BC%8Cshort%EF%BC%8Cint%EF%BC%8Cfloat%EF%BC%8Clong%EF%BC%8Cdouble%EF%BC%89%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%EF%BC%8C-x3D-x3D-%EF%BC%88reference%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%AE%83%E5%B9%B6%E4%B8%8D%E7%AD%89%E5%90%8C%E4%BA%8E%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%BA%AB%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E8%B5%B7%E5%A7%8B-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BC%95%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E4%BB%A3%E8%A1%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%A5%E6%9F%84%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E4%B8%8E%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89-x3D-x3D-%E5%92%8Creturn-address%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%8C%87%E5%90%91%E4%BA%86%E4%B8%80%E6%9D%A1%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%89%E3%80%82"><span class="toc-number">1.2.1.12.</span> <span class="toc-text">局部变量表存放了编译期可知的各种JAVA虚拟机基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用，&#x3D;&#x3D;（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）&#x3D;&#x3D;和return address类型（指向了一条字节码指令的地址）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9C%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%A7%BD%EF%BC%88SLot%EF%BC%89%E6%9D%A5%E8%A1%A8%E7%A4%BA%EF%BC%8C%E5%85%B6%E4%B8%AD64%E4%BD%8D%E9%95%BF%E5%BA%A6%E7%9A%84long%E5%92%8Cdouble%E7%B1%BB%E5%9E%8B%E4%BC%9A%E5%8D%A0%E7%94%A8%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%A7%BD%EF%BC%8C%E5%85%B6%E4%BD%99%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%AA%E5%8D%A0%E7%94%A8%E4%B8%80%E4%B8%AA%E3%80%82%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%89%80%E9%9C%80%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E9%97%B4%E5%AE%8C%E6%88%90%E5%88%86%E9%85%8D%EF%BC%8C-x3D-x3D-%E5%BD%93%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%9C%A8%E6%A0%88%E5%B8%A7%E4%B8%AD%E5%88%86%E9%85%8D%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%A9%BA%E9%97%B4%E6%98%AF%E5%AE%8C%E5%85%A8%E7%A1%AE%E5%AE%9A-%E7%9A%84%EF%BC%8C%E5%9C%A8%E6%96%B9%E6%B3%95%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.13.</span> <span class="toc-text">这些数据类型在局部变量表中的存储空间以局部变量槽（SLot）来表示，其中64位长度的long和double类型会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，&#x3D;&#x3D;当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%BB%E8%80%85%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%BF%99%E9%87%8C%E8%AF%B4%E7%9A%84%E2%80%9C%E5%A4%A7%E5%B0%8F%E2%80%9D%E6%98%AF%E6%8C%87%E5%8F%98%E9%87%8F%E6%A7%BD%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%8C-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9C%9F%E6%AD%A3%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%88%E8%AD%AC%E5%A6%82%E6%8C%89%E7%85%A71%E4%B8%AA%E5%8F%98%E9%87%8F%E6%A7%BD%E5%8D%A0%E7%94%A832%E4%B8%AA%E6%AF%94%E7%89%B9%E3%80%8164%E4%B8%AA%E6%AF%94%E7%89%B9%EF%BC%8C%E6%88%96%E8%80%85%E6%9B%B4%E5%A4%9A%EF%BC%89%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80-%E4%B8%AA%E5%8F%98%E9%87%8F%E6%A7%BD%EF%BC%8C%E8%BF%99%E6%98%AF%E5%AE%8C%E5%85%A8%E7%94%B1%E5%85%B7%E4%BD%93%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E8%87%AA%E8%A1%8C%E5%86%B3%E5%AE%9A%E7%9A%84%E4%BA%8B%E6%83%85%E3%80%82"><span class="toc-number">1.2.1.14.</span> <span class="toc-text">请读者注意，这里说的“大小”是指变量槽的数量， 虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E3%80%8Ajava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%A7%84%E5%AE%9A%E4%BA%86-x3D-x3D-%E4%B8%A4%E7%B1%BB%E5%BC%82%E5%B8%B8%E7%8A%B6%E5%86%B5%EF%BC%9A1%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E8%AF%B7%E6%B1%82%E7%9A%84%E6%A0%88%E6%B7%B1%E5%BA%A6%E5%A4%A7%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%80%E5%85%81%E8%AE%B8%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%8C%E5%B0%86%E6%8A%9B%E5%87%BAStackOVerflowError%E5%BC%82%E5%B8%B8%EF%BC%9A%E5%A6%82%E6%9E%9Cjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%AE%B9%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%EF%BC%8C%E5%BD%93%E6%A0%88%E6%89%A9%E5%B1%95%E6%97%B6%E6%97%A0%E6%B3%95%E7%94%B3%E8%AF%B7%E5%88%B0%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%9A%E6%8A%9B%E5%87%BAOutOfMemoryError%E5%BC%82%E5%B8%B8-x3D-x3D-%E3%80%82"><span class="toc-number">1.2.1.15.</span> <span class="toc-text">在《java虚拟机规范》中，对这个内存区域规定了&#x3D;&#x3D;两类异常状况：1：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOVerflowError异常：如果java虚拟机栈容量可以动态扩容，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E6%A0%88%E5%AE%B9%E9%87%8F%E6%98%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E7%9A%84%EF%BC%8C%E4%BB%A5%E5%89%8D%E7%9A%84Classic%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%80%92%E6%98%AF%E5%8F%AF%E4%BB%A5%E3%80%82%E6%89%80%E4%BB%A5%E5%9C%A8HotSpot%E8%99%9A%E6%8B%9F-%E6%9C%BA%E4%B8%8A%E6%98%AF%E4%B8%8D%E4%BC%9A%E7%94%B1%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E6%97%A0%E6%B3%95%E6%89%A9%E5%B1%95%E8%80%8C%E5%AF%BC%E8%87%B4OutOfMemoryError%E5%BC%82%E5%B8%B8%E2%80%94%E2%80%94%E5%8F%AA%E8%A6%81%E7%BA%BF%E7%A8%8B%E7%94%B3%E8%AF%B7%E6%A0%88%E7%A9%BA%E9%97%B4%E6%88%90%E5%8A%9F%E4%BA%86%E5%B0%B1%E4%B8%8D-%E4%BC%9A%E6%9C%89OOM%EF%BC%8C%E4%BD%86%E6%98%AF%E5%A6%82%E6%9E%9C%E7%94%B3%E8%AF%B7%E6%97%B6%E5%B0%B1%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%BB%8D%E7%84%B6%E6%98%AF%E4%BC%9A%E5%87%BA%E7%8E%B0OOM%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E5%AE%9E%E6%88%98%E4%B8%AD%E7%AC%94%E8%80%85%E4%B9%9F%E6%BC%94%E7%A4%BA%E4%BA%86%E8%BF%99%E7%A7%8D%E6%83%85-%E5%86%B5%E3%80%82%E6%9C%AC%E4%B9%A6%E7%AC%AC2%E7%89%88%E6%97%B6%E8%BF%99%E9%87%8C%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%98%AF%E6%9C%89%E8%AF%AF%E7%9A%84%EF%BC%8C%E8%AF%B7%E9%98%85%E8%AF%BB%E8%BF%87%E7%AC%AC2%E7%89%88%E7%9A%84%E8%AF%BB%E8%80%85%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E3%80%82"><span class="toc-number">1.2.1.16.</span> <span class="toc-text">HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟 机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情 况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">1.2.1.17.</span> <span class="toc-text">2.2.3  本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89-%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%91%E6%8C%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E9%9D%9E%E5%B8%B8%E7%9B%B8%E4%BC%BC%E7%9A%84%EF%BC%8C%E5%85%B6%E5%8C%BA%E5%88%AB%E5%8F%AA%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8Cjava%E6%96%B9%E6%B3%95%EF%BC%8C%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%89%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%80%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%88%99%E6%98%AF%E4%B8%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%88%86%E5%8F%91%E6%9C%8D%E5%8A%A1%E3%80%82"><span class="toc-number">1.2.1.18.</span> <span class="toc-text">本地方法栈（Native Method Stack） 与虚拟机发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行java方法，（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地分发服务。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E5%AF%B9%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%AD%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%BC%BA%E5%88%B6%E8%A7%84-%E5%AE%9A%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%85%B7%E4%BD%93%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%87%AA%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%AE%83%EF%BC%8C%E7%94%9A%E8%87%B3%E6%9C%89%E7%9A%84Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E8%AD%AC%E5%A6%82Hot-Spot%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89%E7%9B%B4%E6%8E%A5-%E5%B0%B1%E6%8A%8A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%90%88%E4%BA%8C%E4%B8%BA%E4%B8%80%E3%80%82%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%80%E6%A0%B7%EF%BC%8C-x3D-x3D-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B9%9F%E4%BC%9A%E5%9C%A8%E6%A0%88%E6%B7%B1%E5%BA%A6%E6%BA%A2%E5%87%BA%E6%88%96%E8%80%85%E6%A0%88%E6%89%A9%E5%B1%95%E5%A4%B1-%E8%B4%A5%E6%97%B6%E5%88%86%E5%88%AB%E6%8A%9B%E5%87%BAStackOverflowError%E5%92%8COutOfMemoryError%E5%BC%82%E5%B8%B8-x3D-x3D"><span class="toc-number">1.2.1.19.</span> <span class="toc-text">《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接 就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，&#x3D;&#x3D;本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-Java-%E5%A0%86"><span class="toc-number">1.2.1.20.</span> <span class="toc-text">2.2.4   Java 堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8Ejava%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A5%E8%AF%B4%EF%BC%8C-x3D-x3D-Java%E5%A0%86%EF%BC%88java-heap%EF%BC%89-%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%80%E7%AE%A1%E7%9A%84%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E4%B8%80%E5%9D%97%E3%80%82-x3D-x3D-java%E5%A0%86%E6%98%AF%E8%A2%AB%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E4%B8%80%E5%9D%97%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%82"><span class="toc-number">1.2.1.21.</span> <span class="toc-text">对于java应用程序来说，&#x3D;&#x3D;Java堆（java heap） 是虚拟机所管的的内存中最大的一块。&#x3D;&#x3D; java堆是被所有线程共享的一块内存区域。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-Java%E5%A0%86%E6%98%AF%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F-x3D-x3D-%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99%E4%B8%AD%E5%AE%83%E4%B9%9F%E8%A2%AB%E7%A7%B0%E4%BD%9C-x3D-x3D-%E2%80%9CGC%E5%A0%86%E2%80%9D-x3D-x3D-%EF%BC%88Garbage-Collected-Heap%EF%BC%8C%E5%B9%B8%E5%A5%BD%E5%9B%BD%E5%86%85%E6%B2%A1%E7%BF%BB%E8%AF%91%E6%88%90%E2%80%9C%E5%9E%83%E5%9C%BE%E5%A0%86%E2%80%9D%EF%BC%89%E3%80%82%E4%BB%8E%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%EF%BC%8C%E7%94%B1%E4%BA%8E%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%A4%A7%E9%83%A8%E5%88%86%E9%83%BD%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%88%86-%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA%E8%AE%BE%E8%AE%A1%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5Java%E5%A0%86%E4%B8%AD%E7%BB%8F%E5%B8%B8%E4%BC%9A%E5%87%BA%E7%8E%B0%E2%80%9C%E6%96%B0%E7%94%9F%E4%BB%A3%E2%80%9D%E2%80%9C%E8%80%81%E5%B9%B4%E4%BB%A3%E2%80%9D%E2%80%9C%E6%B0%B8%E4%B9%85%E4%BB%A3%E2%80%9D%E2%80%9CEden%E7%A9%BA%E9%97%B4%E2%80%9D%E2%80%9CFrom-Survivor%E7%A9%BA-%E9%97%B4%E2%80%9D%E2%80%9CTo-Survivor%E7%A9%BA%E9%97%B4%E2%80%9D%E7%AD%89%E5%90%8D%E8%AF%8D%EF%BC%8C%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5%E5%9C%A8%E6%9C%AC%E4%B9%A6%E5%90%8E%E7%BB%AD%E7%AB%A0%E8%8A%82%E4%B8%AD%E8%BF%98%E4%BC%9A%E5%8F%8D%E5%A4%8D%E7%99%BB%E5%9C%BA%E4%BA%AE%E7%9B%B8%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%87%8C%E7%AC%94%E8%80%85%E6%83%B3%E5%85%88%E8%AF%B4%E6%98%8E%E7%9A%84-%E6%98%AF%E8%BF%99%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E9%83%A8%E5%88%86%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%85%B1%E5%90%8C%E7%89%B9%E6%80%A7%E6%88%96%E8%80%85%E8%AF%B4%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E8%80%8C%E5%B7%B2%EF%BC%8C%E8%80%8C%E9%9D%9E%E6%9F%90%E4%B8%AAJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B7%E4%BD%93-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9B%BA%E6%9C%89%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%8C%E6%9B%B4%E4%B8%8D%E6%98%AF%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E9%87%8C%E5%AF%B9Java%E5%A0%86%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E8%87%B4%E5%88%92%E5%88%86%E3%80%82%E4%B8%8D%E5%B0%91%E8%B5%84%E6%96%99%E4%B8%8A%E7%BB%8F%E5%B8%B8%E5%86%99%E7%9D%80-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E2%80%9CJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%E3%80%81Eden%E3%80%81Survivor%E2%80%A6%E2%80%A6%E2%80%9D%E8%BF%99%E6%A0%B7%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E5%9C%A8%E5%8D%81%E5%B9%B4-%E4%B9%8B%E5%89%8D%EF%BC%88%E4%BB%A5G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%87%BA%E7%8E%B0%E4%B8%BA%E5%88%86%E7%95%8C%EF%BC%89%EF%BC%8C%E4%BD%9C%E4%B8%BA%E4%B8%9A%E7%95%8C%E7%BB%9D%E5%AF%B9%E4%B8%BB%E6%B5%81%E7%9A%84HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%AE%83%E5%86%85%E9%83%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A8%E9%83%A8-%E9%83%BD%E5%9F%BA%E4%BA%8E%E2%80%9C%E7%BB%8F%E5%85%B8%E5%88%86%E4%BB%A3%E2%80%9D-3-%E6%9D%A5%E8%AE%BE%E8%AE%A1%EF%BC%8C%E9%9C%80%E8%A6%81%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8%E6%90%AD%E9%85%8D%E6%89%8D%E8%83%BD%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%9C%A8%E8%BF%99%E7%A7%8D%E8%83%8C%E6%99%AF%E4%B8%8B%EF%BC%8C%E4%B8%8A%E8%BF%B0%E8%AF%B4%E6%B3%95%E8%BF%98-%E7%AE%97%E6%98%AF%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%A4%AA%E5%A4%A7%E6%AD%A7%E4%B9%89%E3%80%82%E4%BD%86%E6%98%AF%E5%88%B0%E4%BA%86%E4%BB%8A%E5%A4%A9%EF%BC%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%8D%81%E5%B9%B4%E5%89%8D%E5%B7%B2%E4%B8%8D%E5%8F%AF%E5%90%8C%E6%97%A5%E8%80%8C%E8%AF%AD%EF%BC%8CHotSpot%E9%87%8C%E9%9D%A2%E4%B9%9F%E5%87%BA-%E7%8E%B0%E4%BA%86%E4%B8%8D%E9%87%87%E7%94%A8%E5%88%86%E4%BB%A3%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%96%B0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%86%8D%E6%8C%89%E7%85%A7%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%8F%90%E6%B3%95%E5%B0%B1%E6%9C%89%E5%BE%88%E5%A4%9A%E9%9C%80%E8%A6%81%E5%95%86%E6%A6%B7%E7%9A%84%E5%9C%B0%E6%96%B9%E4%BA%86%E3%80%82"><span class="toc-number">1.2.1.22.</span> <span class="toc-text">&#x3D;&#x3D;Java堆是垃圾收集器管理的内存区域&#x3D;&#x3D;，因此一些资料中它也被称作&#x3D;&#x3D;“GC堆”&#x3D;&#x3D;（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分 代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空 间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的 是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体 实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着 类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年 之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部 都基于“经典分代” [3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还 算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出 现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%A6%82%E6%9E%9C%E4%BB%8E%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%EF%BC%8C%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84Java%E5%A0%86%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%88%92%E5%88%86%E5%87%BA%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%E7%9A%84%E5%88%86%E9%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA-%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%8CTLAB%EF%BC%89%EF%BC%8C%E4%BB%A5%E6%8F%90%E5%8D%87%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E6%97%B6%E7%9A%84%E6%95%88%E7%8E%87%E3%80%82-x3D-x3D-%E4%B8%8D%E8%BF%87%E6%97%A0%E8%AE%BA%E4%BB%8E%E4%BB%80%E4%B9%88%E8%A7%92%E5%BA%A6%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%A6%82-%E4%BD%95%E5%88%92%E5%88%86%EF%BC%8C%E9%83%BD%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98Java%E5%A0%86%E4%B8%AD%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9%E7%9A%84%E5%85%B1%E6%80%A7%EF%BC%8C%E6%97%A0%E8%AE%BA%E6%98%AF%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%AD%98%E5%82%A8%E7%9A%84%E9%83%BD%E5%8F%AA%E8%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B0%86Java-%E5%A0%86%E7%BB%86%E5%88%86%E7%9A%84%E7%9B%AE%E7%9A%84%E5%8F%AA%E6%98%AF%E4%B8%BA%E4%BA%86%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%EF%BC%8C%E6%88%96%E8%80%85%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E3%80%82%E5%9C%A8%E6%9C%AC%E7%AB%A0%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BB%85%E4%BB%85%E9%92%88%E5%AF%B9%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84-%E4%BD%9C%E7%94%A8%E8%BF%9B%E8%A1%8C%E8%AE%A8%E8%AE%BA%EF%BC%8CJava%E5%A0%86%E4%B8%AD%E7%9A%84%E4%B8%8A%E8%BF%B0%E5%90%84%E4%B8%AA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%86%E9%85%8D%E3%80%81%E5%9B%9E%E6%94%B6%E7%AD%89%E7%BB%86%E8%8A%82%E5%B0%86%E4%BC%9A%E6%98%AF%E4%B8%8B%E4%B8%80%E7%AB%A0%E7%9A%84%E4%B8%BB%E9%A2%98%E3%80%82"><span class="toc-number">1.2.1.23.</span> <span class="toc-text">&#x3D;&#x3D;如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 （Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。&#x3D;&#x3D;不过无论从什么角度，无论如 何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的 作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E7%9A%84%E8%A7%84%E5%AE%9A%EF%BC%8C-x3D-x3D-Java%E5%A0%86%E5%8F%AF%E4%BB%A5%E5%A4%84%E4%BA%8E%E7%89%A9%E7%90%86%E4%B8%8A%E4%B8%8D%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%AD%EF%BC%8C%E4%BD%86%E5%9C%A8%E9%80%BB%E8%BE%91%E4%B8%8A%E5%AE%83%E5%BA%94%E8%AF%A5-%E8%A2%AB%E8%A7%86%E4%B8%BA%E8%BF%9E%E7%BB%AD%E7%9A%84-x3D-x3D-%EF%BC%8C%E8%BF%99%E7%82%B9%E5%B0%B1%E5%83%8F%E6%88%91%E4%BB%AC%E7%94%A8%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%8E%BB%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%B9%B6%E4%B8%8D%E8%A6%81%E6%B1%82%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E9%83%BD%E8%BF%9E%E7%BB%AD%E5%AD%98%E6%94%BE%E3%80%82-x3D-x3D-%E4%BD%86%E5%AF%B9%E4%BA%8E%E5%A4%A7-%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%85%B8%E5%9E%8B%E7%9A%84%E5%A6%82%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%EF%BC%89%EF%BC%8C%E5%A4%9A%E6%95%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%87%BA%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E3%80%81%E5%AD%98%E5%82%A8%E9%AB%98%E6%95%88%E7%9A%84%E8%80%83%E8%99%91%EF%BC%8C%E5%BE%88%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A6%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E7%9A%84-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.24.</span> <span class="toc-text">根据《Java虚拟机规范》的规定，&#x3D;&#x3D;Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的&#x3D;&#x3D;，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。&#x3D;&#x3D;但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%A0%86%E6%97%A2%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%AE%9E%E7%8E%B0%E6%88%90%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%EF%BC%8C-x3D-x3D-%E4%B8%8D%E8%BF%87%E5%BD%93%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%BD%E6%98%AF%E6%8C%89%E7%85%A7%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%88%E9%80%9A%E8%BF%87%E5%8F%82%E6%95%B0-Xmx%E5%92%8C-Xms%E8%AE%BE%E5%AE%9A%EF%BC%89-x3D-x3D-%E3%80%82-x3D-x3D-%E5%A6%82%E6%9E%9C%E5%9C%A8Java%E5%A0%86%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E5%AE%8C%E6%88%90%E5%AE%9E%E4%BE%8B%E5%88%86%E9%85%8D%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%A0%86%E4%B9%9F%E6%97%A0%E6%B3%95%E5%86%8D%E6%89%A9%E5%B1%95%E6%97%B6%EF%BC%8CJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%86%E4%BC%9A%E6%8A%9B%E5%87%BAOutOfMemoryError%E5%BC%82%E5%B8%B8%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.25.</span> <span class="toc-text">Java堆既可以被实现成固定大小的，也可以是可扩展的，&#x3D;&#x3D;不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）&#x3D;&#x3D;。&#x3D;&#x3D;如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.2.1.26.</span> <span class="toc-text">2.2.5   方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA-Method-Area-%E4%B8%8E-Java-%E5%A0%86%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%98%AF%E5%90%84%E4%B8%AA-x3D-x3D-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F-x3D-x3D-%EF%BC%8C%E5%AE%83%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E5%B7%B2%E8%A2%AB%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E7%9A%84-x3D-x3D-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B8%B8%E9%87%8F%EF%BC%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%8C%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%93%E5%AD%98%E7%AD%89%E6%95%B0%E6%8D%AE%E3%80%82-x3D-x3D-%E8%99%BD%E7%84%B6%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E4%B8%AD%E6%8A%8A-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%8F%8F%E8%BF%B0%E4%B8%BA%E5%A0%86%E7%9A%84%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E9%83%A8%E5%88%86%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E5%8D%B4%E6%9C%89%E4%B8%80%E4%B8%AA%E5%88%AB%E5%90%8D%E5%8F%AB%E4%BD%9C%E2%80%9C%E9%9D%9E%E5%A0%86%E2%80%9D%EF%BC%88Non-Heap%EF%BC%89%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%8EJava%E5%A0%86%E5%8C%BA-%E5%88%86%E5%BC%80%E6%9D%A5%E3%80%82"><span class="toc-number">1.2.1.27.</span> <span class="toc-text">方法区(Method Area ) 与 Java 堆一样，是各个&#x3D;&#x3D;线程共享的内存区域-&#x3D;&#x3D;，它用于存储已被虚拟机加载的&#x3D;&#x3D;类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。&#x3D;&#x3D;虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区 分开来。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E5%88%B0%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%8C%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%8F%90%E4%B8%80%E4%B8%8B-x3D-x3D-%E2%80%9C%E6%B0%B8%E4%B9%85%E4%BB%A3%E2%80%9D-x3D-x3D-%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E5%9C%A8JDK-8%E4%BB%A5%E5%89%8D%EF%BC%8C%E8%AE%B8%E5%A4%9AJava%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E4%B9%A0%E6%83%AF%E5%9C%A8-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E5%BC%80%E5%8F%91%E3%80%81%E9%83%A8%E7%BD%B2%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%BE%88%E5%A4%9A%E4%BA%BA%E9%83%BD%E6%9B%B4%E6%84%BF%E6%84%8F%E6%8A%8A%E6%96%B9%E6%B3%95%E5%8C%BA%E7%A7%B0%E5%91%BC%E4%B8%BA%E2%80%9C%E6%B0%B8%E4%B9%85%E4%BB%A3%E2%80%9D%EF%BC%88Permanent-Generation%EF%BC%89%EF%BC%8C%E6%88%96%E5%B0%86%E4%B8%A4%E8%80%85%E6%B7%B7%E4%B8%BA%E4%B8%80%E8%B0%88%E3%80%82%E6%9C%AC%E8%B4%A8%E4%B8%8A%E8%BF%99%E4%B8%A4%E8%80%85%E5%B9%B6%E4%B8%8D%E6%98%AF%E7%AD%89%E4%BB%B7%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BB%85%E4%BB%85%E6%98%AF%E5%BD%93%E6%97%B6%E7%9A%84HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE-%E8%AE%A1%E5%9B%A2%E9%98%9F%E9%80%89%E6%8B%A9%E6%8A%8A%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%88%86%E4%BB%A3%E8%AE%BE%E8%AE%A1%E6%89%A9%E5%B1%95%E8%87%B3%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E4%BD%BF%E7%94%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E8%80%8C%E5%B7%B2%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%BD%BF%E5%BE%97-HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%83%BD%E5%A4%9F%E5%83%8F%E7%AE%A1%E7%90%86Java%E5%A0%86%E4%B8%80%E6%A0%B7%E7%AE%A1%E7%90%86%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%EF%BC%8C%E7%9C%81%E5%8E%BB%E4%B8%93%E9%97%A8%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BC%96%E5%86%99%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A3%E7%A0%81%E7%9A%84-%E5%B7%A5%E4%BD%9C%E3%80%82%E4%BD%86%E6%98%AF%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AD%AC%E5%A6%82BEA-JRockit%E3%80%81IBM-J9%E7%AD%89%E6%9D%A5%E8%AF%B4%EF%BC%8C%E6%98%AF%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E6%A6%82%E5%BF%B5%E7%9A%84%E3%80%82%E5%8E%9F%E5%88%99-%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E5%B1%9E%E4%BA%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%8C%E4%B8%8D%E5%8F%97%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E7%AE%A1%E6%9D%9F%EF%BC%8C%E5%B9%B6%E4%B8%8D%E8%A6%81%E6%B1%82%E7%BB%9F%E4%B8%80%E3%80%82%E4%BD%86%E7%8E%B0%E5%9C%A8%E5%9B%9E%E5%A4%B4-%E6%9D%A5%E7%9C%8B%EF%BC%8C%E5%BD%93%E5%B9%B4%E4%BD%BF%E7%94%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%B3%E5%AE%9A%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%B8%BB%E6%84%8F%EF%BC%8C%E8%BF%99%E7%A7%8D%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%87%B4%E4%BA%86Java%E5%BA%94%E7%94%A8%E6%9B%B4%E5%AE%B9%E6%98%93%E9%81%87%E5%88%B0-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%9C%89-XX%EF%BC%9AMaxPermSize%E7%9A%84%E4%B8%8A%E9%99%90%EF%BC%8C%E5%8D%B3%E4%BD%BF%E4%B8%8D%E8%AE%BE%E7%BD%AE%E4%B9%9F%E6%9C%89%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%EF%BC%8C%E8%80%8CJ9%E5%92%8CJRockit%E5%8F%AA%E8%A6%81-%E6%B2%A1%E6%9C%89%E8%A7%A6%E7%A2%B0%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%8F%AF%E7%94%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%8A%E9%99%90%EF%BC%8C%E4%BE%8B%E5%A6%8232%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%844GB%E9%99%90%E5%88%B6%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%87%BA%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%8C%E8%80%8C%E4%B8%94%E6%9C%89%E6%9E%81%E5%B0%91%E6%95%B0%E6%96%B9%E6%B3%95-%EF%BC%88%E4%BE%8B%E5%A6%82String-intern-%EF%BC%89%E4%BC%9A%E5%9B%A0%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%8E%9F%E5%9B%A0%E8%80%8C%E5%AF%BC%E8%87%B4%E4%B8%8D%E5%90%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8B%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E8%A1%A8%E7%8E%B0%E3%80%82%E5%BD%93Oracle%E6%94%B6%E8%B4%ADBEA%E8%8E%B7%E5%BE%97%E4%BA%86-JRockit%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E5%90%8E%EF%BC%8C%E5%87%86%E5%A4%87%E6%8A%8AJRockit%E4%B8%AD%E7%9A%84%E4%BC%98%E7%A7%80%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%AD%AC%E5%A6%82Java-Mission-Control%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%A7%BB%E6%A4%8D%E5%88%B0HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%B6%EF%BC%8C%E4%BD%86%E5%9B%A0%E4%B8%BA%E4%B8%A4%E8%80%85%E5%AF%B9%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%B7%AE%E5%BC%82%E8%80%8C%E9%9D%A2%E4%B8%B4%E8%AF%B8%E5%A4%9A%E5%9B%B0%E9%9A%BE%E3%80%82%E8%80%83%E8%99%91%E5%88%B0HotSpot%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%91%E5%B1%95%EF%BC%8C%E5%9C%A8JDK-6%E7%9A%84-%E6%97%B6%E5%80%99HotSpot%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%B0%B1%E6%9C%89%E6%94%BE%E5%BC%83%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%8C%E9%80%90%E6%AD%A5%E6%94%B9%E4%B8%BA%E9%87%87%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%EF%BC%88Native-Memory%EF%BC%89%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E8%AE%A1-%E5%88%92%E4%BA%86-1-%EF%BC%8C-x3D-x3D-%E5%88%B0%E4%BA%86JDK-7%E7%9A%84HotSpot%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%8A%8A%E5%8E%9F%E6%9C%AC%E6%94%BE%E5%9C%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%AD%89%E7%A7%BB%E5%87%BA%EF%BC%8C%E8%80%8C%E5%88%B0%E4%BA%86-JDK-8%EF%BC%8C%E7%BB%88%E4%BA%8E%E5%AE%8C%E5%85%A8%E5%BA%9F%E5%BC%83%E4%BA%86%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E6%94%B9%E7%94%A8%E4%B8%8EJRockit%E3%80%81J9%E4%B8%80%E6%A0%B7%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89%E6%9D%A5%E4%BB%A3%E6%9B%BF%EF%BC%8C%E6%8A%8AJDK-7%E4%B8%AD%E6%B0%B8%E4%B9%85%E4%BB%A3%E8%BF%98%E5%89%A9%E4%BD%99%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%BB%E8%A6%81%E6%98%AF%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%89%E5%85%A8%E9%83%A8%E7%A7%BB%E5%88%B0%E5%85%83%E7%A9%BA%E9%97%B4%E4%B8%AD%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.28.</span> <span class="toc-text">说到方法区，不得不提一下&#x3D;&#x3D;“永久代”&#x3D;&#x3D;这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设 计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则 上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头 来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到 内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，&#x3D;&#x3D;到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E5%AF%B9%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%98%AF%E9%9D%9E%E5%B8%B8%E5%AE%BD%E6%9D%BE%E7%9A%84%EF%BC%8C%E9%99%A4%E4%BA%86%E5%92%8CJava%E5%A0%86%E4%B8%80%E6%A0%B7%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%92%8C%E5%8F%AF%E4%BB%A5%E9%80%89-%E6%8B%A9%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%88%96%E8%80%85%E5%8F%AF%E6%89%A9%E5%B1%95%E5%A4%96%EF%BC%8C%E7%94%9A%E8%87%B3%E8%BF%98%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%B8%8D%E5%AE%9E%E7%8E%B0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E3%80%82%E7%9B%B8%E5%AF%B9%E8%80%8C%E8%A8%80%EF%BC%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%A1%8C%E4%B8%BA%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%8C%BA%E5%9F%9F%E7%9A%84-%E7%A1%AE%E6%98%AF%E6%AF%94%E8%BE%83%E5%B0%91%E5%87%BA%E7%8E%B0%E7%9A%84%EF%BC%8C%E4%BD%86%E5%B9%B6%E9%9D%9E%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E4%BA%86%E6%96%B9%E6%B3%95%E5%8C%BA%E5%B0%B1%E5%A6%82%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%80%E6%A0%B7%E2%80%9C%E6%B0%B8%E4%B9%85%E2%80%9D%E5%AD%98%E5%9C%A8%E4%BA%86%E3%80%82-x3D-x3D-%E8%BF%99%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%9E-%E6%94%B6%E7%9B%AE%E6%A0%87%E4%B8%BB%E8%A6%81%E6%98%AF%E9%92%88%E5%AF%B9%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%9B%9E%E6%94%B6%E5%92%8C%E5%AF%B9%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8D%B8%E8%BD%BD%EF%BC%8C-x3D-x3D-%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%E8%BF%99%E4%B8%AA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%9E%E6%94%B6%E6%95%88%E6%9E%9C%E6%AF%94%E8%BE%83%E9%9A%BE%E4%BB%A4%E4%BA%BA%E6%BB%A1%E6%84%8F%EF%BC%8C%E5%B0%A4-%E5%85%B6%E6%98%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8D%B8%E8%BD%BD%EF%BC%8C%E6%9D%A1%E4%BB%B6%E7%9B%B8%E5%BD%93%E8%8B%9B%E5%88%BB%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BF%99%E9%83%A8%E5%88%86%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%89%E6%97%B6%E5%8F%88%E7%A1%AE%E5%AE%9E%E6%98%AF%E5%BF%85%E8%A6%81%E7%9A%84%E3%80%82%E4%BB%A5%E5%89%8DSun%E5%85%AC%E5%8F%B8%E7%9A%84Bug%E5%88%97-%E8%A1%A8%E4%B8%AD%EF%BC%8C%E6%9B%BE%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E8%8B%A5%E5%B9%B2%E4%B8%AA%E4%B8%A5%E9%87%8D%E7%9A%84Bug%E5%B0%B1%E6%98%AF%E7%94%B1%E4%BA%8E%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E6%AD%A4%E5%8C%BA%E5%9F%9F%E6%9C%AA%E5%AE%8C%E5%85%A8%E5%9B%9E%E6%94%B6%E8%80%8C%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98-%E6%B3%84%E6%BC%8F%E3%80%82"><span class="toc-number">1.2.1.29.</span> <span class="toc-text">《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。&#x3D;&#x3D;这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，&#x3D;&#x3D;一般来说这个区域的回收效果比较难令人满意，尤 其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列 表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E7%9A%84%E8%A7%84%E5%AE%9A%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%96%B9%E6%B3%95%E5%8C%BA%E6%97%A0%E6%B3%95%E6%BB%A1%E8%B6%B3%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%9C%80%E6%B1%82%E6%97%B6%EF%BC%8C%E5%B0%86%E6%8A%9B%E5%87%BA-OutOfMemoryError%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">1.2.1.30.</span> <span class="toc-text">根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">1.2.1.31.</span> <span class="toc-text">2.2.6   运行时常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88Runtime-Constant-Pool-%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E3%80%82Class-%E6%96%87%E4%BB%B6%E4%B8%AD%E9%99%A4%E4%BA%86%E6%9C%89%E7%B1%BB%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%A5%E5%8F%A3%E7%AD%89%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E4%B8%80%E9%A1%B9%E4%BF%A1%E6%81%AF%E6%98%AF%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%AD%98%E6%94%BE%E7%BC%96%E8%AF%91%E6%9C%9F%E7%94%9F%E6%88%90%E7%9A%84%E5%90%84%E7%A7%8D%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8E%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%EF%BC%8C%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E5%B0%86%E5%9C%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%90%8E%E5%AD%98%E6%94%BE%E5%88%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E4%B8%AD%E3%80%82"><span class="toc-number">1.2.1.32.</span> <span class="toc-text">运行时常量池（Runtime Constant Pool )  是方法区的一部分。Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E4%BA%8EClass%E6%96%87%E4%BB%B6%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%88%E8%87%AA%E7%84%B6%E4%B9%9F%E5%8C%85%E6%8B%AC%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E7%9A%84%E6%A0%BC%E5%BC%8F%E9%83%BD%E6%9C%89%E4%B8%A5%E6%A0%BC%E8%A7%84%E5%AE%9A%EF%BC%8C%E5%A6%82%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E7%94%A8-%E4%BA%8E%E5%AD%98%E5%82%A8%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%83%BD%E5%BF%85%E9%A1%BB%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83%E4%B8%8A%E7%9A%84%E8%A6%81%E6%B1%82%E6%89%8D%E4%BC%9A%E8%A2%AB%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%A4%E5%8F%AF%E3%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%86%E5%AF%B9%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C-%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%81%9A%E4%BB%BB%E4%BD%95%E7%BB%86%E8%8A%82%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%8F%90%E4%BE%9B%E5%95%86%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9C%80%E8%A6%81%E6%9D%A5%E5%AE%9E%E7%8E%B0-%E8%BF%99%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8C%E4%B8%8D%E8%BF%87%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%EF%BC%8C%E9%99%A4%E4%BA%86%E4%BF%9D%E5%AD%98Class%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8F%8F%E8%BF%B0%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E5%A4%96%EF%BC%8C%E8%BF%98%E4%BC%9A%E6%8A%8A%E7%94%B1%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E7%BF%BB%E8%AF%91%E5%87%BA%E6%9D%A5-%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E4%B9%9F%E5%AD%98%E5%82%A8%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD-1-%E3%80%82"><span class="toc-number">1.2.1.33.</span> <span class="toc-text">Java虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用 于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池， 《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现 这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来 的直接引用也存储在运行时常量池中[1]。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9B%B8%E5%AF%B9%E4%BA%8EClass%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%89%B9%E5%BE%81%E6%98%AF%E5%85%B7%E5%A4%87%E5%8A%A8%E6%80%81%E6%80%A7%EF%BC%8CJava%E8%AF%AD%E8%A8%80%E5%B9%B6%E4%B8%8D%E8%A6%81%E6%B1%82%E5%B8%B8%E9%87%8F-%E4%B8%80%E5%AE%9A%E5%8F%AA%E6%9C%89%E7%BC%96%E8%AF%91%E6%9C%9F%E6%89%8D%E8%83%BD%E4%BA%A7%E7%94%9F%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%B9%B6%E9%9D%9E%E9%A2%84%E7%BD%AE%E5%85%A5Class%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E5%86%85%E5%AE%B9%E6%89%8D%E8%83%BD%E8%BF%9B%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8-%E9%87%8F%E6%B1%A0%EF%BC%8C-x3D-x3D-%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%86%E6%96%B0%E7%9A%84%E5%B8%B8%E9%87%8F%E6%94%BE%E5%85%A5%E6%B1%A0%E4%B8%AD%EF%BC%8C%E8%BF%99%E7%A7%8D%E7%89%B9%E6%80%A7%E8%A2%AB%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%88%A9%E7%94%A8%E5%BE%97%E6%AF%94%E8%BE%83%E5%A4%9A%E7%9A%84%E4%BE%BF%E6%98%AFString%E7%B1%BB%E7%9A%84-intern-%E6%96%B9%E6%B3%95%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.34.</span> <span class="toc-text">运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，&#x3D;&#x3D;运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的 intern()方法。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E6%97%A2%E7%84%B6%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E8%87%AA%E7%84%B6%E5%8F%97%E5%88%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%8C%E5%BD%93%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%97%A0%E6%B3%95%E5%86%8D%E7%94%B3%E8%AF%B7%E5%88%B0%E5%86%85%E5%AD%98-%E6%97%B6%E4%BC%9A%E6%8A%9B%E5%87%BAOutOfMemoryError%E5%BC%82%E5%B8%B8%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.35.</span> <span class="toc-text">&#x3D;&#x3D;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.2.1.36.</span> <span class="toc-text">2.2.7    直接内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88Direct-Memory%EF%BC%89%E5%B9%B6%E4%B8%8D%E6%98%AF%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E3%80%8AJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E4%B8%AD-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%82%E4%BD%86%E6%98%AF%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E4%B9%9F%E8%A2%AB%E9%A2%91%E7%B9%81%E5%9C%B0%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%80%8C%E4%B8%94%E4%B9%9F%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4OutOfMemoryError%E5%BC%82%E5%B8%B8%E5%87%BA%E7%8E%B0%EF%BC%8C%E6%89%80-%E4%BB%A5%E6%88%91%E4%BB%AC%E6%94%BE%E5%88%B0%E8%BF%99%E9%87%8C%E4%B8%80%E8%B5%B7%E8%AE%B2%E8%A7%A3%E3%80%82"><span class="toc-number">1.2.1.37.</span> <span class="toc-text">直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8JDK-1-4%E4%B8%AD%E6%96%B0%E5%8A%A0%E5%85%A5%E4%BA%86-x3D-x3D-NIO%EF%BC%88New-Input-x2F-Output%EF%BC%89%E7%B1%BB-x3D-x3D-%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86-x3D-x3D-%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E9%80%9A%E9%81%93%EF%BC%88Channel%EF%BC%89%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA-%EF%BC%88Buffer%EF%BC%89%E7%9A%84I-x2F-O%E6%96%B9%E5%BC%8F-x3D-x3D-%EF%BC%8C-x3D-x3D-%E5%AE%83%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Native%E5%87%BD%E6%95%B0%E5%BA%93%E7%9B%B4%E6%8E%A5%E5%88%86%E9%85%8D%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98-x3D-x3D-%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%9C%A8Java%E5%A0%86%E9%87%8C%E9%9D%A2%E7%9A%84-DirectByteBuffer%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%BF%99%E5%9D%97%E5%86%85%E5%AD%98%E7%9A%84%E5%BC%95%E7%94%A8%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%E3%80%82-x3D-x3D-%E8%BF%99%E6%A0%B7%E8%83%BD%E5%9C%A8%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%98%BE%E8%91%97%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%81%BF%E5%85%8D%E4%BA%86-%E5%9C%A8Java%E5%A0%86%E5%92%8CNative%E5%A0%86%E4%B8%AD%E6%9D%A5%E5%9B%9E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E3%80%82-x3D-x3D"><span class="toc-number">1.2.1.38.</span> <span class="toc-text">在JDK 1.4中新加入了&#x3D;&#x3D;NIO（New Input&#x2F;Output）类&#x3D;&#x3D;，引入了&#x3D;&#x3D;一种基于通道（Channel）与缓冲区 （Buffer）的I&#x2F;O方式&#x3D;&#x3D;，&#x3D;&#x3D;它可以使用Native函数库直接分配堆外内存&#x3D;&#x3D;，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。&#x3D;&#x3D;这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%84%B6%EF%BC%8C%E6%9C%AC%E6%9C%BA%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8D%E4%BC%9A%E5%8F%97%E5%88%B0Java%E5%A0%86%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%8C%E4%BD%86%E6%98%AF%EF%BC%8C%E6%97%A2%E7%84%B6%E6%98%AF%E5%86%85%E5%AD%98%EF%BC%8C%E5%88%99%E8%82%AF%E5%AE%9A%E8%BF%98%E6%98%AF%E4%BC%9A%E5%8F%97%E5%88%B0-%E6%9C%AC%E6%9C%BA%E6%80%BB%E5%86%85%E5%AD%98%EF%BC%88%E5%8C%85%E6%8B%AC%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E3%80%81SWAP%E5%88%86%E5%8C%BA%E6%88%96%E8%80%85%E5%88%86%E9%A1%B5%E6%96%87%E4%BB%B6%EF%BC%89%E5%A4%A7%E5%B0%8F%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%AF%BB%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%8D%E5%8A%A1-%E5%99%A8%E7%AE%A1%E7%90%86%E5%91%98%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E5%8E%BB%E8%AE%BE%E7%BD%AE-Xmx%E7%AD%89%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BD%86%E7%BB%8F%E5%B8%B8%E5%BF%BD%E7%95%A5%E6%8E%89%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%BF%E5%BE%97-%E5%90%84%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%80%BB%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%EF%BC%88%E5%8C%85%E6%8B%AC%E7%89%A9%E7%90%86%E7%9A%84%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%89%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%AF%BC%E8%87%B4%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E6%97%B6%E5%87%BA%E7%8E%B0-OutOfMemoryError%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">1.2.1.39.</span> <span class="toc-text">显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-HotSpot-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.3 HotSpot 虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.3.1  对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E6%98%AF%E4%B8%80%E9%97%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%EF%BC%8CJava%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%97%A0%E6%97%B6%E6%97%A0%E5%88%BB%E9%83%BD%E6%9C%89%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%88%9B%E5%BB%BA%E5%87%BA%E6%9D%A5%E3%80%82%E5%9C%A8%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2-%E4%B8%8A%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%80%9A%E5%B8%B8%EF%BC%88%E4%BE%8B%E5%A4%96%EF%BC%9A%E5%A4%8D%E5%88%B6%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%80%E4%B8%AAnew%E5%85%B3%E9%94%AE%E5%AD%97%E8%80%8C%E5%B7%B2%EF%BC%8C%E8%80%8C%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E6%96%87-%E4%B8%AD%E8%AE%A8%E8%AE%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%99%90%E4%BA%8E%E6%99%AE%E9%80%9AJava%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%8D%E5%8C%85%E6%8B%AC%E6%95%B0%E7%BB%84%E5%92%8CClass%E5%AF%B9%E8%B1%A1%E7%AD%89%EF%BC%89%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E4%B8%80%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面 上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文 中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%BD%93Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%81%87%E5%88%B0%E4%B8%80%E6%9D%A1%E5%AD%97%E8%8A%82%E7%A0%81new%E6%8C%87%E4%BB%A4%E6%97%B6%EF%BC%8C%E9%A6%96%E5%85%88%E5%B0%86%E5%8E%BB%E6%A3%80%E6%9F%A5%E8%BF%99%E4%B8%AA%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E8%83%BD%E5%9C%A8%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%AE%9A%E4%BD%8D%E5%88%B0-%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%A3%80%E6%9F%A5%E8%BF%99%E4%B8%AA%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%BB%A3%E8%A1%A8%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%B7%B2%E8%A2%AB%E5%8A%A0%E8%BD%BD%E3%80%81%E8%A7%A3%E6%9E%90%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E9%82%A3-%E5%BF%85%E9%A1%BB%E5%85%88%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%BA%94%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-x3D-x3D-%EF%BC%8C%E8%AF%A6%E6%83%85%E8%A7%81%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">&#x3D;&#x3D;当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程&#x3D;&#x3D;，详情见第七章</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5%E9%80%9A%E8%BF%87%E5%90%8E%EF%BC%8C%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%86%E4%B8%BA%E6%96%B0%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E3%80%82%E5%AF%B9%E8%B1%A1%E6%89%80%E9%9C%80%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%9C%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E4%BE%BF%E5%8F%AF%E4%BB%A5%E5%AE%8C%E5%85%A8%E7%A1%AE%E5%AE%9A%EF%BC%8C-x3D-x3D-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%AE%9E%E9%99%85%E4%B8%8A%E4%BE%BF%E7%AD%89%E5%90%8C%E4%BA%8E%E6%8A%8A%E4%B8%80%E5%9D%97%E7%A1%AE%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%86%85%E5%AD%98%E4%BB%8Ejava%E5%A0%86%E5%88%92%E5%88%86%E5%87%BA%E6%9D%A5%E3%80%82-x3D-x3D-%E5%81%87%E8%AE%BEjava%E5%A0%86%E4%B8%AD%E5%86%85%E7%B2%97%E4%BD%A0%E6%98%AF%E7%BB%9D%E5%AF%B9%E8%A7%84%E6%95%B4%E7%9A%84%EF%BC%8C%E6%89%80%E6%9C%89%E8%A2%AB%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E5%86%85%E5%AD%98%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E8%BE%B9%EF%BC%8C%E7%A9%BA%E9%97%B2%E7%9A%84%E5%86%85%E5%AD%98%E8%A2%AB%E6%94%BE%E5%9C%A8%E5%8F%A6%E4%B8%80%E8%BE%B9%EF%BC%8C-x3D-x3D-%E4%B8%AD%E9%97%B4%E6%94%BE%E7%9D%80%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%88%86%E8%A7%A3%E7%82%B9%E7%9A%84%E6%8C%87%E7%A4%BA%E5%99%A8%EF%BC%8C-x3D-x3D-%E9%82%A3%E6%89%80%E5%88%86%E9%85%8D%E5%86%85%E7%B2%97%E4%BD%A0%E5%B0%B1%E4%BB%85%E4%BB%85%E6%98%AF-x3D-x3D-%E6%8A%8A%E9%82%A3%E4%B8%AA%E6%8C%87%E9%92%88%E5%90%91%E7%A9%BA%E9%97%B2%E6%96%B9%E5%90%91%E6%8C%AA%E5%8A%A8%E4%B8%80%E6%AE%B5%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E7%9B%B8%E7%AD%89%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%A7%B0%E4%B8%BA%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%88Bump-the-pointer-%EF%BC%89-x3D-x3D-%E4%BD%86%E5%A6%82%E6%9E%9CJava%E5%A0%86%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B9%B6%E4%B8%8D%E6%98%AF%E8%A7%84%E6%95%B4%E7%9A%84%EF%BC%8C%E5%B7%B2%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%92%8C%E7%A9%BA%E9%97%B2%E7%9A%84%E5%86%85%E5%AD%98%E7%9B%B8%E4%BA%92%E4%BA%A4%E9%94%99%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E9%82%A3-%E5%B0%B1%E6%B2%A1%E6%9C%89%E5%8A%9E%E6%B3%95%E7%AE%80%E5%8D%95%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%E4%BA%86%EF%BC%8C-x3D-x3D-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%B1%E5%BF%85%E9%A1%BB%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%EF%BC%8C%E8%AE%B0%E5%BD%95%E4%B8%8A%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%9D%97%E6%98%AF%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%8C%E5%9C%A8%E5%88%86-%E9%85%8D%E7%9A%84%E6%97%B6%E5%80%99%E4%BB%8E%E5%88%97%E8%A1%A8%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E5%9D%97%E8%B6%B3%E5%A4%9F%E5%A4%A7%E7%9A%84%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8%E4%B8%8A%E7%9A%84%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%BF%99%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%A7%B0-%E4%B8%BA%E2%80%9C%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E2%80%9D%EF%BC%88Free-List%EF%BC%89%E3%80%82-x3D-x3D"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，&#x3D;&#x3D;为对象分配空间的任务实际上便等同于把一块确定大小的内存从java堆划分出来。&#x3D;&#x3D;假设java堆中内粗你是绝对规整的，所有被使用过的内存都放在一边，空闲的内存被放在另一边，&#x3D;&#x3D;中间放着一个指针作为分解点的指示器，&#x3D;&#x3D;那所分配内粗你就仅仅是&#x3D;&#x3D;把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump the pointer ）&#x3D;&#x3D; 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，&#x3D;&#x3D;虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%94%B1Java%E5%A0%86%E6%98%AF%E5%90%A6%E8%A7%84%E6%95%B4%E5%86%B3%E5%AE%9A%EF%BC%8C%E8%80%8CJava%E5%A0%86%E6%98%AF%E5%90%A6%E8%A7%84%E6%95%B4%E5%8F%88%E7%94%B1%E6%89%80%E9%87%87%E7%94%A8-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%98%AF%E5%90%A6%E5%B8%A6%E6%9C%89%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9%E6%95%B4%E7%90%86%EF%BC%88Compact%EF%BC%89%E7%9A%84%E8%83%BD%E5%8A%9B%E5%86%B3%E5%AE%9A%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E5%BD%93%E4%BD%BF%E7%94%A8Serial%E3%80%81ParNew%E7%AD%89%E5%B8%A6%E5%8E%8B%E7%BC%A9-%E6%95%B4%E7%90%86%E8%BF%87%E7%A8%8B%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%87%87%E7%94%A8%E7%9A%84%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%98%AF%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E%EF%BC%8C%E6%97%A2%E7%AE%80%E5%8D%95%E5%8F%88%E9%AB%98%E6%95%88%EF%BC%9B%E8%80%8C%E5%BD%93%E4%BD%BF%E7%94%A8CMS%E8%BF%99%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%B8%85%E9%99%A4-%EF%BC%88Sweep%EF%BC%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8%E6%97%B6%EF%BC%8C%E7%90%86%E8%AE%BA%E4%B8%8A-1-%E5%B0%B1%E5%8F%AA%E8%83%BD%E9%87%87%E7%94%A8%E8%BE%83%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E3%80%82"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用 的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩 整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除 （Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E6%9C%89%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%98%AF%E9%9D%9E%E5%B8%B8%E9%A2%91%E7%B9%81%E7%9A%84%E8%A1%8C-%E4%B8%BA%EF%BC%8C%E5%8D%B3%E4%BD%BF%E4%BB%85%E4%BB%85%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%E4%B9%9F%E5%B9%B6%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E6%AD%A3%E5%9C%A8%E7%BB%99%E5%AF%B9%E8%B1%A1-A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%8C%E6%8C%87%E9%92%88%E8%BF%98%E6%B2%A1%E6%9D%A5%E5%BE%97%E5%8F%8A%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%AF%B9%E8%B1%A1B%E5%8F%88%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BA%86%E5%8E%9F%E6%9D%A5%E7%9A%84%E6%8C%87%E9%92%88%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%83%85%E5%86%B5%E3%80%82%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98-%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%8F%AF%E9%80%89%E6%96%B9%E6%A1%88%EF%BC%9A-x3D-x3D-%E4%B8%80%E7%A7%8D%E6%98%AF%E5%AF%B9%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8A%A8%E4%BD%9C%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%AE%9E%E9%99%85%E4%B8%8A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E9%87%87%E7%94%A8CAS%E9%85%8D%E4%B8%8A%E5%A4%B1%E8%B4%A5-%E9%87%8D%E8%AF%95%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BF%9D%E8%AF%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9B%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E6%98%AF%E6%8A%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8A%A8%E4%BD%9C%E6%8C%89%E7%85%A7%E7%BA%BF%E7%A8%8B%E5%88%92%E5%88%86%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%A9%BA%E9%97%B4%E4%B9%8B%E4%B8%AD%E8%BF%9B-%E8%A1%8C%EF%BC%8C%E5%8D%B3%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8Java%E5%A0%86%E4%B8%AD%E9%A2%84%E5%85%88%E5%88%86%E9%85%8D%E4%B8%80%E5%B0%8F%E5%9D%97%E5%86%85%E5%AD%98%EF%BC%8C%E7%A7%B0%E4%B8%BA%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E7%BC%93%E5%86%B2%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%8CTLAB%EF%BC%89-x3D-x3D-%EF%BC%8C%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A6%81%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%8C%E5%B0%B1%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E5%88%86%E9%85%8D%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%94%A8%E5%AE%8C-%E4%BA%86%EF%BC%8C%E5%88%86%E9%85%8D%E6%96%B0%E7%9A%84%E7%BC%93%E5%AD%98%E5%8C%BA%E6%97%B6%E6%89%8D%E9%9C%80%E8%A6%81%E5%90%8C%E6%AD%A5%E9%94%81%E5%AE%9A%E3%80%82%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8TLAB%EF%BC%8C%E5%8F%AF%E4%BB%A5-x3D-x3D-%E9%80%9A%E8%BF%87-XX%EF%BC%9A-x2F-UseTLAB-x3D-x3D-%E5%8F%82%E6%95%B0%E6%9D%A5-%E8%AE%BE%E5%AE%9A%E3%80%82"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：&#x3D;&#x3D;一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）&#x3D;&#x3D;，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以&#x3D;&#x3D;通过-XX：+&#x2F;-UseTLAB&#x3D;&#x3D;参数来 设定。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%85%E9%A1%BB%E5%B0%86%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%88%E4%BD%86%E4%B8%8D%E5%8C%85%E6%8B%AC%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%89%E9%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E9%9B%B6%E5%80%BC-x3D-x3D-%EF%BC%8C%E5%A6%82%E6%9E%9C-%E4%BD%BF%E7%94%A8%E4%BA%86TLAB%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%BF%99%E4%B8%80%E9%A1%B9%E5%B7%A5%E4%BD%9C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%89%8D%E8%87%B3TLAB%E5%88%86%E9%85%8D%E6%97%B6%E9%A1%BA%E4%BE%BF%E8%BF%9B%E8%A1%8C%E3%80%82%E8%BF%99%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BF%9D%E8%AF%81%E4%BA%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5-%E5%9C%A8Java%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%B5%8B%E5%88%9D%E5%A7%8B%E5%80%BC%E5%B0%B1%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%83%BD%E8%AE%BF%E9%97%AE%E5%88%B0%E8%BF%99%E4%BA%9B%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E9%9B%B6%E5%80%BC%E3%80%82"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">&#x3D;&#x3D;内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值&#x3D;&#x3D;，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E6%8E%A5%E4%B8%8B%E6%9D%A5%EF%BC%8CJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%98%E8%A6%81%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%BF%85%E8%A6%81%E7%9A%84%E8%AE%BE%E7%BD%AE-x3D-x3D-%EF%BC%8C%E4%BE%8B%E5%A6%82%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E3%80%81%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%89%BE%E5%88%B0-%E7%B1%BB%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E7%A0%81%E4%BC%9A%E5%BB%B6%E5%90%8E%E5%88%B0%E7%9C%9F%E6%AD%A3%E8%B0%83%E7%94%A8Object-hashCode-%E6%96%B9%E6%B3%95%E6%97%B6%E6%89%8D-%E8%AE%A1%E7%AE%97%EF%BC%89%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84GC%E5%88%86%E4%BB%A3%E5%B9%B4%E9%BE%84%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82%E8%BF%99%E4%BA%9B%E4%BF%A1%E6%81%AF%E5%AD%98%E6%94%BE%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Object-Header%EF%BC%89%E4%B9%8B%E4%B8%AD%E3%80%82%E6%A0%B9%E6%8D%AE%E8%99%9A%E6%8B%9F-%E6%9C%BA%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%E6%98%AF%E5%90%A6%E5%90%AF%E7%94%A8%E5%81%8F%E5%90%91%E9%94%81%E7%AD%89%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BC%9A%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F%E3%80%82%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85-%E5%AE%B9%EF%BC%8C%E7%A8%8D%E5%90%8E%E4%BC%9A%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82"><span class="toc-number">1.2.2.8.</span> <span class="toc-text">&#x3D;&#x3D;接下来，Java虚拟机还要对对象进行必要的设置&#x3D;&#x3D;，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内 容，稍后会详细介绍。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8A%E9%9D%A2%E5%B7%A5%E4%BD%9C%E9%83%BD%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%A7%86%E8%A7%92%E6%9D%A5%E7%9C%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B7%B2%E7%BB%8F%E4%BA%A7%E7%94%9F%E4%BA%86%E3%80%82%E4%BD%86%E6%98%AF%E4%BB%8EJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A7%86-%E8%A7%92%E7%9C%8B%E6%9D%A5%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%89%8D%E5%88%9A%E5%88%9A%E5%BC%80%E5%A7%8B%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8D%B3Class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84-%E6%96%B9%E6%B3%95%E8%BF%98%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%97%E6%AE%B5%E9%83%BD-%E4%B8%BA%E9%BB%98%E8%AE%A4%E7%9A%84%E9%9B%B6%E5%80%BC%EF%BC%8C%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E7%9A%84%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E5%92%8C%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E4%B9%9F%E8%BF%98%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E9%A2%84%E5%AE%9A%E7%9A%84%E6%84%8F%E5%9B%BE%E6%9E%84%E9%80%A0%E5%A5%BD%E3%80%82%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%EF%BC%88%E7%94%B1%E5%AD%97%E8%8A%82-%E7%A0%81%E6%B5%81%E4%B8%ADnew%E6%8C%87%E4%BB%A4%E5%90%8E%E9%9D%A2%E6%98%AF%E5%90%A6%E8%B7%9F%E9%9A%8Finvokespecial%E6%8C%87%E4%BB%A4%E6%89%80%E5%86%B3%E5%AE%9A%EF%BC%8CJava%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E5%9C%A8%E9%81%87%E5%88%B0new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%9C%B0%E6%96%B9%E5%90%8C%E6%97%B6%E7%94%9F%E6%88%90-%E8%BF%99%E4%B8%A4%E6%9D%A1%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%BD%86%E5%A6%82%E6%9E%9C%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F%E4%BA%A7%E7%94%9F%E7%9A%84%E5%88%99%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%A6%82%E6%AD%A4%EF%BC%89%EF%BC%8C-x3D-x3D-new%E6%8C%87%E4%BB%A4%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%8E%A5%E7%9D%80%E6%89%A7%E8%A1%8C-%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8C%89%E7%85%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%84%8F%E6%84%BF%E5%AF%B9%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E7%9C%9F%E6%AD%A3%E5%8F%AF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%8D%E7%AE%97%E5%AE%8C%E5%85%A8%E8%A2%AB%E6%9E%84%E9%80%A0%E5%87%BA%E6%9D%A5%E3%80%82-x3D-x3D"><span class="toc-number">1.2.2.9.</span> <span class="toc-text">在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），&#x3D;&#x3D;new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.2.10.</span> <span class="toc-text">2.3.2  对象的布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%87%8C%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80%E5%8F%AF%E4%BB%A5%E5%88%92%E5%88%86%E4%B8%BA%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Header%EF%BC%89%E3%80%81%E5%AE%9E%E4%BE%8B-%E6%95%B0%E6%8D%AE%EF%BC%88Instance-Data%EF%BC%89%E5%92%8C%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88Padding%EF%BC%89%E3%80%82"><span class="toc-number">1.2.2.11.</span> <span class="toc-text">在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例 数据（Instance Data）和对齐填充（Padding）。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3.3  对象的访问定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%9E%E6%88%98-%EF%BC%9A-OutOfMemoryError-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4     实战 ：  OutOfMemoryError 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Java%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1    Java堆溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2  虚拟机栈和本地方法栈溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3    方法区和运行时常量池溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%9C%AC%E6%9C%BA%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4    本机直接内存溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E5%8F%AF%E9%80%9A%E8%BF%87-xx%EF%BC%9AmaxDirectMemorySize%E5%8F%82%E6%95%B0%E6%9D%A5%E6%8C%87%E5%AE%9A%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%8E%BB%E6%8C%87%E5%AE%9A%EF%BC%8C%E5%88%99%E9%BB%98%E8%AE%A4%E4%B8%8EJava%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%80%E8%87%B4%E3%80%82"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">直接内存的容量大小可通过-xx：maxDirectMemorySize参数来指定，如果不去指定，则默认与Java最大值一致。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.</span> <span class="toc-text">Chapter  3     垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%B8%8EC-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%B8%80%E5%A0%B5%E7%94%B1-%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%8A%80%E6%9C%AF%E6%89%80%E5%9B%B4%E6%88%90%E7%9A%84%E9%AB%98%E5%A2%99%EF%BC%8C%E5%A2%99%E5%A4%96%E9%9D%A2%E7%9A%84%E4%BA%BA%E6%83%B3%E8%BF%9B%E5%8E%BB%EF%BC%8C%E5%A2%99%E9%87%8C%E9%9D%A2%E7%9A%84%E4%BA%BA%E5%8D%B4%E6%83%B3%E5%87%BA%E6%9D%A5%E3%80%82"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">Java 与C++ 之间有一堵由 内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1   概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">那些内存需要回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">什么时候回收？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6-%E3%80%82"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">如何回收?。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%8C%BA%E5%9F%9F%E5%88%99%E6%9C%89%E7%9D%80%E5%BE%88%E6%98%BE%E8%91%97%E7%9A%84%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98%E4%B9%9F%E5%8F%AF%E8%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%A4%84%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E6%89%8D%E8%83%BD%E7%9F%A5%E9%81%93%E7%A8%8B%E5%BA%8F%E4%BC%9A%E5%88%9B%E5%BB%BA%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E6%97%B6%E6%98%AF%E5%8A%A8%E6%80%81%E7%9A%84%E3%80%82-x3D-x3D-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%89%80%E5%85%B3%E6%B3%A8%E7%9A%84%E6%AD%A3%E5%BC%8F%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E8%AF%A5%E7%AE%A1%E7%90%86-x3D-x3D-%E3%80%82"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">java 堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行时期，我们才能知道程序会创建哪些对象，创建对象，这部分的内存分配和回收时是动态的。&#x3D;&#x3D;垃圾收集器所关注的正式这部分内存该管理&#x3D;&#x3D;。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2    对象已死？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E8%BF%98%E2%80%9C%E5%AD%98%E6%B4%BB%E2%80%9C%E7%9D%80%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%B7%B2%E7%BB%8F%E2%80%9D%E6%AD%BB%E5%8E%BB%E2%80%9C%EF%BC%9F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">如何确定哪些对象还“存活“着，哪些已经”死去“？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.1    引用计数算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%8C%E6%AF%8F%E5%BD%93%E6%9C%89%E4%B8%80%E4%B8%AA%E5%9C%B0%E6%96%B9%E5%BC%95%E7%94%A8%E5%AE%83%E6%97%B6%EF%BC%8C%E8%AE%A1%E6%95%B0%E5%99%A8%E5%80%BC%E5%B0%B1%E5%8A%A0%E4%B8%80%EF%BC%9A%E5%BD%93%E5%BC%95%E7%94%A8%E5%A4%B1%E6%95%88%E6%97%B6%EF%BC%8C%E8%AE%A1%E6%95%B0%E5%99%A8%E5%80%BC%E5%B0%B1-1%EF%BC%9A%E4%BB%BB%E4%BD%95%E6%97%B6%E5%88%BB%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA0%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%82-x3D-x3D"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">&#x3D;&#x3D;在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一：当引用失效时，计数器值就-1：任何时刻计数器为0的对象就是不可能再被使用的。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BE%88%E9%9A%BE%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">引用计数很难解决对象之间相互循环引用的问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8%E5%B0%B1%E6%94%BE%E5%BC%83%E5%9B%9E%E6%94%B6%E5%AE%83%E4%BB%AC%EF%BC%8C%E8%BF%99%E4%B9%9F%E4%BB%8E%E4%BE%A7%E9%9D%A2%E8%AF%B4%E6%98%8E%E4%BA%86Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%80%9A%E8%BF%87%E8%AE%A1%E6%95%B0%E5%BC%95%E7%94%A8%E7%AE%97%E6%B3%95%E6%9D%A5%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E7%9A%84%E3%80%82"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过计数引用算法来判断对象是否存活的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">3.2.2      可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E4%B8%80%E7%B3%BB%E5%88%97-%E7%A7%B0%E4%B8%BA-%E2%80%9DGC-Roots%E2%80%9D-%E7%9A%84%E6%A0%B9%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%B5%B7%E5%A7%8B%E8%8A%82%E7%82%B9%E9%9B%86%EF%BC%8C%E4%BB%8E%E8%BF%99%E4%BA%9B%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E5%BE%80%E4%B8%8B%E6%90%9C%E7%B4%A2%EF%BC%8C%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B%E6%89%80%E8%B5%B0%E8%BF%87%E7%9A%84%E8%B7%AF%E5%BE%84%E7%A7%B0%E4%B8%BA%E2%80%9C%E5%BC%95%E7%94%A8%E9%93%BE%E2%80%9D%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%88%B0GC-Roots-%E9%97%B4%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%BC%95%E7%94%A8%E9%93%BE%E7%9B%B8%E8%BF%9E%EF%BC%8C-x3D-x3D-%E6%88%96%E8%80%85%E7%94%A8%E5%9B%BE%E8%AE%BA%E7%9A%84%E8%AF%9D%E8%AF%B4%E5%B0%B1%E6%98%AF%E4%BB%8EGC-Roots-%E5%88%B0%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E8%BE%BE%E6%97%B6%EF%BC%8C%E5%88%99%E8%AF%81%E6%98%8E%E6%AD%A4%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%82-x3D-x3D"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">这个算法的思路就是通过一系列 称为 ”GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系往下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到GC Roots 间没有任何引用链相连，&#x3D;&#x3D;或者用图论的话说就是从GC Roots  到这个对象不可达时，则证明此对象是不可能再被使用的。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8JAVA%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%AD%E9%87%8C%E9%9D%A2%EF%BC%8C%E5%9B%BA%E5%AE%9A%E5%8F%AF%E4%BD%9C%E4%B8%BAGC-Roots-%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8C%85%E6%8B%AC%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%EF%BC%9A"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">在JAVA技术体系中里面，固定可作为GC Roots 的对象包括以下几种：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-x3D-x3D-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E6%A0%88%E5%B8%A7%E4%B8%AD%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%89%E4%B8%AD%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1-x3D-x3D-%EF%BC%8C%E8%AD%AC%E5%A6%82%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%A0%88%E5%A0%86%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%8C%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.9.</span> <span class="toc-text">在&#x3D;&#x3D;虚拟机栈（栈帧中的本地变量表）中引用的对象&#x3D;&#x3D;，譬如各个线程被调用的方法栈堆中使用到的参数方法，局部变量，临时变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E7%B1%BB%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1-x3D-x3D-%EF%BC%8C%E8%AD%AC%E5%A6%82java%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.10.</span> <span class="toc-text">&#x3D;&#x3D;在方法区中类静态属性引用的对象&#x3D;&#x3D;，譬如java类的引用类型静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AD%AC%E5%A6%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%88String-Table%EF%BC%89%E9%87%8C%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.11.</span> <span class="toc-text">在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E4%B8%ADJNI%EF%BC%88%E5%8D%B3%E9%80%9A%E5%B8%B8%E6%89%80%E8%AF%B4%E7%9A%84Native%E6%96%B9%E6%B3%95%EF%BC%89%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.12.</span> <span class="toc-text">在本地方法栈中JNI（即通常所说的Native方法）引用的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E9%83%A8%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E5%A6%82%E5%9F%BA%E6%9C%AC%E4%B9%A6%E8%AE%B0%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84Class%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%80%E4%BA%9B%E5%B8%B8%E9%A9%BB%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%98%E6%9C%89%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.3.2.13.</span> <span class="toc-text">java虚拟机内部的引用，如基本书记类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%A2%AB%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%88synchronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89%E6%8C%81%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.14.</span> <span class="toc-text">所有被同步锁（synchronized关键字）持有的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E6%98%A0java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E9%83%A8%E6%83%85%E5%86%B5%E7%9A%84JMXBean%EF%BC%8CJVMT1%E4%B8%AD%E6%B3%A8%E5%86%8C%E7%9A%84%E5%9B%9E%E8%B0%83%EF%BC%8C%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E7%BC%93%E5%AD%98%E7%AD%89%E3%80%82"><span class="toc-number">1.3.2.15.</span> <span class="toc-text">反映java虚拟机内部情况的JMXBean，JVMT1中注册的回调，本地代码缓存等。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.16.</span> <span class="toc-text">3.2.3    再谈引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%BD%93%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E8%BF%98%E8%B6%B3%E5%A4%9F%E6%97%B6%EF%BC%8C%E8%83%BD%E4%BF%9D%E7%95%99%E5%9C%A8%E5%86%85%E5%AD%98%E4%B9%8B%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%86%85%E5%AD%98%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%90%8E%E4%BB%8D%E7%84%B6%E9%9D%9E%E5%B8%B8%E7%B4%A7%E5%BC%A0%EF%BC%8C%E9%82%A3%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%BC%83%E8%BF%99%E4%BA%9B%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E5%BE%88%E5%A4%9A%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E9%83%BD%E7%AC%A6%E5%90%88%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF%E3%80%82-x3D-x3D"><span class="toc-number">1.3.2.17.</span> <span class="toc-text">&#x3D;&#x3D;当内存空间还足够时，能保留在内存之中，如果内存在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的场景。&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C-x3D-x3D-%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%8C%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%8C%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8-x3D-x3D-4%E7%A7%8D%EF%BC%8C%E8%BF%99%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%BC%BA%E5%BA%A6%E4%B8%80%E6%AC%A1%E9%80%90%E6%B8%90%E5%87%8F%E5%BC%B1%E3%80%82"><span class="toc-number">1.3.2.18.</span> <span class="toc-text">java的引用，&#x3D;&#x3D;强引用，软引用，弱引用，和虚引用&#x3D;&#x3D;4种，这四种引用强度一次逐渐减弱。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-1-4%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.18.1.</span> <span class="toc-text">3.2.3.1    4种引用类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%BC%BA%E5%BC%95%E7%94%A8-x3D-x3D-%E6%98%AF%E6%9C%80%E4%BC%A0%E7%BB%9F%E7%9A%84%E2%80%9C%E5%BC%95%E7%94%A8%E2%80%9D%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%98%AF%E6%8C%87%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%AD%E6%99%AE%E9%81%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%8D%B3%E7%B1%BB%E4%BC%BC%E7%9A%84%E2%80%9CObject-obj-x3D-new-Object%EF%BC%88%EF%BC%89%E2%80%9D%E8%BF%99%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%8C-x3D-x3D-%E5%8F%AA%E8%A6%81%E5%BC%BA%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E8%BF%98%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B0%B1%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%9B%9E%E6%94%B6%E6%8E%89%E8%A2%AB%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1-x3D-x3D-%E3%80%82"><span class="toc-number">1.3.2.19.</span> <span class="toc-text">&#x3D;&#x3D;强引用&#x3D;&#x3D;是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似的“Object obj &#x3D; new Object（）”这种引用关系，&#x3D;&#x3D;只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%BA%9B%E8%BF%98%E6%9C%89%E7%94%A8%EF%BC%8C%E4%BD%86%E9%9D%9E%E5%BF%85%E9%A1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E5%8F%AA%E8%A2%AB%E8%BD%AF%E5%BC%95%E7%94%A8%E5%85%B3%E8%81%94%E7%9D%80%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%B0%86%E8%A6%81%E5%8F%91%E7%94%9F%E5%86%85-%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%E5%89%8D%EF%BC%8C%E4%BC%9A%E6%8A%8A%E8%BF%99%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%88%97%E8%BF%9B%E5%9B%9E%E6%94%B6%E8%8C%83%E5%9B%B4%E4%B9%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E6%AC%A1%E5%9B%9E%E6%94%B6%E8%BF%98%E6%B2%A1%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%8C-%E6%89%8D%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82%E5%9C%A8JDK-1-2%E7%89%88%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BE%9B%E4%BA%86SoftReference%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">1.3.2.20.</span> <span class="toc-text">软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E4%B9%9F%E6%98%AF%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%82%A3%E4%BA%9B%E9%9D%9E%E5%BF%85%E9%A1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E7%9A%84%E5%BC%BA%E5%BA%A6%E6%AF%94%E8%BD%AF%E5%BC%95%E7%94%A8%E6%9B%B4%E5%BC%B1%E4%B8%80%E4%BA%9B%EF%BC%8C%E8%A2%AB%E5%BC%B1%E5%BC%95%E7%94%A8%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AA-%E8%83%BD%E7%94%9F%E5%AD%98%E5%88%B0%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%8F%91%E7%94%9F%E4%B8%BA%E6%AD%A2%E3%80%82%E5%BD%93%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%BC%80%E5%A7%8B%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%BD%93%E5%89%8D%E5%86%85%E5%AD%98%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%9B%9E%E6%94%B6%E6%8E%89%E5%8F%AA-%E8%A2%AB%E5%BC%B1%E5%BC%95%E7%94%A8%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E5%9C%A8JDK-1-2%E7%89%88%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BE%9B%E4%BA%86WeakReference%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">1.3.2.21.</span> <span class="toc-text">弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E4%B9%9F%E7%A7%B0%E4%B8%BA%E2%80%9C%E5%B9%BD%E7%81%B5%E5%BC%95%E7%94%A8%E2%80%9D%E6%88%96%E8%80%85%E2%80%9C%E5%B9%BB%E5%BD%B1%E5%BC%95%E7%94%A8%E2%80%9D%EF%BC%8C%E5%AE%83%E6%98%AF%E6%9C%80%E5%BC%B1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%E3%80%82%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9C%89%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84-%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%AE%8C%E5%85%A8%E4%B8%8D%E4%BC%9A%E5%AF%B9%E5%85%B6%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4%E6%9E%84%E6%88%90%E5%BD%B1%E5%93%8D%EF%BC%8C%E4%B9%9F%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E8%99%9A%E5%BC%95%E7%94%A8%E6%9D%A5%E5%8F%96%E5%BE%97%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E3%80%82%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E8%99%9A-%E5%BC%95%E7%94%A8%E5%85%B3%E8%81%94%E7%9A%84%E5%94%AF%E4%B8%80%E7%9B%AE%E7%9A%84%E5%8F%AA%E6%98%AF%E4%B8%BA%E4%BA%86%E8%83%BD%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E6%94%B6%E9%9B%86%E5%99%A8%E5%9B%9E%E6%94%B6%E6%97%B6%E6%94%B6%E5%88%B0%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5%E3%80%82%E5%9C%A8JDK-1-2%E7%89%88%E4%B9%8B%E5%90%8E%E6%8F%90%E4%BE%9B-%E4%BA%86PhantomReference%E7%B1%BB%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%99%9A%E5%BC%95%E7%94%A8%E3%80%82"><span class="toc-number">1.3.2.22.</span> <span class="toc-text">虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1%EF%BC%9F"><span class="toc-number">1.3.2.23.</span> <span class="toc-text">3.2.4    生存还是死亡？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B3%E4%BD%BF%E5%9C%A8-x3D-x3D-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E4%B8%AD%E5%88%A4%E5%AE%9A%E4%B8%BA%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1-x3D-x3D-%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E2%80%9C%E9%9D%9E%E6%AD%BB%E4%B8%8D%E5%8F%AF%E2%80%9D%E7%9A%84%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E5%AE%83%E4%BB%AC%E6%9A%82%E6%97%B6%E8%BF%98%E5%A4%84%E4%BA%8E%E2%80%9C%E7%BC%93-%E5%88%91%E2%80%9D%E9%98%B6%E6%AE%B5%EF%BC%8C%E8%A6%81%E7%9C%9F%E6%AD%A3%E5%AE%A3%E5%91%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%EF%BC%8C%E8%87%B3%E5%B0%91%E8%A6%81%E7%BB%8F%E5%8E%86%E4%B8%A4%E6%AC%A1%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E5%9C%A8%E8%BF%9B%E8%A1%8C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E5%90%8E%E5%8F%91%E7%8E%B0%E6%B2%A1-%E6%9C%89%E4%B8%8EGC-Roots%E7%9B%B8%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BC%95%E7%94%A8%E9%93%BE%EF%BC%8C%E9%82%A3%E5%AE%83%E5%B0%86%E4%BC%9A%E8%A2%AB%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A0%87%E8%AE%B0%EF%BC%8C%E9%9A%8F%E5%90%8E%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%AD%9B%E9%80%89%EF%BC%8C%E7%AD%9B%E9%80%89%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E6%AD%A4%E5%AF%B9%E8%B1%A1%E6%98%AF-%E5%90%A6%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%A7%E8%A1%8Cfinalize-%E6%96%B9%E6%B3%95%E3%80%82%E5%81%87%E5%A6%82%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E8%A6%86%E7%9B%96finalize-%E6%96%B9%E6%B3%95%EF%BC%8C%E6%88%96%E8%80%85finalize-%E6%96%B9%E6%B3%95%E5%B7%B2%E7%BB%8F%E8%A2%AB%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E7%94%A8-%E8%BF%87%EF%BC%8C%E9%82%A3%E4%B9%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%86%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E9%83%BD%E8%A7%86%E4%B8%BA%E2%80%9C%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%A7%E8%A1%8C%E2%80%9D%E3%80%82"><span class="toc-number">1.3.2.24.</span> <span class="toc-text">即使在&#x3D;&#x3D;可达性分析算法中判定为不可达的对象&#x3D;&#x3D;，也不是“非死不可”的，这时候它们暂时还处于“缓 刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没 有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是 否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E5%88%A4%E5%AE%9A%E4%B8%BA%E7%A1%AE%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%A7%E8%A1%8Cfinalize-%E6%96%B9%E6%B3%95%EF%BC%8C%E9%82%A3%E4%B9%88%E8%AF%A5%E5%AF%B9%E8%B1%A1%E5%B0%86%E4%BC%9A%E8%A2%AB%E6%94%BE%E7%BD%AE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAF-Queue%E7%9A%84-%E9%98%9F%E5%88%97%E4%B9%8B%E4%B8%AD%EF%BC%8C%E5%B9%B6%E5%9C%A8%E7%A8%8D%E5%90%8E%E7%94%B1%E4%B8%80%E6%9D%A1%E7%94%B1%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%BB%BA%E7%AB%8B%E7%9A%84%E3%80%81%E4%BD%8E%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84Finalizer%E7%BA%BF%E7%A8%8B%E5%8E%BB%E6%89%A7%E8%A1%8C%E5%AE%83%E4%BB%AC%E7%9A%84finalize-%E6%96%B9%E6%B3%95%E3%80%82%E8%BF%99%E9%87%8C%E6%89%80%E8%AF%B4%E7%9A%84%E2%80%9C%E6%89%A7%E8%A1%8C%E2%80%9D%E6%98%AF%E6%8C%87%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BC%9A%E8%A7%A6%E5%8F%91%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%BD%86%E5%B9%B6%E4%B8%8D%E6%89%BF%E8%AF%BA%E4%B8%80%E5%AE%9A%E4%BC%9A%E7%AD%89%E5%BE%85%E5%AE%83%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F%E3%80%82-%E8%BF%99%E6%A0%B7%E5%81%9A%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84finalize-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%BC%93%E6%85%A2%EF%BC%8C%E6%88%96%E8%80%85%E6%9B%B4%E6%9E%81%E7%AB%AF%E5%9C%B0%E5%8F%91%E7%94%9F%E4%BA%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%B0%86%E5%BE%88%E5%8F%AF%E8%83%BD%E5%AF%BC-%E8%87%B4F-Queue%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1%E6%B0%B8%E4%B9%85%E5%A4%84%E4%BA%8E%E7%AD%89%E5%BE%85%EF%BC%8C%E7%94%9A%E8%87%B3%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AA%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B4%A9%E6%BA%83%E3%80%82-x3D-x3D-finalize-%E6%96%B9%E6%B3%95%E6%98%AF%E5%AF%B9-%E8%B1%A1%E9%80%83%E8%84%B1%E6%AD%BB%E4%BA%A1%E5%91%BD%E8%BF%90%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%9C%BA%E4%BC%9A%EF%BC%8C%E7%A8%8D%E5%90%8E%E6%94%B6%E9%9B%86%E5%99%A8%E5%B0%86%E5%AF%B9F-Queue%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%8F%E8%A7%84%E6%A8%A1%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AF%B9-%E8%B1%A1%E8%A6%81%E5%9C%A8finalize-%E4%B8%AD%E6%88%90%E5%8A%9F%E6%8B%AF%E6%95%91%E8%87%AA%E5%B7%B1%E2%80%94%E2%80%94%E5%8F%AA%E8%A6%81%E9%87%8D%E6%96%B0%E4%B8%8E%E5%BC%95%E7%94%A8%E9%93%BE%E4%B8%8A%E7%9A%84%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94%E5%8D%B3%E5%8F%AF%EF%BC%8C%E8%AD%AC%E5%A6%82%E6%8A%8A%E8%87%AA%E5%B7%B1-%EF%BC%88this%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89%E8%B5%8B%E5%80%BC%E7%BB%99%E6%9F%90%E4%B8%AA%E7%B1%BB%E5%8F%98%E9%87%8F%E6%88%96%E8%80%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%8C%E9%82%A3%E5%9C%A8%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%A0%87%E8%AE%B0%E6%97%B6%E5%AE%83%E5%B0%86%E8%A2%AB%E7%A7%BB%E5%87%BA%E2%80%9C%E5%8D%B3%E5%B0%86%E5%9B%9E%E6%94%B6%E2%80%9D%E7%9A%84%E9%9B%86%E5%90%88-x3D-x3D-%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%AF%B9%E8%B1%A1%E8%BF%99%E6%97%B6%E5%80%99%E8%BF%98%E6%B2%A1%E6%9C%89%E9%80%83%E8%84%B1%EF%BC%8C%E9%82%A3%E5%9F%BA%E6%9C%AC%E4%B8%8A%E5%AE%83%E5%B0%B1%E7%9C%9F%E7%9A%84%E8%A6%81%E8%A2%AB%E5%9B%9E%E6%94%B6%E4%BA%86%E3%80%82%E4%BB%8E%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%953-2%E4%B8%AD%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA-%E5%AF%B9%E8%B1%A1%E7%9A%84finalize-%E8%A2%AB%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%B4%BB"><span class="toc-number">1.3.2.25.</span> <span class="toc-text">如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize() 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。&#x3D;&#x3D;finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合&#x3D;&#x3D;；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。从代码清单3-2中我们可以看到一个 对象的finalize()被执行，但是它仍然可以存活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.3.2.26.</span> <span class="toc-text">3.2.5  回收方法区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BA%9B%E4%BA%BA%E8%AE%A4%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E5%A6%82HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%85%83%E7%A9%BA%E9%97%B4%E6%88%96%E8%80%85%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%89%E6%98%AF%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%A1%8C%E4%B8%BA%E7%9A%84%EF%BC%8C%E3%80%8AJava%E8%99%9A-%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%E3%80%8B%E4%B8%AD%E6%8F%90%E5%88%B0%E8%BF%87%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%A6%81%E6%B1%82%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%8C%E4%BA%8B%E5%AE%9E%E4%B8%8A%E4%B9%9F%E7%A1%AE%E5%AE%9E%E6%9C%89%E6%9C%AA%E5%AE%9E%E7%8E%B0%E6%88%96%E6%9C%AA%E8%83%BD%E5%AE%8C%E6%95%B4-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E7%B1%BB%E5%9E%8B%E5%8D%B8%E8%BD%BD%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8%E5%AD%98%E5%9C%A8%EF%BC%88%E5%A6%82JDK-11%E6%97%B6%E6%9C%9F%E7%9A%84ZGC%E6%94%B6%E9%9B%86%E5%99%A8%E5%B0%B1%E4%B8%8D%E6%94%AF%E6%8C%81%E7%B1%BB%E5%8D%B8%E8%BD%BD%EF%BC%89%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E7%9A%84%E2%80%9C%E6%80%A7%E4%BB%B7%E6%AF%94%E2%80%9D%E9%80%9A%E5%B8%B8%E4%B9%9F%E6%98%AF%E6%AF%94%E8%BE%83%E4%BD%8E%E7%9A%84%EF%BC%9A%E5%9C%A8Java%E5%A0%86%E4%B8%AD%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E5%9C%A8%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%AD%EF%BC%8C%E5%AF%B9%E5%B8%B8%E8%A7%84%E5%BA%94%E7%94%A8%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E9%80%9A%E5%B8%B8-%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B670-%E8%87%B399-%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%9B%B8%E6%AF%94%E4%B9%8B%E4%B8%8B%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%9E%E6%94%B6%E5%9B%BF%E4%BA%8E%E8%8B%9B%E5%88%BB%E7%9A%84%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%85%B6%E5%8C%BA%E5%9F%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E5%9B%9E-%E6%94%B6%E6%88%90%E6%9E%9C%E5%BE%80%E5%BE%80%E8%BF%9C%E4%BD%8E%E4%BA%8E%E6%AD%A4%E3%80%82"><span class="toc-number">1.3.2.27.</span> <span class="toc-text">有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚 拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整 实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回 收成果往往远低于此。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%BB%E8%A6%81%E5%9B%9E%E6%94%B6%E4%B8%A4%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%EF%BC%9A%E5%BA%9F%E5%BC%83%E7%9A%84%E5%B8%B8%E9%87%8F%E5%92%8C%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B-x3D-x3D-%E3%80%82%E5%9B%9E%E6%94%B6%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%9B%9E%E6%94%B6-Java%E5%A0%86%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%9D%9E%E5%B8%B8%E7%B1%BB%E4%BC%BC%E3%80%82%E4%B8%BE%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%AD%97%E9%9D%A2%E9%87%8F%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%81%87%E5%A6%82%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9Cjava%E2%80%9D%E6%9B%BE%E7%BB%8F%E8%BF%9B%E5%85%A5%E5%B8%B8%E9%87%8F%E6%B1%A0-%E4%B8%AD%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%8F%88%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E6%98%AF%E2%80%9Cjava%E2%80%9D%EF%BC%8C%E6%8D%A2%E5%8F%A5%E8%AF%9D%E8%AF%B4%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8-%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E2%80%9Cjava%E2%80%9D%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%B8%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E4%B9%9F%E6%B2%A1%E6%9C%89%E5%85%B6%E4%BB%96%E5%9C%B0%E6%96%B9%E5%BC%95%E7%94%A8%E8%BF%99%E4%B8%AA%E5%AD%97%E9%9D%A2%E9%87%8F%E3%80%82%E5%A6%82%E6%9E%9C%E5%9C%A8%E8%BF%99%E6%97%B6%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%EF%BC%8C%E8%80%8C%E4%B8%94-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%A4%E6%96%AD%E7%A1%AE%E6%9C%89%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%BF%99%E4%B8%AA%E2%80%9Cjava%E2%80%9D%E5%B8%B8%E9%87%8F%E5%B0%B1%E5%B0%86%E4%BC%9A%E8%A2%AB%E7%B3%BB%E7%BB%9F%E6%B8%85%E7%90%86%E5%87%BA%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%82%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%85%B6%E4%BB%96%E7%B1%BB%EF%BC%88%E6%8E%A5-%E5%8F%A3%EF%BC%89%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E5%AD%97%E6%AE%B5%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%B9%9F%E4%B8%8E%E6%AD%A4%E7%B1%BB%E4%BC%BC%E3%80%82"><span class="toc-number">1.3.2.28.</span> <span class="toc-text">&#x3D;&#x3D;方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型&#x3D;&#x3D;。回收废弃常量与回收 Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且 垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接 口）、方法、字段的符号引用也与此类似。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B8%B8%E9%87%8F%E6%98%AF%E5%90%A6%E2%80%9C%E5%BA%9F%E5%BC%83%E2%80%9D%E8%BF%98%E6%98%AF%E7%9B%B8%E5%AF%B9%E7%AE%80%E5%8D%95%EF%BC%8C%E8%80%8C%E8%A6%81%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E2%80%9C%E4%B8%8D%E5%86%8D%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB%E2%80%9D%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%B0%B1-%E6%AF%94%E8%BE%83%E8%8B%9B%E5%88%BB%E4%BA%86%E3%80%82%E9%9C%80%E8%A6%81-x3D-x3D-%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3-x3D-x3D-%E4%B8%8B%E9%9D%A2%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.3.2.29.</span> <span class="toc-text">定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要&#x3D;&#x3D;同时满足&#x3D;&#x3D;下面三个条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B7-x3D-x3D-%E8%AF%A5%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%AE%9E%E4%BE%8B%E9%83%BD%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6-x3D-x3D-%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AFJava%E5%A0%86%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%AF%A5%E7%B1%BB%E5%8F%8A%E5%85%B6%E4%BB%BB%E4%BD%95%E6%B4%BE%E7%94%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E3%80%82"><span class="toc-number">1.3.2.30.</span> <span class="toc-text">·&#x3D;&#x3D;该类所有的实例都已经被回收&#x3D;&#x3D;，也就是Java堆中不存在该类及其任何派生子类的实例。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B7-x3D-x3D-%E5%8A%A0%E8%BD%BD%E8%AF%A5%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%9B%9E%E6%94%B6-x3D-x3D-%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%9D%A1%E4%BB%B6%E9%99%A4%E9%9D%9E%E6%98%AF%E7%BB%8F%E8%BF%87%E7%B2%BE%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%8C%E5%A6%82-OSGi%E3%80%81JSP%E7%9A%84%E9%87%8D%E5%8A%A0%E8%BD%BD%E7%AD%89%EF%BC%8C%E5%90%A6%E5%88%99%E9%80%9A%E5%B8%B8%E6%98%AF%E5%BE%88%E9%9A%BE%E8%BE%BE%E6%88%90%E7%9A%84%E3%80%82"><span class="toc-number">1.3.2.31.</span> <span class="toc-text">·&#x3D;&#x3D;加载该类的类加载器已经被回收&#x3D;&#x3D;，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B7-x3D-x3D-%E8%AF%A5%E7%B1%BB%E5%AF%B9%E5%BA%94%E7%9A%84java-lang-Class%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9%E8%A2%AB%E5%BC%95%E7%94%A8-x3D-x3D-%EF%BC%8C%E6%97%A0%E6%B3%95%E5%9C%A8%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E8%AF%A5%E7%B1%BB%E7%9A%84%E6%96%B9-%E6%B3%95%E3%80%82"><span class="toc-number">1.3.2.32.</span> <span class="toc-text">·&#x3D;&#x3D;该类对应的java.lang.Class对象没有在任何地方被引用&#x3D;&#x3D;，无法在任何地方通过反射访问该类的方 法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%9C%A8%E5%A4%A7%E9%87%8F%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81CGLib%E7%AD%89%E5%AD%97%E8%8A%82%E7%A0%81%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90JSP%E4%BB%A5%E5%8F%8AOSGi%E8%BF%99%E7%B1%BB%E9%A2%91%E7%B9%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%99%A8%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B8%AD%EF%BC%8C%E9%80%9A%E5%B8%B8%E9%83%BD%E9%9C%80%E8%A6%81Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B7%E5%A4%87%E7%B1%BB%E5%9E%8B%E5%8D%B8%E8%BD%BD%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E4%BB%A5%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BC%9A%E5%AF%B9%E6%96%B9%E6%B3%95%E5%8C%BA%E9%80%A0%E6%88%90%E8%BF%87%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E5%8E%8B-%E5%8A%9B%E3%80%82-x3D-x3D"><span class="toc-number">1.3.2.33.</span> <span class="toc-text">&#x3D;&#x3D;在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3  垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%B6%88%E4%BA%A1%E7%9A%84%E8%A7%92%E5%BA%A6%E5%87%BA%E5%8F%91%EF%BC%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%88%92%E5%88%86%E4%B8%BA%E2%80%9C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E2%80%9D%EF%BC%88Reference-Counting-GC%EF%BC%89%E5%92%8C%E2%80%9C%E8%BF%BD%E8%B8%AA%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E2%80%9D%EF%BC%88Tracing-GC%EF%BC%89%E4%B8%A4%E5%A4%A7%E7%B1%BB%EF%BC%8C%E8%BF%99%E4%B8%A4%E7%B1%BB%E4%B9%9F%E5%B8%B8%E8%A2%AB%E7%A7%B0%E4%BD%9C%E2%80%9C%E7%9B%B4%E6%8E%A5%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E2%80%9D%E5%92%8C%E2%80%9C%E9%97%B4%E6%8E%A5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E2%80%9D%E3%80%82%E7%94%B1%E4%BA%8E%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%9C%A8%E6%9C%AC%E4%B9%A6%E8%AE%A8%E8%AE%BA%E5%88%B0%E7%9A%84%E4%B8%BB%E6%B5%81Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%9D%87%E6%9C%AA%E6%B6%89%E5%8F%8A%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E6%9A%82%E4%B8%8D-%E6%8A%8A%E5%AE%83%E4%BD%9C%E4%B8%BA%E6%AD%A3%E6%96%87%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E6%9D%A5%E8%AE%B2%E8%A7%A3%EF%BC%8C%E6%9C%AC%E8%8A%82%E4%BB%8B%E7%BB%8D%E7%9A%84%E6%89%80%E6%9C%89%E7%AE%97%E6%B3%95%E5%9D%87%E5%B1%9E%E4%BA%8E%E8%BF%BD%E8%B8%AA%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E8%8C%83%E7%95%B4%E3%80%82"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.1   分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%88%86%E4%BB%A3%E5%81%87%E8%AF%B4-week-generation-hypothesis-%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%98%AF%E6%9C%9D%E7%94%9F%E5%A4%95%E7%81%AD%E7%9A%84"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">弱分代假说(week generation hypothesis): 绝大多数对象都是朝生夕灭的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%86%E4%BB%A3%E5%81%87%E8%AF%B4-Strong-generation-hypothesis-%E7%86%AC%E8%BF%87%E8%B6%8A%E5%A4%9A%E6%AC%A1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E8%B6%8A%E9%9A%BE%E4%BB%A5%E6%B6%88%E4%BA%A1%E3%80%82"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">强分代假说(Strong generation hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%88%86%E4%BB%A3%E5%81%87%E8%AF%B4%E5%85%B1%E5%90%8C%E5%A5%A0%E5%AE%9A%E4%BA%86%E5%A4%9A%E6%AC%BE%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E4%B8%80%E8%87%B4%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9A-x3D-x3D-%E6%94%B6%E9%9B%86%E5%99%A8%E5%BA%94%E8%AF%A5%E5%B0%86Java%E5%A0%86%E5%88%92%E5%88%86-%E5%87%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8C%BA%E5%9F%9F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1%E4%BE%9D%E6%8D%AE%E5%85%B6%E5%B9%B4%E9%BE%84%EF%BC%88%E5%B9%B4%E9%BE%84%E5%8D%B3%E5%AF%B9%E8%B1%A1%E7%86%AC%E8%BF%87%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8C%BA-%E5%9F%9F%E4%B9%8B%E4%B8%AD%E5%AD%98%E5%82%A8%E3%80%82-x3D-x3D-%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9F%9F%E4%B8%AD%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%98%AF%E6%9C%9D%E7%94%9F%E5%A4%95%E7%81%AD%EF%BC%8C%E9%9A%BE%E4%BB%A5%E7%86%AC%E8%BF%87%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B%E7%9A%84%E8%AF%9D%EF%BC%8C%E9%82%A3-%E4%B9%88%E6%8A%8A%E5%AE%83%E4%BB%AC%E9%9B%86%E4%B8%AD%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%9B%9E%E6%94%B6%E6%97%B6%E5%8F%AA%E5%85%B3%E6%B3%A8%E5%A6%82%E4%BD%95%E4%BF%9D%E7%95%99%E5%B0%91%E9%87%8F%E5%AD%98%E6%B4%BB%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8E%BB%E6%A0%87%E8%AE%B0%E9%82%A3%E4%BA%9B%E5%A4%A7%E9%87%8F%E5%B0%86%E8%A6%81%E8%A2%AB%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AF%B9-%E8%B1%A1%EF%BC%8C%E5%B0%B1%E8%83%BD%E4%BB%A5%E8%BE%83%E4%BD%8E%E4%BB%A3%E4%BB%B7%E5%9B%9E%E6%94%B6%E5%88%B0%E5%A4%A7%E9%87%8F%E7%9A%84%E7%A9%BA%E9%97%B4%EF%BC%9B%E5%A6%82%E6%9E%9C%E5%89%A9%E4%B8%8B%E7%9A%84%E9%83%BD%E6%98%AF%E9%9A%BE%E4%BB%A5%E6%B6%88%E4%BA%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%82%A3%E6%8A%8A%E5%AE%83%E4%BB%AC%E9%9B%86%E4%B8%AD%E6%94%BE%E5%9C%A8%E4%B8%80%E5%9D%97%EF%BC%8C-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BE%BF%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%BE%83%E4%BD%8E%E7%9A%84%E9%A2%91%E7%8E%87%E6%9D%A5%E5%9B%9E%E6%94%B6%E8%BF%99%E4%B8%AA%E5%8C%BA%E5%9F%9F%EF%BC%8C%E8%BF%99%E5%B0%B1%E5%90%8C%E6%97%B6%E5%85%BC%E9%A1%BE%E4%BA%86%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E7%A9%BA%E9%97%B4%E6%9C%89-%E6%95%88%E5%88%A9%E7%94%A8%E3%80%82"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：&#x3D;&#x3D;收集器应该将Java堆划分 出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区 域之中存储。&#x3D;&#x3D;显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那 么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对 象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有 效利用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Java%E5%A0%86%E5%88%92%E5%88%86%E5%87%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8C%BA%E5%9F%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%89%8D%E5%8F%AF%E4%BB%A5%E6%AF%8F%E6%AC%A1%E5%8F%AA%E5%9B%9E%E6%94%B6%E5%85%B6%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E6%88%96%E8%80%85%E6%9F%90%E4%BA%9B%E9%83%A8%E5%88%86%E7%9A%84%E5%8C%BA%E5%9F%9F-%E2%80%94%E2%80%94%E5%9B%A0%E8%80%8C%E6%89%8D%E6%9C%89%E4%BA%86%E2%80%9CMinor-GC%E2%80%9D%E2%80%9CMajor-GC%E2%80%9D%E2%80%9CFull-GC%E2%80%9D%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9B%9E%E6%94%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%92%E5%88%86%EF%BC%9B%E4%B9%9F%E6%89%8D%E8%83%BD%E5%A4%9F%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%AE%89-%E6%8E%92%E4%B8%8E%E9%87%8C%E9%9D%A2%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E5%AD%98%E4%BA%A1%E7%89%B9%E5%BE%81%E7%9B%B8%E5%8C%B9%E9%85%8D%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9B%A0%E8%80%8C%E5%8F%91%E5%B1%95%E5%87%BA%E4%BA%86%E2%80%9C%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E2%80%9D%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97-%E6%B3%95%E2%80%9D%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%E2%80%9D%E7%AD%89%E9%92%88%E5%AF%B9%E6%80%A7%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E3%80%82%E8%BF%99%E9%87%8C%E7%AC%94%E8%80%85%E6%8F%90%E5%89%8D%E6%8F%90%E5%8F%8A%E4%BA%86%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E5%90%8D%E8%AF%8D%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%83%BD%E6%98%AF%E6%9C%AC%E7%AB%A0%E7%9A%84-%E9%87%8D%E8%A6%81%E8%A7%92%E8%89%B2%EF%BC%8C%E7%A8%8D%E5%90%8E%E9%83%BD%E4%BC%9A%E9%80%90%E4%B8%80%E7%99%BB%E5%9C%BA%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%AF%BB%E8%80%85%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%EF%BC%8C%E8%BF%99%E4%B8%80%E5%88%87%E7%9A%84%E5%87%BA%E7%8E%B0%E9%83%BD%E5%A7%8B%E4%BA%8E%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA%E3%80%82"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域 ——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安 排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算 法”“标记-整理算法”等针对性的垃圾收集算法。这里笔者提前提及了一些新的名词，它们都是本章的 重要角色，稍后都会逐一登场，现在读者只需要知道，这一切的出现都始于分代收集理论。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E5%81%87%E8%AF%B4%EF%BC%88Intergenerational-Reference-Hypothesis%EF%BC%89%EF%BC%9A%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%90%8C%E4%BB%A3%E5%BC%95%E7%94%A8%E6%9D%A5%E8%AF%B4%E4%BB%85%E5%8D%A0%E6%9E%81-%E5%B0%91%E6%95%B0%E3%80%82"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B7%E9%83%A8%E5%88%86%E6%94%B6%E9%9B%86%EF%BC%88Partial-GC%EF%BC%89%EF%BC%9A%E6%8C%87%E7%9B%AE%E6%A0%87%E4%B8%8D%E6%98%AF%E5%AE%8C%E6%95%B4%E6%94%B6%E9%9B%86%E6%95%B4%E4%B8%AAJava%E5%A0%86%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%8F%88%E5%88%86%E4%B8%BA%EF%BC%9A"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">·部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%96%A0%E6%96%B0%E7%94%9F%E4%BB%A3%E6%94%B6%E9%9B%86%EF%BC%88Minor-GC-x2F-Young-GC%EF%BC%89%EF%BC%9A%E6%8C%87%E7%9B%AE%E6%A0%87%E5%8F%AA%E6%98%AF%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.3.3.9.</span> <span class="toc-text">■新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%96%A0%E8%80%81%E5%B9%B4%E4%BB%A3%E6%94%B6%E9%9B%86%EF%BC%88Major-GC-x2F-Old-GC%EF%BC%89%EF%BC%9A%E6%8C%87%E7%9B%AE%E6%A0%87%E5%8F%AA%E6%98%AF%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E3%80%82%E7%9B%AE%E5%89%8D%E5%8F%AA%E6%9C%89CMS%E6%94%B6%E9%9B%86%E5%99%A8%E4%BC%9A%E6%9C%89%E5%8D%95-%E7%8B%AC%E6%94%B6%E9%9B%86%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E5%8F%A6%E5%A4%96%E8%AF%B7%E6%B3%A8%E6%84%8F%E2%80%9CMajor-GC%E2%80%9D%E8%BF%99%E4%B8%AA%E8%AF%B4%E6%B3%95%E7%8E%B0%E5%9C%A8%E6%9C%89%E7%82%B9%E6%B7%B7%E6%B7%86%EF%BC%8C%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%B5%84%E6%96%99%E4%B8%8A%E5%B8%B8%E6%9C%89%E4%B8%8D%E5%90%8C%E6%89%80%E6%8C%87%EF%BC%8C-%E8%AF%BB%E8%80%85%E9%9C%80%E6%8C%89%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8C%BA%E5%88%86%E5%88%B0%E5%BA%95%E6%98%AF%E6%8C%87%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%94%B6%E9%9B%86%E8%BF%98%E6%98%AF%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86%E3%80%82"><span class="toc-number">1.3.3.10.</span> <span class="toc-text">■老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%96%A0%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86%EF%BC%88Mixed-GC%EF%BC%89%EF%BC%9A%E6%8C%87%E7%9B%AE%E6%A0%87%E6%98%AF%E6%94%B6%E9%9B%86%E6%95%B4%E4%B8%AA%E6%96%B0%E7%94%9F%E4%BB%A3%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E3%80%82%E7%9B%AE%E5%89%8D%E5%8F%AA%E6%9C%89G1%E6%94%B6-%E9%9B%86%E5%99%A8%E4%BC%9A%E6%9C%89%E8%BF%99%E7%A7%8D%E8%A1%8C%E4%B8%BA%E3%80%82"><span class="toc-number">1.3.3.11.</span> <span class="toc-text">■混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%C2%B7%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86%EF%BC%88Full-GC%EF%BC%89%EF%BC%9A%E6%94%B6%E9%9B%86%E6%95%B4%E4%B8%AAJava%E5%A0%86%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E3%80%82"><span class="toc-number">1.3.3.12.</span> <span class="toc-text">·整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/03/ASMR/" title="ASMR"><img src="/image/suzy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ASMR"/></a><div class="content"><a class="title" href="/2023/06/03/ASMR/" title="ASMR">ASMR</a><time datetime="2023-06-03T09:55:52.000Z" title="发表于 2023-06-03 17:55:52">2023-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/25/git/" title="git"><img src="/image/suzy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/2022/10/25/git/" title="git">git</a><time datetime="2022-10-25T12:47:34.000Z" title="发表于 2022-10-25 20:47:34">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/19/mybatis/" title="mybatis"><img src="/image/suzy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mybatis"/></a><div class="content"><a class="title" href="/2022/10/19/mybatis/" title="mybatis">mybatis</a><time datetime="2022-10-19T15:32:43.000Z" title="发表于 2022-10-19 23:32:43">2022-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/18/Docker/" title="Docker"><img src="/image/suzy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2022/10/18/Docker/" title="Docker">Docker</a><time datetime="2022-10-18T03:29:39.000Z" title="发表于 2022-10-18 11:29:39">2022-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/" title="计算机网络面试"><img src="/image/suzy.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络面试"/></a><div class="content"><a class="title" href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95/" title="计算机网络面试">计算机网络面试</a><time datetime="2022-10-17T11:42:27.000Z" title="发表于 2022-10-17 19:42:27">2022-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ovesh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'b148acfa2ad0ea4de66f',
      clientSecret: 'ca24ef753b84ddbbe4649e22bceb5d576db878bb',
      repo: 'Oveshh.github.io',
      owner: 'Oveshh',
      admin: ['Oveshh'],
      id: '9e73c0cfc39daf21807a56ef67e686d5',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/10/15/JVM/'
    this.page.identifier = '/2022/10/15/JVM/'
    this.page.title = 'JVM'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Gitalk' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>